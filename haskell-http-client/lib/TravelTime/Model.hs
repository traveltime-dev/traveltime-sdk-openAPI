{-
   TravelTime API

   No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

   OpenAPI Version: 3.0.3
   TravelTime API API version: 1.2.2
   Contact: support@igeolise.com
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : TravelTime.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module TravelTime.Model where

import TravelTime.Core
import TravelTime.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** FocusLat
newtype FocusLat = FocusLat { unFocusLat :: Double } deriving (P.Eq, P.Show)

-- ** FocusLng
newtype FocusLng = FocusLng { unFocusLng :: Double } deriving (P.Eq, P.Show)

-- ** Lat
newtype Lat = Lat { unLat :: Double } deriving (P.Eq, P.Show)

-- ** Lng
newtype Lng = Lng { unLng :: Double } deriving (P.Eq, P.Show)

-- ** Query
newtype Query = Query { unQuery :: Text } deriving (P.Eq, P.Show)

-- ** WithinCountry
newtype WithinCountry = WithinCountry { unWithinCountry :: Text } deriving (P.Eq, P.Show)

-- * Models


-- ** Coords
-- | Coords
data Coords = Coords
  { coordsLat :: !(Double) -- ^ /Required/ "lat"
  , coordsLng :: !(Double) -- ^ /Required/ "lng"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Coords
instance A.FromJSON Coords where
  parseJSON = A.withObject "Coords" $ \o ->
    Coords
      <$> (o .:  "lat")
      <*> (o .:  "lng")

-- | ToJSON Coords
instance A.ToJSON Coords where
  toJSON Coords {..} =
   _omitNulls
      [ "lat" .= coordsLat
      , "lng" .= coordsLng
      ]


-- | Construct a value of type 'Coords' (by applying it's required fields, if any)
mkCoords
  :: Double -- ^ 'coordsLat' 
  -> Double -- ^ 'coordsLng' 
  -> Coords
mkCoords coordsLat coordsLng =
  Coords
  { coordsLat
  , coordsLng
  }

-- ** RequestLocation
-- | RequestLocation
data RequestLocation = RequestLocation
  { requestLocationId :: !(Text) -- ^ /Required/ "id"
  , requestLocationCoords :: !(Coords) -- ^ /Required/ "coords"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RequestLocation
instance A.FromJSON RequestLocation where
  parseJSON = A.withObject "RequestLocation" $ \o ->
    RequestLocation
      <$> (o .:  "id")
      <*> (o .:  "coords")

-- | ToJSON RequestLocation
instance A.ToJSON RequestLocation where
  toJSON RequestLocation {..} =
   _omitNulls
      [ "id" .= requestLocationId
      , "coords" .= requestLocationCoords
      ]


-- | Construct a value of type 'RequestLocation' (by applying it's required fields, if any)
mkRequestLocation
  :: Text -- ^ 'requestLocationId' 
  -> Coords -- ^ 'requestLocationCoords' 
  -> RequestLocation
mkRequestLocation requestLocationId requestLocationCoords =
  RequestLocation
  { requestLocationId
  , requestLocationCoords
  }

-- ** RequestRangeFull
-- | RequestRangeFull
data RequestRangeFull = RequestRangeFull
  { requestRangeFullEnabled :: !(Bool) -- ^ /Required/ "enabled"
  , requestRangeFullMaxResults :: !(Int) -- ^ /Required/ "max_results"
  , requestRangeFullWidth :: !(Int) -- ^ /Required/ "width"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RequestRangeFull
instance A.FromJSON RequestRangeFull where
  parseJSON = A.withObject "RequestRangeFull" $ \o ->
    RequestRangeFull
      <$> (o .:  "enabled")
      <*> (o .:  "max_results")
      <*> (o .:  "width")

-- | ToJSON RequestRangeFull
instance A.ToJSON RequestRangeFull where
  toJSON RequestRangeFull {..} =
   _omitNulls
      [ "enabled" .= requestRangeFullEnabled
      , "max_results" .= requestRangeFullMaxResults
      , "width" .= requestRangeFullWidth
      ]


-- | Construct a value of type 'RequestRangeFull' (by applying it's required fields, if any)
mkRequestRangeFull
  :: Bool -- ^ 'requestRangeFullEnabled' 
  -> Int -- ^ 'requestRangeFullMaxResults' 
  -> Int -- ^ 'requestRangeFullWidth' 
  -> RequestRangeFull
mkRequestRangeFull requestRangeFullEnabled requestRangeFullMaxResults requestRangeFullWidth =
  RequestRangeFull
  { requestRangeFullEnabled
  , requestRangeFullMaxResults
  , requestRangeFullWidth
  }

-- ** RequestRangeNoMaxResults
-- | RequestRangeNoMaxResults
data RequestRangeNoMaxResults = RequestRangeNoMaxResults
  { requestRangeNoMaxResultsEnabled :: !(Bool) -- ^ /Required/ "enabled"
  , requestRangeNoMaxResultsWidth :: !(Int) -- ^ /Required/ "width"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RequestRangeNoMaxResults
instance A.FromJSON RequestRangeNoMaxResults where
  parseJSON = A.withObject "RequestRangeNoMaxResults" $ \o ->
    RequestRangeNoMaxResults
      <$> (o .:  "enabled")
      <*> (o .:  "width")

-- | ToJSON RequestRangeNoMaxResults
instance A.ToJSON RequestRangeNoMaxResults where
  toJSON RequestRangeNoMaxResults {..} =
   _omitNulls
      [ "enabled" .= requestRangeNoMaxResultsEnabled
      , "width" .= requestRangeNoMaxResultsWidth
      ]


-- | Construct a value of type 'RequestRangeNoMaxResults' (by applying it's required fields, if any)
mkRequestRangeNoMaxResults
  :: Bool -- ^ 'requestRangeNoMaxResultsEnabled' 
  -> Int -- ^ 'requestRangeNoMaxResultsWidth' 
  -> RequestRangeNoMaxResults
mkRequestRangeNoMaxResults requestRangeNoMaxResultsEnabled requestRangeNoMaxResultsWidth =
  RequestRangeNoMaxResults
  { requestRangeNoMaxResultsEnabled
  , requestRangeNoMaxResultsWidth
  }

-- ** RequestRoutes
-- | RequestRoutes
data RequestRoutes = RequestRoutes
  { requestRoutesLocations :: !([RequestLocation]) -- ^ /Required/ "locations"
  , requestRoutesDepartureSearches :: !(Maybe [RequestRoutesDepartureSearch]) -- ^ "departure_searches"
  , requestRoutesArrivalSearches :: !(Maybe [RequestRoutesArrivalSearch]) -- ^ "arrival_searches"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RequestRoutes
instance A.FromJSON RequestRoutes where
  parseJSON = A.withObject "RequestRoutes" $ \o ->
    RequestRoutes
      <$> (o .:  "locations")
      <*> (o .:? "departure_searches")
      <*> (o .:? "arrival_searches")

-- | ToJSON RequestRoutes
instance A.ToJSON RequestRoutes where
  toJSON RequestRoutes {..} =
   _omitNulls
      [ "locations" .= requestRoutesLocations
      , "departure_searches" .= requestRoutesDepartureSearches
      , "arrival_searches" .= requestRoutesArrivalSearches
      ]


-- | Construct a value of type 'RequestRoutes' (by applying it's required fields, if any)
mkRequestRoutes
  :: [RequestLocation] -- ^ 'requestRoutesLocations' 
  -> RequestRoutes
mkRequestRoutes requestRoutesLocations =
  RequestRoutes
  { requestRoutesLocations
  , requestRoutesDepartureSearches = Nothing
  , requestRoutesArrivalSearches = Nothing
  }

-- ** RequestRoutesArrivalSearch
-- | RequestRoutesArrivalSearch
data RequestRoutesArrivalSearch = RequestRoutesArrivalSearch
  { requestRoutesArrivalSearchId :: !(Text) -- ^ /Required/ "id"
  , requestRoutesArrivalSearchDepartureLocationIds :: !([Text]) -- ^ /Required/ "departure_location_ids"
  , requestRoutesArrivalSearchArrivalLocationId :: !(Text) -- ^ /Required/ "arrival_location_id"
  , requestRoutesArrivalSearchTransportation :: !(RequestTransportation) -- ^ /Required/ "transportation"
  , requestRoutesArrivalSearchArrivalTime :: !(DateTime) -- ^ /Required/ "arrival_time"
  , requestRoutesArrivalSearchProperties :: !([RequestRoutesProperty]) -- ^ /Required/ "properties"
  , requestRoutesArrivalSearchRange :: !(Maybe RequestRangeFull) -- ^ "range"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RequestRoutesArrivalSearch
instance A.FromJSON RequestRoutesArrivalSearch where
  parseJSON = A.withObject "RequestRoutesArrivalSearch" $ \o ->
    RequestRoutesArrivalSearch
      <$> (o .:  "id")
      <*> (o .:  "departure_location_ids")
      <*> (o .:  "arrival_location_id")
      <*> (o .:  "transportation")
      <*> (o .:  "arrival_time")
      <*> (o .:  "properties")
      <*> (o .:? "range")

-- | ToJSON RequestRoutesArrivalSearch
instance A.ToJSON RequestRoutesArrivalSearch where
  toJSON RequestRoutesArrivalSearch {..} =
   _omitNulls
      [ "id" .= requestRoutesArrivalSearchId
      , "departure_location_ids" .= requestRoutesArrivalSearchDepartureLocationIds
      , "arrival_location_id" .= requestRoutesArrivalSearchArrivalLocationId
      , "transportation" .= requestRoutesArrivalSearchTransportation
      , "arrival_time" .= requestRoutesArrivalSearchArrivalTime
      , "properties" .= requestRoutesArrivalSearchProperties
      , "range" .= requestRoutesArrivalSearchRange
      ]


-- | Construct a value of type 'RequestRoutesArrivalSearch' (by applying it's required fields, if any)
mkRequestRoutesArrivalSearch
  :: Text -- ^ 'requestRoutesArrivalSearchId' 
  -> [Text] -- ^ 'requestRoutesArrivalSearchDepartureLocationIds' 
  -> Text -- ^ 'requestRoutesArrivalSearchArrivalLocationId' 
  -> RequestTransportation -- ^ 'requestRoutesArrivalSearchTransportation' 
  -> DateTime -- ^ 'requestRoutesArrivalSearchArrivalTime' 
  -> [RequestRoutesProperty] -- ^ 'requestRoutesArrivalSearchProperties' 
  -> RequestRoutesArrivalSearch
mkRequestRoutesArrivalSearch requestRoutesArrivalSearchId requestRoutesArrivalSearchDepartureLocationIds requestRoutesArrivalSearchArrivalLocationId requestRoutesArrivalSearchTransportation requestRoutesArrivalSearchArrivalTime requestRoutesArrivalSearchProperties =
  RequestRoutesArrivalSearch
  { requestRoutesArrivalSearchId
  , requestRoutesArrivalSearchDepartureLocationIds
  , requestRoutesArrivalSearchArrivalLocationId
  , requestRoutesArrivalSearchTransportation
  , requestRoutesArrivalSearchArrivalTime
  , requestRoutesArrivalSearchProperties
  , requestRoutesArrivalSearchRange = Nothing
  }

-- ** RequestRoutesDepartureSearch
-- | RequestRoutesDepartureSearch
data RequestRoutesDepartureSearch = RequestRoutesDepartureSearch
  { requestRoutesDepartureSearchId :: !(Text) -- ^ /Required/ "id"
  , requestRoutesDepartureSearchDepartureLocationId :: !(Text) -- ^ /Required/ "departure_location_id"
  , requestRoutesDepartureSearchArrivalLocationIds :: !([Text]) -- ^ /Required/ "arrival_location_ids"
  , requestRoutesDepartureSearchTransportation :: !(RequestTransportation) -- ^ /Required/ "transportation"
  , requestRoutesDepartureSearchDepartureTime :: !(DateTime) -- ^ /Required/ "departure_time"
  , requestRoutesDepartureSearchProperties :: !([RequestRoutesProperty]) -- ^ /Required/ "properties"
  , requestRoutesDepartureSearchRange :: !(Maybe RequestRangeFull) -- ^ "range"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RequestRoutesDepartureSearch
instance A.FromJSON RequestRoutesDepartureSearch where
  parseJSON = A.withObject "RequestRoutesDepartureSearch" $ \o ->
    RequestRoutesDepartureSearch
      <$> (o .:  "id")
      <*> (o .:  "departure_location_id")
      <*> (o .:  "arrival_location_ids")
      <*> (o .:  "transportation")
      <*> (o .:  "departure_time")
      <*> (o .:  "properties")
      <*> (o .:? "range")

-- | ToJSON RequestRoutesDepartureSearch
instance A.ToJSON RequestRoutesDepartureSearch where
  toJSON RequestRoutesDepartureSearch {..} =
   _omitNulls
      [ "id" .= requestRoutesDepartureSearchId
      , "departure_location_id" .= requestRoutesDepartureSearchDepartureLocationId
      , "arrival_location_ids" .= requestRoutesDepartureSearchArrivalLocationIds
      , "transportation" .= requestRoutesDepartureSearchTransportation
      , "departure_time" .= requestRoutesDepartureSearchDepartureTime
      , "properties" .= requestRoutesDepartureSearchProperties
      , "range" .= requestRoutesDepartureSearchRange
      ]


-- | Construct a value of type 'RequestRoutesDepartureSearch' (by applying it's required fields, if any)
mkRequestRoutesDepartureSearch
  :: Text -- ^ 'requestRoutesDepartureSearchId' 
  -> Text -- ^ 'requestRoutesDepartureSearchDepartureLocationId' 
  -> [Text] -- ^ 'requestRoutesDepartureSearchArrivalLocationIds' 
  -> RequestTransportation -- ^ 'requestRoutesDepartureSearchTransportation' 
  -> DateTime -- ^ 'requestRoutesDepartureSearchDepartureTime' 
  -> [RequestRoutesProperty] -- ^ 'requestRoutesDepartureSearchProperties' 
  -> RequestRoutesDepartureSearch
mkRequestRoutesDepartureSearch requestRoutesDepartureSearchId requestRoutesDepartureSearchDepartureLocationId requestRoutesDepartureSearchArrivalLocationIds requestRoutesDepartureSearchTransportation requestRoutesDepartureSearchDepartureTime requestRoutesDepartureSearchProperties =
  RequestRoutesDepartureSearch
  { requestRoutesDepartureSearchId
  , requestRoutesDepartureSearchDepartureLocationId
  , requestRoutesDepartureSearchArrivalLocationIds
  , requestRoutesDepartureSearchTransportation
  , requestRoutesDepartureSearchDepartureTime
  , requestRoutesDepartureSearchProperties
  , requestRoutesDepartureSearchRange = Nothing
  }

-- ** RequestSupportedLocations
-- | RequestSupportedLocations
data RequestSupportedLocations = RequestSupportedLocations
  { requestSupportedLocationsLocations :: !([RequestLocation]) -- ^ /Required/ "locations"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RequestSupportedLocations
instance A.FromJSON RequestSupportedLocations where
  parseJSON = A.withObject "RequestSupportedLocations" $ \o ->
    RequestSupportedLocations
      <$> (o .:  "locations")

-- | ToJSON RequestSupportedLocations
instance A.ToJSON RequestSupportedLocations where
  toJSON RequestSupportedLocations {..} =
   _omitNulls
      [ "locations" .= requestSupportedLocationsLocations
      ]


-- | Construct a value of type 'RequestSupportedLocations' (by applying it's required fields, if any)
mkRequestSupportedLocations
  :: [RequestLocation] -- ^ 'requestSupportedLocationsLocations' 
  -> RequestSupportedLocations
mkRequestSupportedLocations requestSupportedLocationsLocations =
  RequestSupportedLocations
  { requestSupportedLocationsLocations
  }

-- ** RequestTimeFilter
-- | RequestTimeFilter
data RequestTimeFilter = RequestTimeFilter
  { requestTimeFilterLocations :: !([RequestLocation]) -- ^ /Required/ "locations"
  , requestTimeFilterDepartureSearches :: !(Maybe [RequestTimeFilterDepartureSearch]) -- ^ "departure_searches"
  , requestTimeFilterArrivalSearches :: !(Maybe [RequestTimeFilterArrivalSearch]) -- ^ "arrival_searches"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RequestTimeFilter
instance A.FromJSON RequestTimeFilter where
  parseJSON = A.withObject "RequestTimeFilter" $ \o ->
    RequestTimeFilter
      <$> (o .:  "locations")
      <*> (o .:? "departure_searches")
      <*> (o .:? "arrival_searches")

-- | ToJSON RequestTimeFilter
instance A.ToJSON RequestTimeFilter where
  toJSON RequestTimeFilter {..} =
   _omitNulls
      [ "locations" .= requestTimeFilterLocations
      , "departure_searches" .= requestTimeFilterDepartureSearches
      , "arrival_searches" .= requestTimeFilterArrivalSearches
      ]


-- | Construct a value of type 'RequestTimeFilter' (by applying it's required fields, if any)
mkRequestTimeFilter
  :: [RequestLocation] -- ^ 'requestTimeFilterLocations' 
  -> RequestTimeFilter
mkRequestTimeFilter requestTimeFilterLocations =
  RequestTimeFilter
  { requestTimeFilterLocations
  , requestTimeFilterDepartureSearches = Nothing
  , requestTimeFilterArrivalSearches = Nothing
  }

-- ** RequestTimeFilterArrivalSearch
-- | RequestTimeFilterArrivalSearch
data RequestTimeFilterArrivalSearch = RequestTimeFilterArrivalSearch
  { requestTimeFilterArrivalSearchId :: !(Text) -- ^ /Required/ "id"
  , requestTimeFilterArrivalSearchDepartureLocationIds :: !([Text]) -- ^ /Required/ "departure_location_ids"
  , requestTimeFilterArrivalSearchArrivalLocationId :: !(Text) -- ^ /Required/ "arrival_location_id"
  , requestTimeFilterArrivalSearchTransportation :: !(RequestTransportation) -- ^ /Required/ "transportation"
  , requestTimeFilterArrivalSearchTravelTime :: !(Int) -- ^ /Required/ "travel_time"
  , requestTimeFilterArrivalSearchArrivalTime :: !(DateTime) -- ^ /Required/ "arrival_time"
  , requestTimeFilterArrivalSearchProperties :: !([RequestTimeFilterProperty]) -- ^ /Required/ "properties"
  , requestTimeFilterArrivalSearchRange :: !(Maybe RequestRangeFull) -- ^ "range"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RequestTimeFilterArrivalSearch
instance A.FromJSON RequestTimeFilterArrivalSearch where
  parseJSON = A.withObject "RequestTimeFilterArrivalSearch" $ \o ->
    RequestTimeFilterArrivalSearch
      <$> (o .:  "id")
      <*> (o .:  "departure_location_ids")
      <*> (o .:  "arrival_location_id")
      <*> (o .:  "transportation")
      <*> (o .:  "travel_time")
      <*> (o .:  "arrival_time")
      <*> (o .:  "properties")
      <*> (o .:? "range")

-- | ToJSON RequestTimeFilterArrivalSearch
instance A.ToJSON RequestTimeFilterArrivalSearch where
  toJSON RequestTimeFilterArrivalSearch {..} =
   _omitNulls
      [ "id" .= requestTimeFilterArrivalSearchId
      , "departure_location_ids" .= requestTimeFilterArrivalSearchDepartureLocationIds
      , "arrival_location_id" .= requestTimeFilterArrivalSearchArrivalLocationId
      , "transportation" .= requestTimeFilterArrivalSearchTransportation
      , "travel_time" .= requestTimeFilterArrivalSearchTravelTime
      , "arrival_time" .= requestTimeFilterArrivalSearchArrivalTime
      , "properties" .= requestTimeFilterArrivalSearchProperties
      , "range" .= requestTimeFilterArrivalSearchRange
      ]


-- | Construct a value of type 'RequestTimeFilterArrivalSearch' (by applying it's required fields, if any)
mkRequestTimeFilterArrivalSearch
  :: Text -- ^ 'requestTimeFilterArrivalSearchId' 
  -> [Text] -- ^ 'requestTimeFilterArrivalSearchDepartureLocationIds' 
  -> Text -- ^ 'requestTimeFilterArrivalSearchArrivalLocationId' 
  -> RequestTransportation -- ^ 'requestTimeFilterArrivalSearchTransportation' 
  -> Int -- ^ 'requestTimeFilterArrivalSearchTravelTime' 
  -> DateTime -- ^ 'requestTimeFilterArrivalSearchArrivalTime' 
  -> [RequestTimeFilterProperty] -- ^ 'requestTimeFilterArrivalSearchProperties' 
  -> RequestTimeFilterArrivalSearch
mkRequestTimeFilterArrivalSearch requestTimeFilterArrivalSearchId requestTimeFilterArrivalSearchDepartureLocationIds requestTimeFilterArrivalSearchArrivalLocationId requestTimeFilterArrivalSearchTransportation requestTimeFilterArrivalSearchTravelTime requestTimeFilterArrivalSearchArrivalTime requestTimeFilterArrivalSearchProperties =
  RequestTimeFilterArrivalSearch
  { requestTimeFilterArrivalSearchId
  , requestTimeFilterArrivalSearchDepartureLocationIds
  , requestTimeFilterArrivalSearchArrivalLocationId
  , requestTimeFilterArrivalSearchTransportation
  , requestTimeFilterArrivalSearchTravelTime
  , requestTimeFilterArrivalSearchArrivalTime
  , requestTimeFilterArrivalSearchProperties
  , requestTimeFilterArrivalSearchRange = Nothing
  }

-- ** RequestTimeFilterDepartureSearch
-- | RequestTimeFilterDepartureSearch
data RequestTimeFilterDepartureSearch = RequestTimeFilterDepartureSearch
  { requestTimeFilterDepartureSearchId :: !(Text) -- ^ /Required/ "id"
  , requestTimeFilterDepartureSearchDepartureLocationId :: !(Text) -- ^ /Required/ "departure_location_id"
  , requestTimeFilterDepartureSearchArrivalLocationIds :: !([Text]) -- ^ /Required/ "arrival_location_ids"
  , requestTimeFilterDepartureSearchTransportation :: !(RequestTransportation) -- ^ /Required/ "transportation"
  , requestTimeFilterDepartureSearchTravelTime :: !(Int) -- ^ /Required/ "travel_time"
  , requestTimeFilterDepartureSearchDepartureTime :: !(DateTime) -- ^ /Required/ "departure_time"
  , requestTimeFilterDepartureSearchProperties :: !([RequestTimeFilterProperty]) -- ^ /Required/ "properties"
  , requestTimeFilterDepartureSearchRange :: !(Maybe RequestRangeFull) -- ^ "range"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RequestTimeFilterDepartureSearch
instance A.FromJSON RequestTimeFilterDepartureSearch where
  parseJSON = A.withObject "RequestTimeFilterDepartureSearch" $ \o ->
    RequestTimeFilterDepartureSearch
      <$> (o .:  "id")
      <*> (o .:  "departure_location_id")
      <*> (o .:  "arrival_location_ids")
      <*> (o .:  "transportation")
      <*> (o .:  "travel_time")
      <*> (o .:  "departure_time")
      <*> (o .:  "properties")
      <*> (o .:? "range")

-- | ToJSON RequestTimeFilterDepartureSearch
instance A.ToJSON RequestTimeFilterDepartureSearch where
  toJSON RequestTimeFilterDepartureSearch {..} =
   _omitNulls
      [ "id" .= requestTimeFilterDepartureSearchId
      , "departure_location_id" .= requestTimeFilterDepartureSearchDepartureLocationId
      , "arrival_location_ids" .= requestTimeFilterDepartureSearchArrivalLocationIds
      , "transportation" .= requestTimeFilterDepartureSearchTransportation
      , "travel_time" .= requestTimeFilterDepartureSearchTravelTime
      , "departure_time" .= requestTimeFilterDepartureSearchDepartureTime
      , "properties" .= requestTimeFilterDepartureSearchProperties
      , "range" .= requestTimeFilterDepartureSearchRange
      ]


-- | Construct a value of type 'RequestTimeFilterDepartureSearch' (by applying it's required fields, if any)
mkRequestTimeFilterDepartureSearch
  :: Text -- ^ 'requestTimeFilterDepartureSearchId' 
  -> Text -- ^ 'requestTimeFilterDepartureSearchDepartureLocationId' 
  -> [Text] -- ^ 'requestTimeFilterDepartureSearchArrivalLocationIds' 
  -> RequestTransportation -- ^ 'requestTimeFilterDepartureSearchTransportation' 
  -> Int -- ^ 'requestTimeFilterDepartureSearchTravelTime' 
  -> DateTime -- ^ 'requestTimeFilterDepartureSearchDepartureTime' 
  -> [RequestTimeFilterProperty] -- ^ 'requestTimeFilterDepartureSearchProperties' 
  -> RequestTimeFilterDepartureSearch
mkRequestTimeFilterDepartureSearch requestTimeFilterDepartureSearchId requestTimeFilterDepartureSearchDepartureLocationId requestTimeFilterDepartureSearchArrivalLocationIds requestTimeFilterDepartureSearchTransportation requestTimeFilterDepartureSearchTravelTime requestTimeFilterDepartureSearchDepartureTime requestTimeFilterDepartureSearchProperties =
  RequestTimeFilterDepartureSearch
  { requestTimeFilterDepartureSearchId
  , requestTimeFilterDepartureSearchDepartureLocationId
  , requestTimeFilterDepartureSearchArrivalLocationIds
  , requestTimeFilterDepartureSearchTransportation
  , requestTimeFilterDepartureSearchTravelTime
  , requestTimeFilterDepartureSearchDepartureTime
  , requestTimeFilterDepartureSearchProperties
  , requestTimeFilterDepartureSearchRange = Nothing
  }

-- ** RequestTimeFilterFast
-- | RequestTimeFilterFast
data RequestTimeFilterFast = RequestTimeFilterFast
  { requestTimeFilterFastLocations :: !([RequestLocation]) -- ^ /Required/ "locations"
  , requestTimeFilterFastArrivalSearches :: !(RequestTimeFilterFastArrivalSearches) -- ^ /Required/ "arrival_searches"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RequestTimeFilterFast
instance A.FromJSON RequestTimeFilterFast where
  parseJSON = A.withObject "RequestTimeFilterFast" $ \o ->
    RequestTimeFilterFast
      <$> (o .:  "locations")
      <*> (o .:  "arrival_searches")

-- | ToJSON RequestTimeFilterFast
instance A.ToJSON RequestTimeFilterFast where
  toJSON RequestTimeFilterFast {..} =
   _omitNulls
      [ "locations" .= requestTimeFilterFastLocations
      , "arrival_searches" .= requestTimeFilterFastArrivalSearches
      ]


-- | Construct a value of type 'RequestTimeFilterFast' (by applying it's required fields, if any)
mkRequestTimeFilterFast
  :: [RequestLocation] -- ^ 'requestTimeFilterFastLocations' 
  -> RequestTimeFilterFastArrivalSearches -- ^ 'requestTimeFilterFastArrivalSearches' 
  -> RequestTimeFilterFast
mkRequestTimeFilterFast requestTimeFilterFastLocations requestTimeFilterFastArrivalSearches =
  RequestTimeFilterFast
  { requestTimeFilterFastLocations
  , requestTimeFilterFastArrivalSearches
  }

-- ** RequestTimeFilterFastArrivalManyToOneSearch
-- | RequestTimeFilterFastArrivalManyToOneSearch
data RequestTimeFilterFastArrivalManyToOneSearch = RequestTimeFilterFastArrivalManyToOneSearch
  { requestTimeFilterFastArrivalManyToOneSearchId :: !(Text) -- ^ /Required/ "id"
  , requestTimeFilterFastArrivalManyToOneSearchArrivalLocationId :: !(Text) -- ^ /Required/ "arrival_location_id"
  , requestTimeFilterFastArrivalManyToOneSearchDepartureLocationIds :: !([Text]) -- ^ /Required/ "departure_location_ids"
  , requestTimeFilterFastArrivalManyToOneSearchTransportation :: !(RequestTransportationFast) -- ^ /Required/ "transportation"
  , requestTimeFilterFastArrivalManyToOneSearchTravelTime :: !(Int) -- ^ /Required/ "travel_time"
  , requestTimeFilterFastArrivalManyToOneSearchArrivalTimePeriod :: !(RequestArrivalTimePeriod) -- ^ /Required/ "arrival_time_period"
  , requestTimeFilterFastArrivalManyToOneSearchProperties :: !([RequestTimeFilterFastProperty]) -- ^ /Required/ "properties"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RequestTimeFilterFastArrivalManyToOneSearch
instance A.FromJSON RequestTimeFilterFastArrivalManyToOneSearch where
  parseJSON = A.withObject "RequestTimeFilterFastArrivalManyToOneSearch" $ \o ->
    RequestTimeFilterFastArrivalManyToOneSearch
      <$> (o .:  "id")
      <*> (o .:  "arrival_location_id")
      <*> (o .:  "departure_location_ids")
      <*> (o .:  "transportation")
      <*> (o .:  "travel_time")
      <*> (o .:  "arrival_time_period")
      <*> (o .:  "properties")

-- | ToJSON RequestTimeFilterFastArrivalManyToOneSearch
instance A.ToJSON RequestTimeFilterFastArrivalManyToOneSearch where
  toJSON RequestTimeFilterFastArrivalManyToOneSearch {..} =
   _omitNulls
      [ "id" .= requestTimeFilterFastArrivalManyToOneSearchId
      , "arrival_location_id" .= requestTimeFilterFastArrivalManyToOneSearchArrivalLocationId
      , "departure_location_ids" .= requestTimeFilterFastArrivalManyToOneSearchDepartureLocationIds
      , "transportation" .= requestTimeFilterFastArrivalManyToOneSearchTransportation
      , "travel_time" .= requestTimeFilterFastArrivalManyToOneSearchTravelTime
      , "arrival_time_period" .= requestTimeFilterFastArrivalManyToOneSearchArrivalTimePeriod
      , "properties" .= requestTimeFilterFastArrivalManyToOneSearchProperties
      ]


-- | Construct a value of type 'RequestTimeFilterFastArrivalManyToOneSearch' (by applying it's required fields, if any)
mkRequestTimeFilterFastArrivalManyToOneSearch
  :: Text -- ^ 'requestTimeFilterFastArrivalManyToOneSearchId' 
  -> Text -- ^ 'requestTimeFilterFastArrivalManyToOneSearchArrivalLocationId' 
  -> [Text] -- ^ 'requestTimeFilterFastArrivalManyToOneSearchDepartureLocationIds' 
  -> RequestTransportationFast -- ^ 'requestTimeFilterFastArrivalManyToOneSearchTransportation' 
  -> Int -- ^ 'requestTimeFilterFastArrivalManyToOneSearchTravelTime' 
  -> RequestArrivalTimePeriod -- ^ 'requestTimeFilterFastArrivalManyToOneSearchArrivalTimePeriod' 
  -> [RequestTimeFilterFastProperty] -- ^ 'requestTimeFilterFastArrivalManyToOneSearchProperties' 
  -> RequestTimeFilterFastArrivalManyToOneSearch
mkRequestTimeFilterFastArrivalManyToOneSearch requestTimeFilterFastArrivalManyToOneSearchId requestTimeFilterFastArrivalManyToOneSearchArrivalLocationId requestTimeFilterFastArrivalManyToOneSearchDepartureLocationIds requestTimeFilterFastArrivalManyToOneSearchTransportation requestTimeFilterFastArrivalManyToOneSearchTravelTime requestTimeFilterFastArrivalManyToOneSearchArrivalTimePeriod requestTimeFilterFastArrivalManyToOneSearchProperties =
  RequestTimeFilterFastArrivalManyToOneSearch
  { requestTimeFilterFastArrivalManyToOneSearchId
  , requestTimeFilterFastArrivalManyToOneSearchArrivalLocationId
  , requestTimeFilterFastArrivalManyToOneSearchDepartureLocationIds
  , requestTimeFilterFastArrivalManyToOneSearchTransportation
  , requestTimeFilterFastArrivalManyToOneSearchTravelTime
  , requestTimeFilterFastArrivalManyToOneSearchArrivalTimePeriod
  , requestTimeFilterFastArrivalManyToOneSearchProperties
  }

-- ** RequestTimeFilterFastArrivalOneToManySearch
-- | RequestTimeFilterFastArrivalOneToManySearch
data RequestTimeFilterFastArrivalOneToManySearch = RequestTimeFilterFastArrivalOneToManySearch
  { requestTimeFilterFastArrivalOneToManySearchId :: !(Text) -- ^ /Required/ "id"
  , requestTimeFilterFastArrivalOneToManySearchDepartureLocationId :: !(Text) -- ^ /Required/ "departure_location_id"
  , requestTimeFilterFastArrivalOneToManySearchArrivalLocationIds :: !([Text]) -- ^ /Required/ "arrival_location_ids"
  , requestTimeFilterFastArrivalOneToManySearchTransportation :: !(RequestTransportationFast) -- ^ /Required/ "transportation"
  , requestTimeFilterFastArrivalOneToManySearchTravelTime :: !(Int) -- ^ /Required/ "travel_time"
  , requestTimeFilterFastArrivalOneToManySearchArrivalTimePeriod :: !(RequestArrivalTimePeriod) -- ^ /Required/ "arrival_time_period"
  , requestTimeFilterFastArrivalOneToManySearchProperties :: !([RequestTimeFilterFastProperty]) -- ^ /Required/ "properties"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RequestTimeFilterFastArrivalOneToManySearch
instance A.FromJSON RequestTimeFilterFastArrivalOneToManySearch where
  parseJSON = A.withObject "RequestTimeFilterFastArrivalOneToManySearch" $ \o ->
    RequestTimeFilterFastArrivalOneToManySearch
      <$> (o .:  "id")
      <*> (o .:  "departure_location_id")
      <*> (o .:  "arrival_location_ids")
      <*> (o .:  "transportation")
      <*> (o .:  "travel_time")
      <*> (o .:  "arrival_time_period")
      <*> (o .:  "properties")

-- | ToJSON RequestTimeFilterFastArrivalOneToManySearch
instance A.ToJSON RequestTimeFilterFastArrivalOneToManySearch where
  toJSON RequestTimeFilterFastArrivalOneToManySearch {..} =
   _omitNulls
      [ "id" .= requestTimeFilterFastArrivalOneToManySearchId
      , "departure_location_id" .= requestTimeFilterFastArrivalOneToManySearchDepartureLocationId
      , "arrival_location_ids" .= requestTimeFilterFastArrivalOneToManySearchArrivalLocationIds
      , "transportation" .= requestTimeFilterFastArrivalOneToManySearchTransportation
      , "travel_time" .= requestTimeFilterFastArrivalOneToManySearchTravelTime
      , "arrival_time_period" .= requestTimeFilterFastArrivalOneToManySearchArrivalTimePeriod
      , "properties" .= requestTimeFilterFastArrivalOneToManySearchProperties
      ]


-- | Construct a value of type 'RequestTimeFilterFastArrivalOneToManySearch' (by applying it's required fields, if any)
mkRequestTimeFilterFastArrivalOneToManySearch
  :: Text -- ^ 'requestTimeFilterFastArrivalOneToManySearchId' 
  -> Text -- ^ 'requestTimeFilterFastArrivalOneToManySearchDepartureLocationId' 
  -> [Text] -- ^ 'requestTimeFilterFastArrivalOneToManySearchArrivalLocationIds' 
  -> RequestTransportationFast -- ^ 'requestTimeFilterFastArrivalOneToManySearchTransportation' 
  -> Int -- ^ 'requestTimeFilterFastArrivalOneToManySearchTravelTime' 
  -> RequestArrivalTimePeriod -- ^ 'requestTimeFilterFastArrivalOneToManySearchArrivalTimePeriod' 
  -> [RequestTimeFilterFastProperty] -- ^ 'requestTimeFilterFastArrivalOneToManySearchProperties' 
  -> RequestTimeFilterFastArrivalOneToManySearch
mkRequestTimeFilterFastArrivalOneToManySearch requestTimeFilterFastArrivalOneToManySearchId requestTimeFilterFastArrivalOneToManySearchDepartureLocationId requestTimeFilterFastArrivalOneToManySearchArrivalLocationIds requestTimeFilterFastArrivalOneToManySearchTransportation requestTimeFilterFastArrivalOneToManySearchTravelTime requestTimeFilterFastArrivalOneToManySearchArrivalTimePeriod requestTimeFilterFastArrivalOneToManySearchProperties =
  RequestTimeFilterFastArrivalOneToManySearch
  { requestTimeFilterFastArrivalOneToManySearchId
  , requestTimeFilterFastArrivalOneToManySearchDepartureLocationId
  , requestTimeFilterFastArrivalOneToManySearchArrivalLocationIds
  , requestTimeFilterFastArrivalOneToManySearchTransportation
  , requestTimeFilterFastArrivalOneToManySearchTravelTime
  , requestTimeFilterFastArrivalOneToManySearchArrivalTimePeriod
  , requestTimeFilterFastArrivalOneToManySearchProperties
  }

-- ** RequestTimeFilterFastArrivalSearches
-- | RequestTimeFilterFastArrivalSearches
data RequestTimeFilterFastArrivalSearches = RequestTimeFilterFastArrivalSearches
  { requestTimeFilterFastArrivalSearchesManyToOne :: !(Maybe [RequestTimeFilterFastArrivalManyToOneSearch]) -- ^ "many_to_one"
  , requestTimeFilterFastArrivalSearchesOneToMany :: !(Maybe [RequestTimeFilterFastArrivalOneToManySearch]) -- ^ "one_to_many"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RequestTimeFilterFastArrivalSearches
instance A.FromJSON RequestTimeFilterFastArrivalSearches where
  parseJSON = A.withObject "RequestTimeFilterFastArrivalSearches" $ \o ->
    RequestTimeFilterFastArrivalSearches
      <$> (o .:? "many_to_one")
      <*> (o .:? "one_to_many")

-- | ToJSON RequestTimeFilterFastArrivalSearches
instance A.ToJSON RequestTimeFilterFastArrivalSearches where
  toJSON RequestTimeFilterFastArrivalSearches {..} =
   _omitNulls
      [ "many_to_one" .= requestTimeFilterFastArrivalSearchesManyToOne
      , "one_to_many" .= requestTimeFilterFastArrivalSearchesOneToMany
      ]


-- | Construct a value of type 'RequestTimeFilterFastArrivalSearches' (by applying it's required fields, if any)
mkRequestTimeFilterFastArrivalSearches
  :: RequestTimeFilterFastArrivalSearches
mkRequestTimeFilterFastArrivalSearches =
  RequestTimeFilterFastArrivalSearches
  { requestTimeFilterFastArrivalSearchesManyToOne = Nothing
  , requestTimeFilterFastArrivalSearchesOneToMany = Nothing
  }

-- ** RequestTimeFilterPostcodeDistricts
-- | RequestTimeFilterPostcodeDistricts
data RequestTimeFilterPostcodeDistricts = RequestTimeFilterPostcodeDistricts
  { requestTimeFilterPostcodeDistrictsDepartureSearches :: !(Maybe [RequestTimeFilterPostcodeDistrictsDepartureSearch]) -- ^ "departure_searches"
  , requestTimeFilterPostcodeDistrictsArrivalSearches :: !(Maybe [RequestTimeFilterPostcodeDistrictsArrivalSearch]) -- ^ "arrival_searches"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RequestTimeFilterPostcodeDistricts
instance A.FromJSON RequestTimeFilterPostcodeDistricts where
  parseJSON = A.withObject "RequestTimeFilterPostcodeDistricts" $ \o ->
    RequestTimeFilterPostcodeDistricts
      <$> (o .:? "departure_searches")
      <*> (o .:? "arrival_searches")

-- | ToJSON RequestTimeFilterPostcodeDistricts
instance A.ToJSON RequestTimeFilterPostcodeDistricts where
  toJSON RequestTimeFilterPostcodeDistricts {..} =
   _omitNulls
      [ "departure_searches" .= requestTimeFilterPostcodeDistrictsDepartureSearches
      , "arrival_searches" .= requestTimeFilterPostcodeDistrictsArrivalSearches
      ]


-- | Construct a value of type 'RequestTimeFilterPostcodeDistricts' (by applying it's required fields, if any)
mkRequestTimeFilterPostcodeDistricts
  :: RequestTimeFilterPostcodeDistricts
mkRequestTimeFilterPostcodeDistricts =
  RequestTimeFilterPostcodeDistricts
  { requestTimeFilterPostcodeDistrictsDepartureSearches = Nothing
  , requestTimeFilterPostcodeDistrictsArrivalSearches = Nothing
  }

-- ** RequestTimeFilterPostcodeDistrictsArrivalSearch
-- | RequestTimeFilterPostcodeDistrictsArrivalSearch
data RequestTimeFilterPostcodeDistrictsArrivalSearch = RequestTimeFilterPostcodeDistrictsArrivalSearch
  { requestTimeFilterPostcodeDistrictsArrivalSearchId :: !(Text) -- ^ /Required/ "id"
  , requestTimeFilterPostcodeDistrictsArrivalSearchTransportation :: !(RequestTransportation) -- ^ /Required/ "transportation"
  , requestTimeFilterPostcodeDistrictsArrivalSearchTravelTime :: !(Int) -- ^ /Required/ "travel_time"
  , requestTimeFilterPostcodeDistrictsArrivalSearchArrivalTime :: !(DateTime) -- ^ /Required/ "arrival_time"
  , requestTimeFilterPostcodeDistrictsArrivalSearchReachablePostcodesThreshold :: !(Double) -- ^ /Required/ "reachable_postcodes_threshold"
  , requestTimeFilterPostcodeDistrictsArrivalSearchProperties :: !([RequestTimeFilterPostcodeDistrictsProperty]) -- ^ /Required/ "properties"
  , requestTimeFilterPostcodeDistrictsArrivalSearchRange :: !(Maybe RequestRangeFull) -- ^ "range"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RequestTimeFilterPostcodeDistrictsArrivalSearch
instance A.FromJSON RequestTimeFilterPostcodeDistrictsArrivalSearch where
  parseJSON = A.withObject "RequestTimeFilterPostcodeDistrictsArrivalSearch" $ \o ->
    RequestTimeFilterPostcodeDistrictsArrivalSearch
      <$> (o .:  "id")
      <*> (o .:  "transportation")
      <*> (o .:  "travel_time")
      <*> (o .:  "arrival_time")
      <*> (o .:  "reachable_postcodes_threshold")
      <*> (o .:  "properties")
      <*> (o .:? "range")

-- | ToJSON RequestTimeFilterPostcodeDistrictsArrivalSearch
instance A.ToJSON RequestTimeFilterPostcodeDistrictsArrivalSearch where
  toJSON RequestTimeFilterPostcodeDistrictsArrivalSearch {..} =
   _omitNulls
      [ "id" .= requestTimeFilterPostcodeDistrictsArrivalSearchId
      , "transportation" .= requestTimeFilterPostcodeDistrictsArrivalSearchTransportation
      , "travel_time" .= requestTimeFilterPostcodeDistrictsArrivalSearchTravelTime
      , "arrival_time" .= requestTimeFilterPostcodeDistrictsArrivalSearchArrivalTime
      , "reachable_postcodes_threshold" .= requestTimeFilterPostcodeDistrictsArrivalSearchReachablePostcodesThreshold
      , "properties" .= requestTimeFilterPostcodeDistrictsArrivalSearchProperties
      , "range" .= requestTimeFilterPostcodeDistrictsArrivalSearchRange
      ]


-- | Construct a value of type 'RequestTimeFilterPostcodeDistrictsArrivalSearch' (by applying it's required fields, if any)
mkRequestTimeFilterPostcodeDistrictsArrivalSearch
  :: Text -- ^ 'requestTimeFilterPostcodeDistrictsArrivalSearchId' 
  -> RequestTransportation -- ^ 'requestTimeFilterPostcodeDistrictsArrivalSearchTransportation' 
  -> Int -- ^ 'requestTimeFilterPostcodeDistrictsArrivalSearchTravelTime' 
  -> DateTime -- ^ 'requestTimeFilterPostcodeDistrictsArrivalSearchArrivalTime' 
  -> Double -- ^ 'requestTimeFilterPostcodeDistrictsArrivalSearchReachablePostcodesThreshold' 
  -> [RequestTimeFilterPostcodeDistrictsProperty] -- ^ 'requestTimeFilterPostcodeDistrictsArrivalSearchProperties' 
  -> RequestTimeFilterPostcodeDistrictsArrivalSearch
mkRequestTimeFilterPostcodeDistrictsArrivalSearch requestTimeFilterPostcodeDistrictsArrivalSearchId requestTimeFilterPostcodeDistrictsArrivalSearchTransportation requestTimeFilterPostcodeDistrictsArrivalSearchTravelTime requestTimeFilterPostcodeDistrictsArrivalSearchArrivalTime requestTimeFilterPostcodeDistrictsArrivalSearchReachablePostcodesThreshold requestTimeFilterPostcodeDistrictsArrivalSearchProperties =
  RequestTimeFilterPostcodeDistrictsArrivalSearch
  { requestTimeFilterPostcodeDistrictsArrivalSearchId
  , requestTimeFilterPostcodeDistrictsArrivalSearchTransportation
  , requestTimeFilterPostcodeDistrictsArrivalSearchTravelTime
  , requestTimeFilterPostcodeDistrictsArrivalSearchArrivalTime
  , requestTimeFilterPostcodeDistrictsArrivalSearchReachablePostcodesThreshold
  , requestTimeFilterPostcodeDistrictsArrivalSearchProperties
  , requestTimeFilterPostcodeDistrictsArrivalSearchRange = Nothing
  }

-- ** RequestTimeFilterPostcodeDistrictsDepartureSearch
-- | RequestTimeFilterPostcodeDistrictsDepartureSearch
data RequestTimeFilterPostcodeDistrictsDepartureSearch = RequestTimeFilterPostcodeDistrictsDepartureSearch
  { requestTimeFilterPostcodeDistrictsDepartureSearchId :: !(Text) -- ^ /Required/ "id"
  , requestTimeFilterPostcodeDistrictsDepartureSearchTransportation :: !(RequestTransportation) -- ^ /Required/ "transportation"
  , requestTimeFilterPostcodeDistrictsDepartureSearchTravelTime :: !(Int) -- ^ /Required/ "travel_time"
  , requestTimeFilterPostcodeDistrictsDepartureSearchDepartureTime :: !(DateTime) -- ^ /Required/ "departure_time"
  , requestTimeFilterPostcodeDistrictsDepartureSearchReachablePostcodesThreshold :: !(Double) -- ^ /Required/ "reachable_postcodes_threshold"
  , requestTimeFilterPostcodeDistrictsDepartureSearchProperties :: !([RequestTimeFilterPostcodeDistrictsProperty]) -- ^ /Required/ "properties"
  , requestTimeFilterPostcodeDistrictsDepartureSearchRange :: !(Maybe RequestRangeFull) -- ^ "range"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RequestTimeFilterPostcodeDistrictsDepartureSearch
instance A.FromJSON RequestTimeFilterPostcodeDistrictsDepartureSearch where
  parseJSON = A.withObject "RequestTimeFilterPostcodeDistrictsDepartureSearch" $ \o ->
    RequestTimeFilterPostcodeDistrictsDepartureSearch
      <$> (o .:  "id")
      <*> (o .:  "transportation")
      <*> (o .:  "travel_time")
      <*> (o .:  "departure_time")
      <*> (o .:  "reachable_postcodes_threshold")
      <*> (o .:  "properties")
      <*> (o .:? "range")

-- | ToJSON RequestTimeFilterPostcodeDistrictsDepartureSearch
instance A.ToJSON RequestTimeFilterPostcodeDistrictsDepartureSearch where
  toJSON RequestTimeFilterPostcodeDistrictsDepartureSearch {..} =
   _omitNulls
      [ "id" .= requestTimeFilterPostcodeDistrictsDepartureSearchId
      , "transportation" .= requestTimeFilterPostcodeDistrictsDepartureSearchTransportation
      , "travel_time" .= requestTimeFilterPostcodeDistrictsDepartureSearchTravelTime
      , "departure_time" .= requestTimeFilterPostcodeDistrictsDepartureSearchDepartureTime
      , "reachable_postcodes_threshold" .= requestTimeFilterPostcodeDistrictsDepartureSearchReachablePostcodesThreshold
      , "properties" .= requestTimeFilterPostcodeDistrictsDepartureSearchProperties
      , "range" .= requestTimeFilterPostcodeDistrictsDepartureSearchRange
      ]


-- | Construct a value of type 'RequestTimeFilterPostcodeDistrictsDepartureSearch' (by applying it's required fields, if any)
mkRequestTimeFilterPostcodeDistrictsDepartureSearch
  :: Text -- ^ 'requestTimeFilterPostcodeDistrictsDepartureSearchId' 
  -> RequestTransportation -- ^ 'requestTimeFilterPostcodeDistrictsDepartureSearchTransportation' 
  -> Int -- ^ 'requestTimeFilterPostcodeDistrictsDepartureSearchTravelTime' 
  -> DateTime -- ^ 'requestTimeFilterPostcodeDistrictsDepartureSearchDepartureTime' 
  -> Double -- ^ 'requestTimeFilterPostcodeDistrictsDepartureSearchReachablePostcodesThreshold' 
  -> [RequestTimeFilterPostcodeDistrictsProperty] -- ^ 'requestTimeFilterPostcodeDistrictsDepartureSearchProperties' 
  -> RequestTimeFilterPostcodeDistrictsDepartureSearch
mkRequestTimeFilterPostcodeDistrictsDepartureSearch requestTimeFilterPostcodeDistrictsDepartureSearchId requestTimeFilterPostcodeDistrictsDepartureSearchTransportation requestTimeFilterPostcodeDistrictsDepartureSearchTravelTime requestTimeFilterPostcodeDistrictsDepartureSearchDepartureTime requestTimeFilterPostcodeDistrictsDepartureSearchReachablePostcodesThreshold requestTimeFilterPostcodeDistrictsDepartureSearchProperties =
  RequestTimeFilterPostcodeDistrictsDepartureSearch
  { requestTimeFilterPostcodeDistrictsDepartureSearchId
  , requestTimeFilterPostcodeDistrictsDepartureSearchTransportation
  , requestTimeFilterPostcodeDistrictsDepartureSearchTravelTime
  , requestTimeFilterPostcodeDistrictsDepartureSearchDepartureTime
  , requestTimeFilterPostcodeDistrictsDepartureSearchReachablePostcodesThreshold
  , requestTimeFilterPostcodeDistrictsDepartureSearchProperties
  , requestTimeFilterPostcodeDistrictsDepartureSearchRange = Nothing
  }

-- ** RequestTimeFilterPostcodeSectors
-- | RequestTimeFilterPostcodeSectors
data RequestTimeFilterPostcodeSectors = RequestTimeFilterPostcodeSectors
  { requestTimeFilterPostcodeSectorsDepartureSearches :: !(Maybe [RequestTimeFilterPostcodeSectorsDepartureSearch]) -- ^ "departure_searches"
  , requestTimeFilterPostcodeSectorsArrivalSearches :: !(Maybe [RequestTimeFilterPostcodeSectorsArrivalSearch]) -- ^ "arrival_searches"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RequestTimeFilterPostcodeSectors
instance A.FromJSON RequestTimeFilterPostcodeSectors where
  parseJSON = A.withObject "RequestTimeFilterPostcodeSectors" $ \o ->
    RequestTimeFilterPostcodeSectors
      <$> (o .:? "departure_searches")
      <*> (o .:? "arrival_searches")

-- | ToJSON RequestTimeFilterPostcodeSectors
instance A.ToJSON RequestTimeFilterPostcodeSectors where
  toJSON RequestTimeFilterPostcodeSectors {..} =
   _omitNulls
      [ "departure_searches" .= requestTimeFilterPostcodeSectorsDepartureSearches
      , "arrival_searches" .= requestTimeFilterPostcodeSectorsArrivalSearches
      ]


-- | Construct a value of type 'RequestTimeFilterPostcodeSectors' (by applying it's required fields, if any)
mkRequestTimeFilterPostcodeSectors
  :: RequestTimeFilterPostcodeSectors
mkRequestTimeFilterPostcodeSectors =
  RequestTimeFilterPostcodeSectors
  { requestTimeFilterPostcodeSectorsDepartureSearches = Nothing
  , requestTimeFilterPostcodeSectorsArrivalSearches = Nothing
  }

-- ** RequestTimeFilterPostcodeSectorsArrivalSearch
-- | RequestTimeFilterPostcodeSectorsArrivalSearch
data RequestTimeFilterPostcodeSectorsArrivalSearch = RequestTimeFilterPostcodeSectorsArrivalSearch
  { requestTimeFilterPostcodeSectorsArrivalSearchId :: !(Text) -- ^ /Required/ "id"
  , requestTimeFilterPostcodeSectorsArrivalSearchTransportation :: !(RequestTransportation) -- ^ /Required/ "transportation"
  , requestTimeFilterPostcodeSectorsArrivalSearchTravelTime :: !(Int) -- ^ /Required/ "travel_time"
  , requestTimeFilterPostcodeSectorsArrivalSearchArrivalTime :: !(DateTime) -- ^ /Required/ "arrival_time"
  , requestTimeFilterPostcodeSectorsArrivalSearchReachablePostcodesThreshold :: !(Double) -- ^ /Required/ "reachable_postcodes_threshold"
  , requestTimeFilterPostcodeSectorsArrivalSearchProperties :: !([RequestTimeFilterPostcodeSectorsProperty]) -- ^ /Required/ "properties"
  , requestTimeFilterPostcodeSectorsArrivalSearchRange :: !(Maybe RequestRangeFull) -- ^ "range"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RequestTimeFilterPostcodeSectorsArrivalSearch
instance A.FromJSON RequestTimeFilterPostcodeSectorsArrivalSearch where
  parseJSON = A.withObject "RequestTimeFilterPostcodeSectorsArrivalSearch" $ \o ->
    RequestTimeFilterPostcodeSectorsArrivalSearch
      <$> (o .:  "id")
      <*> (o .:  "transportation")
      <*> (o .:  "travel_time")
      <*> (o .:  "arrival_time")
      <*> (o .:  "reachable_postcodes_threshold")
      <*> (o .:  "properties")
      <*> (o .:? "range")

-- | ToJSON RequestTimeFilterPostcodeSectorsArrivalSearch
instance A.ToJSON RequestTimeFilterPostcodeSectorsArrivalSearch where
  toJSON RequestTimeFilterPostcodeSectorsArrivalSearch {..} =
   _omitNulls
      [ "id" .= requestTimeFilterPostcodeSectorsArrivalSearchId
      , "transportation" .= requestTimeFilterPostcodeSectorsArrivalSearchTransportation
      , "travel_time" .= requestTimeFilterPostcodeSectorsArrivalSearchTravelTime
      , "arrival_time" .= requestTimeFilterPostcodeSectorsArrivalSearchArrivalTime
      , "reachable_postcodes_threshold" .= requestTimeFilterPostcodeSectorsArrivalSearchReachablePostcodesThreshold
      , "properties" .= requestTimeFilterPostcodeSectorsArrivalSearchProperties
      , "range" .= requestTimeFilterPostcodeSectorsArrivalSearchRange
      ]


-- | Construct a value of type 'RequestTimeFilterPostcodeSectorsArrivalSearch' (by applying it's required fields, if any)
mkRequestTimeFilterPostcodeSectorsArrivalSearch
  :: Text -- ^ 'requestTimeFilterPostcodeSectorsArrivalSearchId' 
  -> RequestTransportation -- ^ 'requestTimeFilterPostcodeSectorsArrivalSearchTransportation' 
  -> Int -- ^ 'requestTimeFilterPostcodeSectorsArrivalSearchTravelTime' 
  -> DateTime -- ^ 'requestTimeFilterPostcodeSectorsArrivalSearchArrivalTime' 
  -> Double -- ^ 'requestTimeFilterPostcodeSectorsArrivalSearchReachablePostcodesThreshold' 
  -> [RequestTimeFilterPostcodeSectorsProperty] -- ^ 'requestTimeFilterPostcodeSectorsArrivalSearchProperties' 
  -> RequestTimeFilterPostcodeSectorsArrivalSearch
mkRequestTimeFilterPostcodeSectorsArrivalSearch requestTimeFilterPostcodeSectorsArrivalSearchId requestTimeFilterPostcodeSectorsArrivalSearchTransportation requestTimeFilterPostcodeSectorsArrivalSearchTravelTime requestTimeFilterPostcodeSectorsArrivalSearchArrivalTime requestTimeFilterPostcodeSectorsArrivalSearchReachablePostcodesThreshold requestTimeFilterPostcodeSectorsArrivalSearchProperties =
  RequestTimeFilterPostcodeSectorsArrivalSearch
  { requestTimeFilterPostcodeSectorsArrivalSearchId
  , requestTimeFilterPostcodeSectorsArrivalSearchTransportation
  , requestTimeFilterPostcodeSectorsArrivalSearchTravelTime
  , requestTimeFilterPostcodeSectorsArrivalSearchArrivalTime
  , requestTimeFilterPostcodeSectorsArrivalSearchReachablePostcodesThreshold
  , requestTimeFilterPostcodeSectorsArrivalSearchProperties
  , requestTimeFilterPostcodeSectorsArrivalSearchRange = Nothing
  }

-- ** RequestTimeFilterPostcodeSectorsDepartureSearch
-- | RequestTimeFilterPostcodeSectorsDepartureSearch
data RequestTimeFilterPostcodeSectorsDepartureSearch = RequestTimeFilterPostcodeSectorsDepartureSearch
  { requestTimeFilterPostcodeSectorsDepartureSearchId :: !(Text) -- ^ /Required/ "id"
  , requestTimeFilterPostcodeSectorsDepartureSearchTransportation :: !(RequestTransportation) -- ^ /Required/ "transportation"
  , requestTimeFilterPostcodeSectorsDepartureSearchTravelTime :: !(Int) -- ^ /Required/ "travel_time"
  , requestTimeFilterPostcodeSectorsDepartureSearchDepartureTime :: !(DateTime) -- ^ /Required/ "departure_time"
  , requestTimeFilterPostcodeSectorsDepartureSearchReachablePostcodesThreshold :: !(Double) -- ^ /Required/ "reachable_postcodes_threshold"
  , requestTimeFilterPostcodeSectorsDepartureSearchProperties :: !([RequestTimeFilterPostcodeSectorsProperty]) -- ^ /Required/ "properties"
  , requestTimeFilterPostcodeSectorsDepartureSearchRange :: !(Maybe RequestRangeFull) -- ^ "range"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RequestTimeFilterPostcodeSectorsDepartureSearch
instance A.FromJSON RequestTimeFilterPostcodeSectorsDepartureSearch where
  parseJSON = A.withObject "RequestTimeFilterPostcodeSectorsDepartureSearch" $ \o ->
    RequestTimeFilterPostcodeSectorsDepartureSearch
      <$> (o .:  "id")
      <*> (o .:  "transportation")
      <*> (o .:  "travel_time")
      <*> (o .:  "departure_time")
      <*> (o .:  "reachable_postcodes_threshold")
      <*> (o .:  "properties")
      <*> (o .:? "range")

-- | ToJSON RequestTimeFilterPostcodeSectorsDepartureSearch
instance A.ToJSON RequestTimeFilterPostcodeSectorsDepartureSearch where
  toJSON RequestTimeFilterPostcodeSectorsDepartureSearch {..} =
   _omitNulls
      [ "id" .= requestTimeFilterPostcodeSectorsDepartureSearchId
      , "transportation" .= requestTimeFilterPostcodeSectorsDepartureSearchTransportation
      , "travel_time" .= requestTimeFilterPostcodeSectorsDepartureSearchTravelTime
      , "departure_time" .= requestTimeFilterPostcodeSectorsDepartureSearchDepartureTime
      , "reachable_postcodes_threshold" .= requestTimeFilterPostcodeSectorsDepartureSearchReachablePostcodesThreshold
      , "properties" .= requestTimeFilterPostcodeSectorsDepartureSearchProperties
      , "range" .= requestTimeFilterPostcodeSectorsDepartureSearchRange
      ]


-- | Construct a value of type 'RequestTimeFilterPostcodeSectorsDepartureSearch' (by applying it's required fields, if any)
mkRequestTimeFilterPostcodeSectorsDepartureSearch
  :: Text -- ^ 'requestTimeFilterPostcodeSectorsDepartureSearchId' 
  -> RequestTransportation -- ^ 'requestTimeFilterPostcodeSectorsDepartureSearchTransportation' 
  -> Int -- ^ 'requestTimeFilterPostcodeSectorsDepartureSearchTravelTime' 
  -> DateTime -- ^ 'requestTimeFilterPostcodeSectorsDepartureSearchDepartureTime' 
  -> Double -- ^ 'requestTimeFilterPostcodeSectorsDepartureSearchReachablePostcodesThreshold' 
  -> [RequestTimeFilterPostcodeSectorsProperty] -- ^ 'requestTimeFilterPostcodeSectorsDepartureSearchProperties' 
  -> RequestTimeFilterPostcodeSectorsDepartureSearch
mkRequestTimeFilterPostcodeSectorsDepartureSearch requestTimeFilterPostcodeSectorsDepartureSearchId requestTimeFilterPostcodeSectorsDepartureSearchTransportation requestTimeFilterPostcodeSectorsDepartureSearchTravelTime requestTimeFilterPostcodeSectorsDepartureSearchDepartureTime requestTimeFilterPostcodeSectorsDepartureSearchReachablePostcodesThreshold requestTimeFilterPostcodeSectorsDepartureSearchProperties =
  RequestTimeFilterPostcodeSectorsDepartureSearch
  { requestTimeFilterPostcodeSectorsDepartureSearchId
  , requestTimeFilterPostcodeSectorsDepartureSearchTransportation
  , requestTimeFilterPostcodeSectorsDepartureSearchTravelTime
  , requestTimeFilterPostcodeSectorsDepartureSearchDepartureTime
  , requestTimeFilterPostcodeSectorsDepartureSearchReachablePostcodesThreshold
  , requestTimeFilterPostcodeSectorsDepartureSearchProperties
  , requestTimeFilterPostcodeSectorsDepartureSearchRange = Nothing
  }

-- ** RequestTimeFilterPostcodes
-- | RequestTimeFilterPostcodes
data RequestTimeFilterPostcodes = RequestTimeFilterPostcodes
  { requestTimeFilterPostcodesDepartureSearches :: !(Maybe [RequestTimeFilterPostcodesDepartureSearch]) -- ^ "departure_searches"
  , requestTimeFilterPostcodesArrivalSearches :: !(Maybe [RequestTimeFilterPostcodesArrivalSearch]) -- ^ "arrival_searches"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RequestTimeFilterPostcodes
instance A.FromJSON RequestTimeFilterPostcodes where
  parseJSON = A.withObject "RequestTimeFilterPostcodes" $ \o ->
    RequestTimeFilterPostcodes
      <$> (o .:? "departure_searches")
      <*> (o .:? "arrival_searches")

-- | ToJSON RequestTimeFilterPostcodes
instance A.ToJSON RequestTimeFilterPostcodes where
  toJSON RequestTimeFilterPostcodes {..} =
   _omitNulls
      [ "departure_searches" .= requestTimeFilterPostcodesDepartureSearches
      , "arrival_searches" .= requestTimeFilterPostcodesArrivalSearches
      ]


-- | Construct a value of type 'RequestTimeFilterPostcodes' (by applying it's required fields, if any)
mkRequestTimeFilterPostcodes
  :: RequestTimeFilterPostcodes
mkRequestTimeFilterPostcodes =
  RequestTimeFilterPostcodes
  { requestTimeFilterPostcodesDepartureSearches = Nothing
  , requestTimeFilterPostcodesArrivalSearches = Nothing
  }

-- ** RequestTimeFilterPostcodesArrivalSearch
-- | RequestTimeFilterPostcodesArrivalSearch
data RequestTimeFilterPostcodesArrivalSearch = RequestTimeFilterPostcodesArrivalSearch
  { requestTimeFilterPostcodesArrivalSearchId :: !(Text) -- ^ /Required/ "id"
  , requestTimeFilterPostcodesArrivalSearchTransportation :: !(RequestTransportation) -- ^ /Required/ "transportation"
  , requestTimeFilterPostcodesArrivalSearchTravelTime :: !(Int) -- ^ /Required/ "travel_time"
  , requestTimeFilterPostcodesArrivalSearchArrivalTime :: !(DateTime) -- ^ /Required/ "arrival_time"
  , requestTimeFilterPostcodesArrivalSearchProperties :: !([RequestTimeFilterPostcodesProperty]) -- ^ /Required/ "properties"
  , requestTimeFilterPostcodesArrivalSearchRange :: !(Maybe RequestRangeFull) -- ^ "range"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RequestTimeFilterPostcodesArrivalSearch
instance A.FromJSON RequestTimeFilterPostcodesArrivalSearch where
  parseJSON = A.withObject "RequestTimeFilterPostcodesArrivalSearch" $ \o ->
    RequestTimeFilterPostcodesArrivalSearch
      <$> (o .:  "id")
      <*> (o .:  "transportation")
      <*> (o .:  "travel_time")
      <*> (o .:  "arrival_time")
      <*> (o .:  "properties")
      <*> (o .:? "range")

-- | ToJSON RequestTimeFilterPostcodesArrivalSearch
instance A.ToJSON RequestTimeFilterPostcodesArrivalSearch where
  toJSON RequestTimeFilterPostcodesArrivalSearch {..} =
   _omitNulls
      [ "id" .= requestTimeFilterPostcodesArrivalSearchId
      , "transportation" .= requestTimeFilterPostcodesArrivalSearchTransportation
      , "travel_time" .= requestTimeFilterPostcodesArrivalSearchTravelTime
      , "arrival_time" .= requestTimeFilterPostcodesArrivalSearchArrivalTime
      , "properties" .= requestTimeFilterPostcodesArrivalSearchProperties
      , "range" .= requestTimeFilterPostcodesArrivalSearchRange
      ]


-- | Construct a value of type 'RequestTimeFilterPostcodesArrivalSearch' (by applying it's required fields, if any)
mkRequestTimeFilterPostcodesArrivalSearch
  :: Text -- ^ 'requestTimeFilterPostcodesArrivalSearchId' 
  -> RequestTransportation -- ^ 'requestTimeFilterPostcodesArrivalSearchTransportation' 
  -> Int -- ^ 'requestTimeFilterPostcodesArrivalSearchTravelTime' 
  -> DateTime -- ^ 'requestTimeFilterPostcodesArrivalSearchArrivalTime' 
  -> [RequestTimeFilterPostcodesProperty] -- ^ 'requestTimeFilterPostcodesArrivalSearchProperties' 
  -> RequestTimeFilterPostcodesArrivalSearch
mkRequestTimeFilterPostcodesArrivalSearch requestTimeFilterPostcodesArrivalSearchId requestTimeFilterPostcodesArrivalSearchTransportation requestTimeFilterPostcodesArrivalSearchTravelTime requestTimeFilterPostcodesArrivalSearchArrivalTime requestTimeFilterPostcodesArrivalSearchProperties =
  RequestTimeFilterPostcodesArrivalSearch
  { requestTimeFilterPostcodesArrivalSearchId
  , requestTimeFilterPostcodesArrivalSearchTransportation
  , requestTimeFilterPostcodesArrivalSearchTravelTime
  , requestTimeFilterPostcodesArrivalSearchArrivalTime
  , requestTimeFilterPostcodesArrivalSearchProperties
  , requestTimeFilterPostcodesArrivalSearchRange = Nothing
  }

-- ** RequestTimeFilterPostcodesDepartureSearch
-- | RequestTimeFilterPostcodesDepartureSearch
data RequestTimeFilterPostcodesDepartureSearch = RequestTimeFilterPostcodesDepartureSearch
  { requestTimeFilterPostcodesDepartureSearchId :: !(Text) -- ^ /Required/ "id"
  , requestTimeFilterPostcodesDepartureSearchTransportation :: !(RequestTransportation) -- ^ /Required/ "transportation"
  , requestTimeFilterPostcodesDepartureSearchTravelTime :: !(Int) -- ^ /Required/ "travel_time"
  , requestTimeFilterPostcodesDepartureSearchDepartureTime :: !(DateTime) -- ^ /Required/ "departure_time"
  , requestTimeFilterPostcodesDepartureSearchProperties :: !([RequestTimeFilterPostcodesProperty]) -- ^ /Required/ "properties"
  , requestTimeFilterPostcodesDepartureSearchRange :: !(Maybe RequestRangeFull) -- ^ "range"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RequestTimeFilterPostcodesDepartureSearch
instance A.FromJSON RequestTimeFilterPostcodesDepartureSearch where
  parseJSON = A.withObject "RequestTimeFilterPostcodesDepartureSearch" $ \o ->
    RequestTimeFilterPostcodesDepartureSearch
      <$> (o .:  "id")
      <*> (o .:  "transportation")
      <*> (o .:  "travel_time")
      <*> (o .:  "departure_time")
      <*> (o .:  "properties")
      <*> (o .:? "range")

-- | ToJSON RequestTimeFilterPostcodesDepartureSearch
instance A.ToJSON RequestTimeFilterPostcodesDepartureSearch where
  toJSON RequestTimeFilterPostcodesDepartureSearch {..} =
   _omitNulls
      [ "id" .= requestTimeFilterPostcodesDepartureSearchId
      , "transportation" .= requestTimeFilterPostcodesDepartureSearchTransportation
      , "travel_time" .= requestTimeFilterPostcodesDepartureSearchTravelTime
      , "departure_time" .= requestTimeFilterPostcodesDepartureSearchDepartureTime
      , "properties" .= requestTimeFilterPostcodesDepartureSearchProperties
      , "range" .= requestTimeFilterPostcodesDepartureSearchRange
      ]


-- | Construct a value of type 'RequestTimeFilterPostcodesDepartureSearch' (by applying it's required fields, if any)
mkRequestTimeFilterPostcodesDepartureSearch
  :: Text -- ^ 'requestTimeFilterPostcodesDepartureSearchId' 
  -> RequestTransportation -- ^ 'requestTimeFilterPostcodesDepartureSearchTransportation' 
  -> Int -- ^ 'requestTimeFilterPostcodesDepartureSearchTravelTime' 
  -> DateTime -- ^ 'requestTimeFilterPostcodesDepartureSearchDepartureTime' 
  -> [RequestTimeFilterPostcodesProperty] -- ^ 'requestTimeFilterPostcodesDepartureSearchProperties' 
  -> RequestTimeFilterPostcodesDepartureSearch
mkRequestTimeFilterPostcodesDepartureSearch requestTimeFilterPostcodesDepartureSearchId requestTimeFilterPostcodesDepartureSearchTransportation requestTimeFilterPostcodesDepartureSearchTravelTime requestTimeFilterPostcodesDepartureSearchDepartureTime requestTimeFilterPostcodesDepartureSearchProperties =
  RequestTimeFilterPostcodesDepartureSearch
  { requestTimeFilterPostcodesDepartureSearchId
  , requestTimeFilterPostcodesDepartureSearchTransportation
  , requestTimeFilterPostcodesDepartureSearchTravelTime
  , requestTimeFilterPostcodesDepartureSearchDepartureTime
  , requestTimeFilterPostcodesDepartureSearchProperties
  , requestTimeFilterPostcodesDepartureSearchRange = Nothing
  }

-- ** RequestTimeMap
-- | RequestTimeMap
data RequestTimeMap = RequestTimeMap
  { requestTimeMapDepartureSearches :: !(Maybe [RequestTimeMapDepartureSearch]) -- ^ "departure_searches"
  , requestTimeMapArrivalSearches :: !(Maybe [RequestTimeMapArrivalSearch]) -- ^ "arrival_searches"
  , requestTimeMapUnions :: !(Maybe [RequestUnionOnIntersection]) -- ^ "unions"
  , requestTimeMapIntersections :: !(Maybe [RequestUnionOnIntersection]) -- ^ "intersections"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RequestTimeMap
instance A.FromJSON RequestTimeMap where
  parseJSON = A.withObject "RequestTimeMap" $ \o ->
    RequestTimeMap
      <$> (o .:? "departure_searches")
      <*> (o .:? "arrival_searches")
      <*> (o .:? "unions")
      <*> (o .:? "intersections")

-- | ToJSON RequestTimeMap
instance A.ToJSON RequestTimeMap where
  toJSON RequestTimeMap {..} =
   _omitNulls
      [ "departure_searches" .= requestTimeMapDepartureSearches
      , "arrival_searches" .= requestTimeMapArrivalSearches
      , "unions" .= requestTimeMapUnions
      , "intersections" .= requestTimeMapIntersections
      ]


-- | Construct a value of type 'RequestTimeMap' (by applying it's required fields, if any)
mkRequestTimeMap
  :: RequestTimeMap
mkRequestTimeMap =
  RequestTimeMap
  { requestTimeMapDepartureSearches = Nothing
  , requestTimeMapArrivalSearches = Nothing
  , requestTimeMapUnions = Nothing
  , requestTimeMapIntersections = Nothing
  }

-- ** RequestTimeMapArrivalSearch
-- | RequestTimeMapArrivalSearch
data RequestTimeMapArrivalSearch = RequestTimeMapArrivalSearch
  { requestTimeMapArrivalSearchId :: !(Text) -- ^ /Required/ "id"
  , requestTimeMapArrivalSearchCoords :: !(Coords) -- ^ /Required/ "coords"
  , requestTimeMapArrivalSearchTransportation :: !(RequestTransportation) -- ^ /Required/ "transportation"
  , requestTimeMapArrivalSearchTravelTime :: !(Int) -- ^ /Required/ "travel_time"
  , requestTimeMapArrivalSearchArrivalTime :: !(DateTime) -- ^ /Required/ "arrival_time"
  , requestTimeMapArrivalSearchProperties :: !(Maybe [RequestTimeMapProperty]) -- ^ "properties"
  , requestTimeMapArrivalSearchRange :: !(Maybe RequestRangeNoMaxResults) -- ^ "range"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RequestTimeMapArrivalSearch
instance A.FromJSON RequestTimeMapArrivalSearch where
  parseJSON = A.withObject "RequestTimeMapArrivalSearch" $ \o ->
    RequestTimeMapArrivalSearch
      <$> (o .:  "id")
      <*> (o .:  "coords")
      <*> (o .:  "transportation")
      <*> (o .:  "travel_time")
      <*> (o .:  "arrival_time")
      <*> (o .:? "properties")
      <*> (o .:? "range")

-- | ToJSON RequestTimeMapArrivalSearch
instance A.ToJSON RequestTimeMapArrivalSearch where
  toJSON RequestTimeMapArrivalSearch {..} =
   _omitNulls
      [ "id" .= requestTimeMapArrivalSearchId
      , "coords" .= requestTimeMapArrivalSearchCoords
      , "transportation" .= requestTimeMapArrivalSearchTransportation
      , "travel_time" .= requestTimeMapArrivalSearchTravelTime
      , "arrival_time" .= requestTimeMapArrivalSearchArrivalTime
      , "properties" .= requestTimeMapArrivalSearchProperties
      , "range" .= requestTimeMapArrivalSearchRange
      ]


-- | Construct a value of type 'RequestTimeMapArrivalSearch' (by applying it's required fields, if any)
mkRequestTimeMapArrivalSearch
  :: Text -- ^ 'requestTimeMapArrivalSearchId' 
  -> Coords -- ^ 'requestTimeMapArrivalSearchCoords' 
  -> RequestTransportation -- ^ 'requestTimeMapArrivalSearchTransportation' 
  -> Int -- ^ 'requestTimeMapArrivalSearchTravelTime' 
  -> DateTime -- ^ 'requestTimeMapArrivalSearchArrivalTime' 
  -> RequestTimeMapArrivalSearch
mkRequestTimeMapArrivalSearch requestTimeMapArrivalSearchId requestTimeMapArrivalSearchCoords requestTimeMapArrivalSearchTransportation requestTimeMapArrivalSearchTravelTime requestTimeMapArrivalSearchArrivalTime =
  RequestTimeMapArrivalSearch
  { requestTimeMapArrivalSearchId
  , requestTimeMapArrivalSearchCoords
  , requestTimeMapArrivalSearchTransportation
  , requestTimeMapArrivalSearchTravelTime
  , requestTimeMapArrivalSearchArrivalTime
  , requestTimeMapArrivalSearchProperties = Nothing
  , requestTimeMapArrivalSearchRange = Nothing
  }

-- ** RequestTimeMapDepartureSearch
-- | RequestTimeMapDepartureSearch
data RequestTimeMapDepartureSearch = RequestTimeMapDepartureSearch
  { requestTimeMapDepartureSearchId :: !(Text) -- ^ /Required/ "id"
  , requestTimeMapDepartureSearchCoords :: !(Coords) -- ^ /Required/ "coords"
  , requestTimeMapDepartureSearchTransportation :: !(RequestTransportation) -- ^ /Required/ "transportation"
  , requestTimeMapDepartureSearchTravelTime :: !(Int) -- ^ /Required/ "travel_time"
  , requestTimeMapDepartureSearchDepartureTime :: !(DateTime) -- ^ /Required/ "departure_time"
  , requestTimeMapDepartureSearchProperties :: !(Maybe [RequestTimeMapProperty]) -- ^ "properties"
  , requestTimeMapDepartureSearchRange :: !(Maybe RequestRangeNoMaxResults) -- ^ "range"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RequestTimeMapDepartureSearch
instance A.FromJSON RequestTimeMapDepartureSearch where
  parseJSON = A.withObject "RequestTimeMapDepartureSearch" $ \o ->
    RequestTimeMapDepartureSearch
      <$> (o .:  "id")
      <*> (o .:  "coords")
      <*> (o .:  "transportation")
      <*> (o .:  "travel_time")
      <*> (o .:  "departure_time")
      <*> (o .:? "properties")
      <*> (o .:? "range")

-- | ToJSON RequestTimeMapDepartureSearch
instance A.ToJSON RequestTimeMapDepartureSearch where
  toJSON RequestTimeMapDepartureSearch {..} =
   _omitNulls
      [ "id" .= requestTimeMapDepartureSearchId
      , "coords" .= requestTimeMapDepartureSearchCoords
      , "transportation" .= requestTimeMapDepartureSearchTransportation
      , "travel_time" .= requestTimeMapDepartureSearchTravelTime
      , "departure_time" .= requestTimeMapDepartureSearchDepartureTime
      , "properties" .= requestTimeMapDepartureSearchProperties
      , "range" .= requestTimeMapDepartureSearchRange
      ]


-- | Construct a value of type 'RequestTimeMapDepartureSearch' (by applying it's required fields, if any)
mkRequestTimeMapDepartureSearch
  :: Text -- ^ 'requestTimeMapDepartureSearchId' 
  -> Coords -- ^ 'requestTimeMapDepartureSearchCoords' 
  -> RequestTransportation -- ^ 'requestTimeMapDepartureSearchTransportation' 
  -> Int -- ^ 'requestTimeMapDepartureSearchTravelTime' 
  -> DateTime -- ^ 'requestTimeMapDepartureSearchDepartureTime' 
  -> RequestTimeMapDepartureSearch
mkRequestTimeMapDepartureSearch requestTimeMapDepartureSearchId requestTimeMapDepartureSearchCoords requestTimeMapDepartureSearchTransportation requestTimeMapDepartureSearchTravelTime requestTimeMapDepartureSearchDepartureTime =
  RequestTimeMapDepartureSearch
  { requestTimeMapDepartureSearchId
  , requestTimeMapDepartureSearchCoords
  , requestTimeMapDepartureSearchTransportation
  , requestTimeMapDepartureSearchTravelTime
  , requestTimeMapDepartureSearchDepartureTime
  , requestTimeMapDepartureSearchProperties = Nothing
  , requestTimeMapDepartureSearchRange = Nothing
  }

-- ** RequestTransportation
-- | RequestTransportation
data RequestTransportation = RequestTransportation
  { requestTransportationType :: !(E'Type4) -- ^ /Required/ "type"
  , requestTransportationPtChangeDelay :: !(Maybe Int) -- ^ "pt_change_delay"
  , requestTransportationWalkingTime :: !(Maybe Int) -- ^ "walking_time"
  , requestTransportationDrivingTimeToStation :: !(Maybe Int) -- ^ "driving_time_to_station"
  , requestTransportationParkingTime :: !(Maybe Int) -- ^ "parking_time"
  , requestTransportationBoardingTime :: !(Maybe Int) -- ^ "boarding_time"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RequestTransportation
instance A.FromJSON RequestTransportation where
  parseJSON = A.withObject "RequestTransportation" $ \o ->
    RequestTransportation
      <$> (o .:  "type")
      <*> (o .:? "pt_change_delay")
      <*> (o .:? "walking_time")
      <*> (o .:? "driving_time_to_station")
      <*> (o .:? "parking_time")
      <*> (o .:? "boarding_time")

-- | ToJSON RequestTransportation
instance A.ToJSON RequestTransportation where
  toJSON RequestTransportation {..} =
   _omitNulls
      [ "type" .= requestTransportationType
      , "pt_change_delay" .= requestTransportationPtChangeDelay
      , "walking_time" .= requestTransportationWalkingTime
      , "driving_time_to_station" .= requestTransportationDrivingTimeToStation
      , "parking_time" .= requestTransportationParkingTime
      , "boarding_time" .= requestTransportationBoardingTime
      ]


-- | Construct a value of type 'RequestTransportation' (by applying it's required fields, if any)
mkRequestTransportation
  :: E'Type4 -- ^ 'requestTransportationType' 
  -> RequestTransportation
mkRequestTransportation requestTransportationType =
  RequestTransportation
  { requestTransportationType
  , requestTransportationPtChangeDelay = Nothing
  , requestTransportationWalkingTime = Nothing
  , requestTransportationDrivingTimeToStation = Nothing
  , requestTransportationParkingTime = Nothing
  , requestTransportationBoardingTime = Nothing
  }

-- ** RequestTransportationFast
-- | RequestTransportationFast
data RequestTransportationFast = RequestTransportationFast
  { requestTransportationFastType :: !(E'Type) -- ^ /Required/ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RequestTransportationFast
instance A.FromJSON RequestTransportationFast where
  parseJSON = A.withObject "RequestTransportationFast" $ \o ->
    RequestTransportationFast
      <$> (o .:  "type")

-- | ToJSON RequestTransportationFast
instance A.ToJSON RequestTransportationFast where
  toJSON RequestTransportationFast {..} =
   _omitNulls
      [ "type" .= requestTransportationFastType
      ]


-- | Construct a value of type 'RequestTransportationFast' (by applying it's required fields, if any)
mkRequestTransportationFast
  :: E'Type -- ^ 'requestTransportationFastType' 
  -> RequestTransportationFast
mkRequestTransportationFast requestTransportationFastType =
  RequestTransportationFast
  { requestTransportationFastType
  }

-- ** RequestUnionOnIntersection
-- | RequestUnionOnIntersection
data RequestUnionOnIntersection = RequestUnionOnIntersection
  { requestUnionOnIntersectionId :: !(Text) -- ^ /Required/ "id"
  , requestUnionOnIntersectionSearchIds :: !([Text]) -- ^ /Required/ "search_ids"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RequestUnionOnIntersection
instance A.FromJSON RequestUnionOnIntersection where
  parseJSON = A.withObject "RequestUnionOnIntersection" $ \o ->
    RequestUnionOnIntersection
      <$> (o .:  "id")
      <*> (o .:  "search_ids")

-- | ToJSON RequestUnionOnIntersection
instance A.ToJSON RequestUnionOnIntersection where
  toJSON RequestUnionOnIntersection {..} =
   _omitNulls
      [ "id" .= requestUnionOnIntersectionId
      , "search_ids" .= requestUnionOnIntersectionSearchIds
      ]


-- | Construct a value of type 'RequestUnionOnIntersection' (by applying it's required fields, if any)
mkRequestUnionOnIntersection
  :: Text -- ^ 'requestUnionOnIntersectionId' 
  -> [Text] -- ^ 'requestUnionOnIntersectionSearchIds' 
  -> RequestUnionOnIntersection
mkRequestUnionOnIntersection requestUnionOnIntersectionId requestUnionOnIntersectionSearchIds =
  RequestUnionOnIntersection
  { requestUnionOnIntersectionId
  , requestUnionOnIntersectionSearchIds
  }

-- ** ResponseBoundingBox
-- | ResponseBoundingBox
data ResponseBoundingBox = ResponseBoundingBox
  { responseBoundingBoxEnvelope :: !(ResponseBox) -- ^ /Required/ "envelope"
  , responseBoundingBoxBoxes :: !([ResponseBox]) -- ^ /Required/ "boxes"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResponseBoundingBox
instance A.FromJSON ResponseBoundingBox where
  parseJSON = A.withObject "ResponseBoundingBox" $ \o ->
    ResponseBoundingBox
      <$> (o .:  "envelope")
      <*> (o .:  "boxes")

-- | ToJSON ResponseBoundingBox
instance A.ToJSON ResponseBoundingBox where
  toJSON ResponseBoundingBox {..} =
   _omitNulls
      [ "envelope" .= responseBoundingBoxEnvelope
      , "boxes" .= responseBoundingBoxBoxes
      ]


-- | Construct a value of type 'ResponseBoundingBox' (by applying it's required fields, if any)
mkResponseBoundingBox
  :: ResponseBox -- ^ 'responseBoundingBoxEnvelope' 
  -> [ResponseBox] -- ^ 'responseBoundingBoxBoxes' 
  -> ResponseBoundingBox
mkResponseBoundingBox responseBoundingBoxEnvelope responseBoundingBoxBoxes =
  ResponseBoundingBox
  { responseBoundingBoxEnvelope
  , responseBoundingBoxBoxes
  }

-- ** ResponseBox
-- | ResponseBox
data ResponseBox = ResponseBox
  { responseBoxMinLat :: !(Double) -- ^ /Required/ "min_lat"
  , responseBoxMaxLat :: !(Double) -- ^ /Required/ "max_lat"
  , responseBoxMinLng :: !(Double) -- ^ /Required/ "min_lng"
  , responseBoxMaxLng :: !(Double) -- ^ /Required/ "max_lng"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResponseBox
instance A.FromJSON ResponseBox where
  parseJSON = A.withObject "ResponseBox" $ \o ->
    ResponseBox
      <$> (o .:  "min_lat")
      <*> (o .:  "max_lat")
      <*> (o .:  "min_lng")
      <*> (o .:  "max_lng")

-- | ToJSON ResponseBox
instance A.ToJSON ResponseBox where
  toJSON ResponseBox {..} =
   _omitNulls
      [ "min_lat" .= responseBoxMinLat
      , "max_lat" .= responseBoxMaxLat
      , "min_lng" .= responseBoxMinLng
      , "max_lng" .= responseBoxMaxLng
      ]


-- | Construct a value of type 'ResponseBox' (by applying it's required fields, if any)
mkResponseBox
  :: Double -- ^ 'responseBoxMinLat' 
  -> Double -- ^ 'responseBoxMaxLat' 
  -> Double -- ^ 'responseBoxMinLng' 
  -> Double -- ^ 'responseBoxMaxLng' 
  -> ResponseBox
mkResponseBox responseBoxMinLat responseBoxMaxLat responseBoxMinLng responseBoxMaxLng =
  ResponseBox
  { responseBoxMinLat
  , responseBoxMaxLat
  , responseBoxMinLng
  , responseBoxMaxLng
  }

-- ** ResponseDistanceBreakdownItem
-- | ResponseDistanceBreakdownItem
data ResponseDistanceBreakdownItem = ResponseDistanceBreakdownItem
  { responseDistanceBreakdownItemMode :: !(ResponseTransportationMode) -- ^ /Required/ "mode"
  , responseDistanceBreakdownItemDistance :: !(Int) -- ^ /Required/ "distance"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResponseDistanceBreakdownItem
instance A.FromJSON ResponseDistanceBreakdownItem where
  parseJSON = A.withObject "ResponseDistanceBreakdownItem" $ \o ->
    ResponseDistanceBreakdownItem
      <$> (o .:  "mode")
      <*> (o .:  "distance")

-- | ToJSON ResponseDistanceBreakdownItem
instance A.ToJSON ResponseDistanceBreakdownItem where
  toJSON ResponseDistanceBreakdownItem {..} =
   _omitNulls
      [ "mode" .= responseDistanceBreakdownItemMode
      , "distance" .= responseDistanceBreakdownItemDistance
      ]


-- | Construct a value of type 'ResponseDistanceBreakdownItem' (by applying it's required fields, if any)
mkResponseDistanceBreakdownItem
  :: ResponseTransportationMode -- ^ 'responseDistanceBreakdownItemMode' 
  -> Int -- ^ 'responseDistanceBreakdownItemDistance' 
  -> ResponseDistanceBreakdownItem
mkResponseDistanceBreakdownItem responseDistanceBreakdownItemMode responseDistanceBreakdownItemDistance =
  ResponseDistanceBreakdownItem
  { responseDistanceBreakdownItemMode
  , responseDistanceBreakdownItemDistance
  }

-- ** ResponseError
-- | ResponseError
data ResponseError = ResponseError
  { responseErrorHttpStatus :: !(Maybe Int) -- ^ "http_status"
  , responseErrorErrorCode :: !(Maybe Int) -- ^ "error_code"
  , responseErrorDescription :: !(Maybe Text) -- ^ "description"
  , responseErrorDocumentationLink :: !(Maybe Text) -- ^ "documentation_link"
  , responseErrorAdditionalInfo :: !(Maybe (Map.Map String [Text])) -- ^ "additional_info"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResponseError
instance A.FromJSON ResponseError where
  parseJSON = A.withObject "ResponseError" $ \o ->
    ResponseError
      <$> (o .:? "http_status")
      <*> (o .:? "error_code")
      <*> (o .:? "description")
      <*> (o .:? "documentation_link")
      <*> (o .:? "additional_info")

-- | ToJSON ResponseError
instance A.ToJSON ResponseError where
  toJSON ResponseError {..} =
   _omitNulls
      [ "http_status" .= responseErrorHttpStatus
      , "error_code" .= responseErrorErrorCode
      , "description" .= responseErrorDescription
      , "documentation_link" .= responseErrorDocumentationLink
      , "additional_info" .= responseErrorAdditionalInfo
      ]


-- | Construct a value of type 'ResponseError' (by applying it's required fields, if any)
mkResponseError
  :: ResponseError
mkResponseError =
  ResponseError
  { responseErrorHttpStatus = Nothing
  , responseErrorErrorCode = Nothing
  , responseErrorDescription = Nothing
  , responseErrorDocumentationLink = Nothing
  , responseErrorAdditionalInfo = Nothing
  }

-- ** ResponseFareTicket
-- | ResponseFareTicket
data ResponseFareTicket = ResponseFareTicket
  { responseFareTicketType :: !(E'Type2) -- ^ /Required/ "type"
  , responseFareTicketPrice :: !(Double) -- ^ /Required/ "price"
  , responseFareTicketCurrency :: !(Text) -- ^ /Required/ "currency"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResponseFareTicket
instance A.FromJSON ResponseFareTicket where
  parseJSON = A.withObject "ResponseFareTicket" $ \o ->
    ResponseFareTicket
      <$> (o .:  "type")
      <*> (o .:  "price")
      <*> (o .:  "currency")

-- | ToJSON ResponseFareTicket
instance A.ToJSON ResponseFareTicket where
  toJSON ResponseFareTicket {..} =
   _omitNulls
      [ "type" .= responseFareTicketType
      , "price" .= responseFareTicketPrice
      , "currency" .= responseFareTicketCurrency
      ]


-- | Construct a value of type 'ResponseFareTicket' (by applying it's required fields, if any)
mkResponseFareTicket
  :: E'Type2 -- ^ 'responseFareTicketType' 
  -> Double -- ^ 'responseFareTicketPrice' 
  -> Text -- ^ 'responseFareTicketCurrency' 
  -> ResponseFareTicket
mkResponseFareTicket responseFareTicketType responseFareTicketPrice responseFareTicketCurrency =
  ResponseFareTicket
  { responseFareTicketType
  , responseFareTicketPrice
  , responseFareTicketCurrency
  }

-- ** ResponseFares
-- | ResponseFares
data ResponseFares = ResponseFares
  { responseFaresBreakdown :: !([ResponseFaresBreakdownItem]) -- ^ /Required/ "breakdown"
  , responseFaresTicketsTotal :: !([ResponseFareTicket]) -- ^ /Required/ "tickets_total"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResponseFares
instance A.FromJSON ResponseFares where
  parseJSON = A.withObject "ResponseFares" $ \o ->
    ResponseFares
      <$> (o .:  "breakdown")
      <*> (o .:  "tickets_total")

-- | ToJSON ResponseFares
instance A.ToJSON ResponseFares where
  toJSON ResponseFares {..} =
   _omitNulls
      [ "breakdown" .= responseFaresBreakdown
      , "tickets_total" .= responseFaresTicketsTotal
      ]


-- | Construct a value of type 'ResponseFares' (by applying it's required fields, if any)
mkResponseFares
  :: [ResponseFaresBreakdownItem] -- ^ 'responseFaresBreakdown' 
  -> [ResponseFareTicket] -- ^ 'responseFaresTicketsTotal' 
  -> ResponseFares
mkResponseFares responseFaresBreakdown responseFaresTicketsTotal =
  ResponseFares
  { responseFaresBreakdown
  , responseFaresTicketsTotal
  }

-- ** ResponseFaresBreakdownItem
-- | ResponseFaresBreakdownItem
data ResponseFaresBreakdownItem = ResponseFaresBreakdownItem
  { responseFaresBreakdownItemModes :: !([ResponseTransportationMode]) -- ^ /Required/ "modes"
  , responseFaresBreakdownItemRoutePartIds :: !([Int]) -- ^ /Required/ "route_part_ids"
  , responseFaresBreakdownItemTickets :: !([ResponseFareTicket]) -- ^ /Required/ "tickets"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResponseFaresBreakdownItem
instance A.FromJSON ResponseFaresBreakdownItem where
  parseJSON = A.withObject "ResponseFaresBreakdownItem" $ \o ->
    ResponseFaresBreakdownItem
      <$> (o .:  "modes")
      <*> (o .:  "route_part_ids")
      <*> (o .:  "tickets")

-- | ToJSON ResponseFaresBreakdownItem
instance A.ToJSON ResponseFaresBreakdownItem where
  toJSON ResponseFaresBreakdownItem {..} =
   _omitNulls
      [ "modes" .= responseFaresBreakdownItemModes
      , "route_part_ids" .= responseFaresBreakdownItemRoutePartIds
      , "tickets" .= responseFaresBreakdownItemTickets
      ]


-- | Construct a value of type 'ResponseFaresBreakdownItem' (by applying it's required fields, if any)
mkResponseFaresBreakdownItem
  :: [ResponseTransportationMode] -- ^ 'responseFaresBreakdownItemModes' 
  -> [Int] -- ^ 'responseFaresBreakdownItemRoutePartIds' 
  -> [ResponseFareTicket] -- ^ 'responseFaresBreakdownItemTickets' 
  -> ResponseFaresBreakdownItem
mkResponseFaresBreakdownItem responseFaresBreakdownItemModes responseFaresBreakdownItemRoutePartIds responseFaresBreakdownItemTickets =
  ResponseFaresBreakdownItem
  { responseFaresBreakdownItemModes
  , responseFaresBreakdownItemRoutePartIds
  , responseFaresBreakdownItemTickets
  }

-- ** ResponseFaresFast
-- | ResponseFaresFast
data ResponseFaresFast = ResponseFaresFast
  { responseFaresFastTicketsTotal :: !([ResponseFareTicket]) -- ^ /Required/ "tickets_total"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResponseFaresFast
instance A.FromJSON ResponseFaresFast where
  parseJSON = A.withObject "ResponseFaresFast" $ \o ->
    ResponseFaresFast
      <$> (o .:  "tickets_total")

-- | ToJSON ResponseFaresFast
instance A.ToJSON ResponseFaresFast where
  toJSON ResponseFaresFast {..} =
   _omitNulls
      [ "tickets_total" .= responseFaresFastTicketsTotal
      ]


-- | Construct a value of type 'ResponseFaresFast' (by applying it's required fields, if any)
mkResponseFaresFast
  :: [ResponseFareTicket] -- ^ 'responseFaresFastTicketsTotal' 
  -> ResponseFaresFast
mkResponseFaresFast responseFaresFastTicketsTotal =
  ResponseFaresFast
  { responseFaresFastTicketsTotal
  }

-- ** ResponseGeocoding
-- | ResponseGeocoding
data ResponseGeocoding = ResponseGeocoding
  { responseGeocodingType :: !(Text) -- ^ /Required/ "type"
  , responseGeocodingFeatures :: !([ResponseGeocodingGeoJsonFeature]) -- ^ /Required/ "features"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResponseGeocoding
instance A.FromJSON ResponseGeocoding where
  parseJSON = A.withObject "ResponseGeocoding" $ \o ->
    ResponseGeocoding
      <$> (o .:  "type")
      <*> (o .:  "features")

-- | ToJSON ResponseGeocoding
instance A.ToJSON ResponseGeocoding where
  toJSON ResponseGeocoding {..} =
   _omitNulls
      [ "type" .= responseGeocodingType
      , "features" .= responseGeocodingFeatures
      ]


-- | Construct a value of type 'ResponseGeocoding' (by applying it's required fields, if any)
mkResponseGeocoding
  :: Text -- ^ 'responseGeocodingType' 
  -> [ResponseGeocodingGeoJsonFeature] -- ^ 'responseGeocodingFeatures' 
  -> ResponseGeocoding
mkResponseGeocoding responseGeocodingType responseGeocodingFeatures =
  ResponseGeocoding
  { responseGeocodingType
  , responseGeocodingFeatures
  }

-- ** ResponseGeocodingGeoJsonFeature
-- | ResponseGeocodingGeoJsonFeature
data ResponseGeocodingGeoJsonFeature = ResponseGeocodingGeoJsonFeature
  { responseGeocodingGeoJsonFeatureType :: !(Text) -- ^ /Required/ "type"
  , responseGeocodingGeoJsonFeatureGeometry :: !(ResponseGeocodingGeometry) -- ^ /Required/ "geometry"
  , responseGeocodingGeoJsonFeatureProperties :: !(ResponseGeocodingProperties) -- ^ /Required/ "properties"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResponseGeocodingGeoJsonFeature
instance A.FromJSON ResponseGeocodingGeoJsonFeature where
  parseJSON = A.withObject "ResponseGeocodingGeoJsonFeature" $ \o ->
    ResponseGeocodingGeoJsonFeature
      <$> (o .:  "type")
      <*> (o .:  "geometry")
      <*> (o .:  "properties")

-- | ToJSON ResponseGeocodingGeoJsonFeature
instance A.ToJSON ResponseGeocodingGeoJsonFeature where
  toJSON ResponseGeocodingGeoJsonFeature {..} =
   _omitNulls
      [ "type" .= responseGeocodingGeoJsonFeatureType
      , "geometry" .= responseGeocodingGeoJsonFeatureGeometry
      , "properties" .= responseGeocodingGeoJsonFeatureProperties
      ]


-- | Construct a value of type 'ResponseGeocodingGeoJsonFeature' (by applying it's required fields, if any)
mkResponseGeocodingGeoJsonFeature
  :: Text -- ^ 'responseGeocodingGeoJsonFeatureType' 
  -> ResponseGeocodingGeometry -- ^ 'responseGeocodingGeoJsonFeatureGeometry' 
  -> ResponseGeocodingProperties -- ^ 'responseGeocodingGeoJsonFeatureProperties' 
  -> ResponseGeocodingGeoJsonFeature
mkResponseGeocodingGeoJsonFeature responseGeocodingGeoJsonFeatureType responseGeocodingGeoJsonFeatureGeometry responseGeocodingGeoJsonFeatureProperties =
  ResponseGeocodingGeoJsonFeature
  { responseGeocodingGeoJsonFeatureType
  , responseGeocodingGeoJsonFeatureGeometry
  , responseGeocodingGeoJsonFeatureProperties
  }

-- ** ResponseGeocodingGeometry
-- | ResponseGeocodingGeometry
data ResponseGeocodingGeometry = ResponseGeocodingGeometry
  { responseGeocodingGeometryType :: !(Text) -- ^ /Required/ "type"
  , responseGeocodingGeometryCoordinates :: !([Double]) -- ^ /Required/ "coordinates"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResponseGeocodingGeometry
instance A.FromJSON ResponseGeocodingGeometry where
  parseJSON = A.withObject "ResponseGeocodingGeometry" $ \o ->
    ResponseGeocodingGeometry
      <$> (o .:  "type")
      <*> (o .:  "coordinates")

-- | ToJSON ResponseGeocodingGeometry
instance A.ToJSON ResponseGeocodingGeometry where
  toJSON ResponseGeocodingGeometry {..} =
   _omitNulls
      [ "type" .= responseGeocodingGeometryType
      , "coordinates" .= responseGeocodingGeometryCoordinates
      ]


-- | Construct a value of type 'ResponseGeocodingGeometry' (by applying it's required fields, if any)
mkResponseGeocodingGeometry
  :: Text -- ^ 'responseGeocodingGeometryType' 
  -> [Double] -- ^ 'responseGeocodingGeometryCoordinates' 
  -> ResponseGeocodingGeometry
mkResponseGeocodingGeometry responseGeocodingGeometryType responseGeocodingGeometryCoordinates =
  ResponseGeocodingGeometry
  { responseGeocodingGeometryType
  , responseGeocodingGeometryCoordinates
  }

-- ** ResponseGeocodingProperties
-- | ResponseGeocodingProperties
data ResponseGeocodingProperties = ResponseGeocodingProperties
  { responseGeocodingPropertiesName :: !(Text) -- ^ /Required/ "name"
  , responseGeocodingPropertiesLabel :: !(Text) -- ^ /Required/ "label"
  , responseGeocodingPropertiesScore :: !(Maybe Double) -- ^ "score"
  , responseGeocodingPropertiesHouseNumber :: !(Maybe Text) -- ^ "house_number"
  , responseGeocodingPropertiesStreet :: !(Maybe Text) -- ^ "street"
  , responseGeocodingPropertiesRegion :: !(Maybe Text) -- ^ "region"
  , responseGeocodingPropertiesRegionCode :: !(Maybe Text) -- ^ "region_code"
  , responseGeocodingPropertiesNeighbourhood :: !(Maybe Text) -- ^ "neighbourhood"
  , responseGeocodingPropertiesCounty :: !(Maybe Text) -- ^ "county"
  , responseGeocodingPropertiesMacroregion :: !(Maybe Text) -- ^ "macroregion"
  , responseGeocodingPropertiesCity :: !(Maybe Text) -- ^ "city"
  , responseGeocodingPropertiesCountry :: !(Maybe Text) -- ^ "country"
  , responseGeocodingPropertiesCountryCode :: !(Maybe Text) -- ^ "country_code"
  , responseGeocodingPropertiesContinent :: !(Maybe Text) -- ^ "continent"
  , responseGeocodingPropertiesPostcode :: !(Maybe Text) -- ^ "postcode"
  , responseGeocodingPropertiesFeatures :: !(Maybe ResponseMapInfoFeatures) -- ^ "features"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResponseGeocodingProperties
instance A.FromJSON ResponseGeocodingProperties where
  parseJSON = A.withObject "ResponseGeocodingProperties" $ \o ->
    ResponseGeocodingProperties
      <$> (o .:  "name")
      <*> (o .:  "label")
      <*> (o .:? "score")
      <*> (o .:? "house_number")
      <*> (o .:? "street")
      <*> (o .:? "region")
      <*> (o .:? "region_code")
      <*> (o .:? "neighbourhood")
      <*> (o .:? "county")
      <*> (o .:? "macroregion")
      <*> (o .:? "city")
      <*> (o .:? "country")
      <*> (o .:? "country_code")
      <*> (o .:? "continent")
      <*> (o .:? "postcode")
      <*> (o .:? "features")

-- | ToJSON ResponseGeocodingProperties
instance A.ToJSON ResponseGeocodingProperties where
  toJSON ResponseGeocodingProperties {..} =
   _omitNulls
      [ "name" .= responseGeocodingPropertiesName
      , "label" .= responseGeocodingPropertiesLabel
      , "score" .= responseGeocodingPropertiesScore
      , "house_number" .= responseGeocodingPropertiesHouseNumber
      , "street" .= responseGeocodingPropertiesStreet
      , "region" .= responseGeocodingPropertiesRegion
      , "region_code" .= responseGeocodingPropertiesRegionCode
      , "neighbourhood" .= responseGeocodingPropertiesNeighbourhood
      , "county" .= responseGeocodingPropertiesCounty
      , "macroregion" .= responseGeocodingPropertiesMacroregion
      , "city" .= responseGeocodingPropertiesCity
      , "country" .= responseGeocodingPropertiesCountry
      , "country_code" .= responseGeocodingPropertiesCountryCode
      , "continent" .= responseGeocodingPropertiesContinent
      , "postcode" .= responseGeocodingPropertiesPostcode
      , "features" .= responseGeocodingPropertiesFeatures
      ]


-- | Construct a value of type 'ResponseGeocodingProperties' (by applying it's required fields, if any)
mkResponseGeocodingProperties
  :: Text -- ^ 'responseGeocodingPropertiesName' 
  -> Text -- ^ 'responseGeocodingPropertiesLabel' 
  -> ResponseGeocodingProperties
mkResponseGeocodingProperties responseGeocodingPropertiesName responseGeocodingPropertiesLabel =
  ResponseGeocodingProperties
  { responseGeocodingPropertiesName
  , responseGeocodingPropertiesLabel
  , responseGeocodingPropertiesScore = Nothing
  , responseGeocodingPropertiesHouseNumber = Nothing
  , responseGeocodingPropertiesStreet = Nothing
  , responseGeocodingPropertiesRegion = Nothing
  , responseGeocodingPropertiesRegionCode = Nothing
  , responseGeocodingPropertiesNeighbourhood = Nothing
  , responseGeocodingPropertiesCounty = Nothing
  , responseGeocodingPropertiesMacroregion = Nothing
  , responseGeocodingPropertiesCity = Nothing
  , responseGeocodingPropertiesCountry = Nothing
  , responseGeocodingPropertiesCountryCode = Nothing
  , responseGeocodingPropertiesContinent = Nothing
  , responseGeocodingPropertiesPostcode = Nothing
  , responseGeocodingPropertiesFeatures = Nothing
  }

-- ** ResponseMapInfo
-- | ResponseMapInfo
data ResponseMapInfo = ResponseMapInfo
  { responseMapInfoMaps :: !([ResponseMapInfoMap]) -- ^ /Required/ "maps"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResponseMapInfo
instance A.FromJSON ResponseMapInfo where
  parseJSON = A.withObject "ResponseMapInfo" $ \o ->
    ResponseMapInfo
      <$> (o .:  "maps")

-- | ToJSON ResponseMapInfo
instance A.ToJSON ResponseMapInfo where
  toJSON ResponseMapInfo {..} =
   _omitNulls
      [ "maps" .= responseMapInfoMaps
      ]


-- | Construct a value of type 'ResponseMapInfo' (by applying it's required fields, if any)
mkResponseMapInfo
  :: [ResponseMapInfoMap] -- ^ 'responseMapInfoMaps' 
  -> ResponseMapInfo
mkResponseMapInfo responseMapInfoMaps =
  ResponseMapInfo
  { responseMapInfoMaps
  }

-- ** ResponseMapInfoFeatures
-- | ResponseMapInfoFeatures
data ResponseMapInfoFeatures = ResponseMapInfoFeatures
  { responseMapInfoFeaturesPublicTransport :: !(Maybe ResponseMapInfoFeaturesPublicTransport) -- ^ "public_transport"
  , responseMapInfoFeaturesFares :: !(Bool) -- ^ /Required/ "fares"
  , responseMapInfoFeaturesPostcodes :: !(Bool) -- ^ /Required/ "postcodes"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResponseMapInfoFeatures
instance A.FromJSON ResponseMapInfoFeatures where
  parseJSON = A.withObject "ResponseMapInfoFeatures" $ \o ->
    ResponseMapInfoFeatures
      <$> (o .:? "public_transport")
      <*> (o .:  "fares")
      <*> (o .:  "postcodes")

-- | ToJSON ResponseMapInfoFeatures
instance A.ToJSON ResponseMapInfoFeatures where
  toJSON ResponseMapInfoFeatures {..} =
   _omitNulls
      [ "public_transport" .= responseMapInfoFeaturesPublicTransport
      , "fares" .= responseMapInfoFeaturesFares
      , "postcodes" .= responseMapInfoFeaturesPostcodes
      ]


-- | Construct a value of type 'ResponseMapInfoFeatures' (by applying it's required fields, if any)
mkResponseMapInfoFeatures
  :: Bool -- ^ 'responseMapInfoFeaturesFares' 
  -> Bool -- ^ 'responseMapInfoFeaturesPostcodes' 
  -> ResponseMapInfoFeatures
mkResponseMapInfoFeatures responseMapInfoFeaturesFares responseMapInfoFeaturesPostcodes =
  ResponseMapInfoFeatures
  { responseMapInfoFeaturesPublicTransport = Nothing
  , responseMapInfoFeaturesFares
  , responseMapInfoFeaturesPostcodes
  }

-- ** ResponseMapInfoFeaturesPublicTransport
-- | ResponseMapInfoFeaturesPublicTransport
data ResponseMapInfoFeaturesPublicTransport = ResponseMapInfoFeaturesPublicTransport
  { responseMapInfoFeaturesPublicTransportDateStart :: !(DateTime) -- ^ /Required/ "date_start"
  , responseMapInfoFeaturesPublicTransportDateEnd :: !(DateTime) -- ^ /Required/ "date_end"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResponseMapInfoFeaturesPublicTransport
instance A.FromJSON ResponseMapInfoFeaturesPublicTransport where
  parseJSON = A.withObject "ResponseMapInfoFeaturesPublicTransport" $ \o ->
    ResponseMapInfoFeaturesPublicTransport
      <$> (o .:  "date_start")
      <*> (o .:  "date_end")

-- | ToJSON ResponseMapInfoFeaturesPublicTransport
instance A.ToJSON ResponseMapInfoFeaturesPublicTransport where
  toJSON ResponseMapInfoFeaturesPublicTransport {..} =
   _omitNulls
      [ "date_start" .= responseMapInfoFeaturesPublicTransportDateStart
      , "date_end" .= responseMapInfoFeaturesPublicTransportDateEnd
      ]


-- | Construct a value of type 'ResponseMapInfoFeaturesPublicTransport' (by applying it's required fields, if any)
mkResponseMapInfoFeaturesPublicTransport
  :: DateTime -- ^ 'responseMapInfoFeaturesPublicTransportDateStart' 
  -> DateTime -- ^ 'responseMapInfoFeaturesPublicTransportDateEnd' 
  -> ResponseMapInfoFeaturesPublicTransport
mkResponseMapInfoFeaturesPublicTransport responseMapInfoFeaturesPublicTransportDateStart responseMapInfoFeaturesPublicTransportDateEnd =
  ResponseMapInfoFeaturesPublicTransport
  { responseMapInfoFeaturesPublicTransportDateStart
  , responseMapInfoFeaturesPublicTransportDateEnd
  }

-- ** ResponseMapInfoMap
-- | ResponseMapInfoMap
data ResponseMapInfoMap = ResponseMapInfoMap
  { responseMapInfoMapName :: !(Text) -- ^ /Required/ "name"
  , responseMapInfoMapFeatures :: !(ResponseMapInfoFeatures) -- ^ /Required/ "features"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResponseMapInfoMap
instance A.FromJSON ResponseMapInfoMap where
  parseJSON = A.withObject "ResponseMapInfoMap" $ \o ->
    ResponseMapInfoMap
      <$> (o .:  "name")
      <*> (o .:  "features")

-- | ToJSON ResponseMapInfoMap
instance A.ToJSON ResponseMapInfoMap where
  toJSON ResponseMapInfoMap {..} =
   _omitNulls
      [ "name" .= responseMapInfoMapName
      , "features" .= responseMapInfoMapFeatures
      ]


-- | Construct a value of type 'ResponseMapInfoMap' (by applying it's required fields, if any)
mkResponseMapInfoMap
  :: Text -- ^ 'responseMapInfoMapName' 
  -> ResponseMapInfoFeatures -- ^ 'responseMapInfoMapFeatures' 
  -> ResponseMapInfoMap
mkResponseMapInfoMap responseMapInfoMapName responseMapInfoMapFeatures =
  ResponseMapInfoMap
  { responseMapInfoMapName
  , responseMapInfoMapFeatures
  }

-- ** ResponseRoute
-- | ResponseRoute
data ResponseRoute = ResponseRoute
  { responseRouteDepartureTime :: !(DateTime) -- ^ /Required/ "departure_time"
  , responseRouteArrivalTime :: !(DateTime) -- ^ /Required/ "arrival_time"
  , responseRouteParts :: !([ResponseRoutePart]) -- ^ /Required/ "parts"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResponseRoute
instance A.FromJSON ResponseRoute where
  parseJSON = A.withObject "ResponseRoute" $ \o ->
    ResponseRoute
      <$> (o .:  "departure_time")
      <*> (o .:  "arrival_time")
      <*> (o .:  "parts")

-- | ToJSON ResponseRoute
instance A.ToJSON ResponseRoute where
  toJSON ResponseRoute {..} =
   _omitNulls
      [ "departure_time" .= responseRouteDepartureTime
      , "arrival_time" .= responseRouteArrivalTime
      , "parts" .= responseRouteParts
      ]


-- | Construct a value of type 'ResponseRoute' (by applying it's required fields, if any)
mkResponseRoute
  :: DateTime -- ^ 'responseRouteDepartureTime' 
  -> DateTime -- ^ 'responseRouteArrivalTime' 
  -> [ResponseRoutePart] -- ^ 'responseRouteParts' 
  -> ResponseRoute
mkResponseRoute responseRouteDepartureTime responseRouteArrivalTime responseRouteParts =
  ResponseRoute
  { responseRouteDepartureTime
  , responseRouteArrivalTime
  , responseRouteParts
  }

-- ** ResponseRoutePart
-- | ResponseRoutePart
data ResponseRoutePart = ResponseRoutePart
  { responseRoutePartId :: !(Text) -- ^ /Required/ "id"
  , responseRoutePartType :: !(E'Type3) -- ^ /Required/ "type"
  , responseRoutePartMode :: !(ResponseTransportationMode) -- ^ /Required/ "mode"
  , responseRoutePartDirections :: !(Text) -- ^ /Required/ "directions"
  , responseRoutePartDistance :: !(Int) -- ^ /Required/ "distance"
  , responseRoutePartTravelTime :: !(Int) -- ^ /Required/ "travel_time"
  , responseRoutePartCoords :: !([Coords]) -- ^ /Required/ "coords"
  , responseRoutePartDirection :: !(Maybe Text) -- ^ "direction"
  , responseRoutePartRoad :: !(Maybe Text) -- ^ "road"
  , responseRoutePartTurn :: !(Maybe Text) -- ^ "turn"
  , responseRoutePartLine :: !(Maybe Text) -- ^ "line"
  , responseRoutePartDepartureStation :: !(Maybe Text) -- ^ "departure_station"
  , responseRoutePartArrivalStation :: !(Maybe Text) -- ^ "arrival_station"
  , responseRoutePartDepartsAt :: !(Maybe Text) -- ^ "departs_at"
  , responseRoutePartArrivesAt :: !(Maybe Text) -- ^ "arrives_at"
  , responseRoutePartNumStops :: !(Maybe Int) -- ^ "num_stops"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResponseRoutePart
instance A.FromJSON ResponseRoutePart where
  parseJSON = A.withObject "ResponseRoutePart" $ \o ->
    ResponseRoutePart
      <$> (o .:  "id")
      <*> (o .:  "type")
      <*> (o .:  "mode")
      <*> (o .:  "directions")
      <*> (o .:  "distance")
      <*> (o .:  "travel_time")
      <*> (o .:  "coords")
      <*> (o .:? "direction")
      <*> (o .:? "road")
      <*> (o .:? "turn")
      <*> (o .:? "line")
      <*> (o .:? "departure_station")
      <*> (o .:? "arrival_station")
      <*> (o .:? "departs_at")
      <*> (o .:? "arrives_at")
      <*> (o .:? "num_stops")

-- | ToJSON ResponseRoutePart
instance A.ToJSON ResponseRoutePart where
  toJSON ResponseRoutePart {..} =
   _omitNulls
      [ "id" .= responseRoutePartId
      , "type" .= responseRoutePartType
      , "mode" .= responseRoutePartMode
      , "directions" .= responseRoutePartDirections
      , "distance" .= responseRoutePartDistance
      , "travel_time" .= responseRoutePartTravelTime
      , "coords" .= responseRoutePartCoords
      , "direction" .= responseRoutePartDirection
      , "road" .= responseRoutePartRoad
      , "turn" .= responseRoutePartTurn
      , "line" .= responseRoutePartLine
      , "departure_station" .= responseRoutePartDepartureStation
      , "arrival_station" .= responseRoutePartArrivalStation
      , "departs_at" .= responseRoutePartDepartsAt
      , "arrives_at" .= responseRoutePartArrivesAt
      , "num_stops" .= responseRoutePartNumStops
      ]


-- | Construct a value of type 'ResponseRoutePart' (by applying it's required fields, if any)
mkResponseRoutePart
  :: Text -- ^ 'responseRoutePartId' 
  -> E'Type3 -- ^ 'responseRoutePartType' 
  -> ResponseTransportationMode -- ^ 'responseRoutePartMode' 
  -> Text -- ^ 'responseRoutePartDirections' 
  -> Int -- ^ 'responseRoutePartDistance' 
  -> Int -- ^ 'responseRoutePartTravelTime' 
  -> [Coords] -- ^ 'responseRoutePartCoords' 
  -> ResponseRoutePart
mkResponseRoutePart responseRoutePartId responseRoutePartType responseRoutePartMode responseRoutePartDirections responseRoutePartDistance responseRoutePartTravelTime responseRoutePartCoords =
  ResponseRoutePart
  { responseRoutePartId
  , responseRoutePartType
  , responseRoutePartMode
  , responseRoutePartDirections
  , responseRoutePartDistance
  , responseRoutePartTravelTime
  , responseRoutePartCoords
  , responseRoutePartDirection = Nothing
  , responseRoutePartRoad = Nothing
  , responseRoutePartTurn = Nothing
  , responseRoutePartLine = Nothing
  , responseRoutePartDepartureStation = Nothing
  , responseRoutePartArrivalStation = Nothing
  , responseRoutePartDepartsAt = Nothing
  , responseRoutePartArrivesAt = Nothing
  , responseRoutePartNumStops = Nothing
  }

-- ** ResponseRoutes
-- | ResponseRoutes
data ResponseRoutes = ResponseRoutes
  { responseRoutesResults :: !([ResponseRoutesResult]) -- ^ /Required/ "results"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResponseRoutes
instance A.FromJSON ResponseRoutes where
  parseJSON = A.withObject "ResponseRoutes" $ \o ->
    ResponseRoutes
      <$> (o .:  "results")

-- | ToJSON ResponseRoutes
instance A.ToJSON ResponseRoutes where
  toJSON ResponseRoutes {..} =
   _omitNulls
      [ "results" .= responseRoutesResults
      ]


-- | Construct a value of type 'ResponseRoutes' (by applying it's required fields, if any)
mkResponseRoutes
  :: [ResponseRoutesResult] -- ^ 'responseRoutesResults' 
  -> ResponseRoutes
mkResponseRoutes responseRoutesResults =
  ResponseRoutes
  { responseRoutesResults
  }

-- ** ResponseRoutesLocation
-- | ResponseRoutesLocation
data ResponseRoutesLocation = ResponseRoutesLocation
  { responseRoutesLocationId :: !(Text) -- ^ /Required/ "id"
  , responseRoutesLocationProperties :: !([ResponseRoutesProperties]) -- ^ /Required/ "properties"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResponseRoutesLocation
instance A.FromJSON ResponseRoutesLocation where
  parseJSON = A.withObject "ResponseRoutesLocation" $ \o ->
    ResponseRoutesLocation
      <$> (o .:  "id")
      <*> (o .:  "properties")

-- | ToJSON ResponseRoutesLocation
instance A.ToJSON ResponseRoutesLocation where
  toJSON ResponseRoutesLocation {..} =
   _omitNulls
      [ "id" .= responseRoutesLocationId
      , "properties" .= responseRoutesLocationProperties
      ]


-- | Construct a value of type 'ResponseRoutesLocation' (by applying it's required fields, if any)
mkResponseRoutesLocation
  :: Text -- ^ 'responseRoutesLocationId' 
  -> [ResponseRoutesProperties] -- ^ 'responseRoutesLocationProperties' 
  -> ResponseRoutesLocation
mkResponseRoutesLocation responseRoutesLocationId responseRoutesLocationProperties =
  ResponseRoutesLocation
  { responseRoutesLocationId
  , responseRoutesLocationProperties
  }

-- ** ResponseRoutesProperties
-- | ResponseRoutesProperties
data ResponseRoutesProperties = ResponseRoutesProperties
  { responseRoutesPropertiesTravelTime :: !(Maybe Int) -- ^ "travel_time"
  , responseRoutesPropertiesDistance :: !(Maybe Int) -- ^ "distance"
  , responseRoutesPropertiesFares :: !(Maybe ResponseFares) -- ^ "fares"
  , responseRoutesPropertiesRoute :: !(Maybe ResponseRoute) -- ^ "route"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResponseRoutesProperties
instance A.FromJSON ResponseRoutesProperties where
  parseJSON = A.withObject "ResponseRoutesProperties" $ \o ->
    ResponseRoutesProperties
      <$> (o .:? "travel_time")
      <*> (o .:? "distance")
      <*> (o .:? "fares")
      <*> (o .:? "route")

-- | ToJSON ResponseRoutesProperties
instance A.ToJSON ResponseRoutesProperties where
  toJSON ResponseRoutesProperties {..} =
   _omitNulls
      [ "travel_time" .= responseRoutesPropertiesTravelTime
      , "distance" .= responseRoutesPropertiesDistance
      , "fares" .= responseRoutesPropertiesFares
      , "route" .= responseRoutesPropertiesRoute
      ]


-- | Construct a value of type 'ResponseRoutesProperties' (by applying it's required fields, if any)
mkResponseRoutesProperties
  :: ResponseRoutesProperties
mkResponseRoutesProperties =
  ResponseRoutesProperties
  { responseRoutesPropertiesTravelTime = Nothing
  , responseRoutesPropertiesDistance = Nothing
  , responseRoutesPropertiesFares = Nothing
  , responseRoutesPropertiesRoute = Nothing
  }

-- ** ResponseRoutesResult
-- | ResponseRoutesResult
data ResponseRoutesResult = ResponseRoutesResult
  { responseRoutesResultSearchId :: !(Text) -- ^ /Required/ "search_id"
  , responseRoutesResultLocations :: !([ResponseRoutesLocation]) -- ^ /Required/ "locations"
  , responseRoutesResultUnreachable :: !([Text]) -- ^ /Required/ "unreachable"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResponseRoutesResult
instance A.FromJSON ResponseRoutesResult where
  parseJSON = A.withObject "ResponseRoutesResult" $ \o ->
    ResponseRoutesResult
      <$> (o .:  "search_id")
      <*> (o .:  "locations")
      <*> (o .:  "unreachable")

-- | ToJSON ResponseRoutesResult
instance A.ToJSON ResponseRoutesResult where
  toJSON ResponseRoutesResult {..} =
   _omitNulls
      [ "search_id" .= responseRoutesResultSearchId
      , "locations" .= responseRoutesResultLocations
      , "unreachable" .= responseRoutesResultUnreachable
      ]


-- | Construct a value of type 'ResponseRoutesResult' (by applying it's required fields, if any)
mkResponseRoutesResult
  :: Text -- ^ 'responseRoutesResultSearchId' 
  -> [ResponseRoutesLocation] -- ^ 'responseRoutesResultLocations' 
  -> [Text] -- ^ 'responseRoutesResultUnreachable' 
  -> ResponseRoutesResult
mkResponseRoutesResult responseRoutesResultSearchId responseRoutesResultLocations responseRoutesResultUnreachable =
  ResponseRoutesResult
  { responseRoutesResultSearchId
  , responseRoutesResultLocations
  , responseRoutesResultUnreachable
  }

-- ** ResponseShape
-- | ResponseShape
data ResponseShape = ResponseShape
  { responseShapeShell :: !([Coords]) -- ^ /Required/ "shell"
  , responseShapeHoles :: !([[Coords]]) -- ^ /Required/ "holes"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResponseShape
instance A.FromJSON ResponseShape where
  parseJSON = A.withObject "ResponseShape" $ \o ->
    ResponseShape
      <$> (o .:  "shell")
      <*> (o .:  "holes")

-- | ToJSON ResponseShape
instance A.ToJSON ResponseShape where
  toJSON ResponseShape {..} =
   _omitNulls
      [ "shell" .= responseShapeShell
      , "holes" .= responseShapeHoles
      ]


-- | Construct a value of type 'ResponseShape' (by applying it's required fields, if any)
mkResponseShape
  :: [Coords] -- ^ 'responseShapeShell' 
  -> [[Coords]] -- ^ 'responseShapeHoles' 
  -> ResponseShape
mkResponseShape responseShapeShell responseShapeHoles =
  ResponseShape
  { responseShapeShell
  , responseShapeHoles
  }

-- ** ResponseSupportedLocation
-- | ResponseSupportedLocation
data ResponseSupportedLocation = ResponseSupportedLocation
  { responseSupportedLocationId :: !(Text) -- ^ /Required/ "id"
  , responseSupportedLocationMapName :: !(Text) -- ^ /Required/ "map_name"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResponseSupportedLocation
instance A.FromJSON ResponseSupportedLocation where
  parseJSON = A.withObject "ResponseSupportedLocation" $ \o ->
    ResponseSupportedLocation
      <$> (o .:  "id")
      <*> (o .:  "map_name")

-- | ToJSON ResponseSupportedLocation
instance A.ToJSON ResponseSupportedLocation where
  toJSON ResponseSupportedLocation {..} =
   _omitNulls
      [ "id" .= responseSupportedLocationId
      , "map_name" .= responseSupportedLocationMapName
      ]


-- | Construct a value of type 'ResponseSupportedLocation' (by applying it's required fields, if any)
mkResponseSupportedLocation
  :: Text -- ^ 'responseSupportedLocationId' 
  -> Text -- ^ 'responseSupportedLocationMapName' 
  -> ResponseSupportedLocation
mkResponseSupportedLocation responseSupportedLocationId responseSupportedLocationMapName =
  ResponseSupportedLocation
  { responseSupportedLocationId
  , responseSupportedLocationMapName
  }

-- ** ResponseSupportedLocations
-- | ResponseSupportedLocations
data ResponseSupportedLocations = ResponseSupportedLocations
  { responseSupportedLocationsLocations :: !([ResponseSupportedLocation]) -- ^ /Required/ "locations"
  , responseSupportedLocationsUnsupportedLocations :: !([Text]) -- ^ /Required/ "unsupported_locations"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResponseSupportedLocations
instance A.FromJSON ResponseSupportedLocations where
  parseJSON = A.withObject "ResponseSupportedLocations" $ \o ->
    ResponseSupportedLocations
      <$> (o .:  "locations")
      <*> (o .:  "unsupported_locations")

-- | ToJSON ResponseSupportedLocations
instance A.ToJSON ResponseSupportedLocations where
  toJSON ResponseSupportedLocations {..} =
   _omitNulls
      [ "locations" .= responseSupportedLocationsLocations
      , "unsupported_locations" .= responseSupportedLocationsUnsupportedLocations
      ]


-- | Construct a value of type 'ResponseSupportedLocations' (by applying it's required fields, if any)
mkResponseSupportedLocations
  :: [ResponseSupportedLocation] -- ^ 'responseSupportedLocationsLocations' 
  -> [Text] -- ^ 'responseSupportedLocationsUnsupportedLocations' 
  -> ResponseSupportedLocations
mkResponseSupportedLocations responseSupportedLocationsLocations responseSupportedLocationsUnsupportedLocations =
  ResponseSupportedLocations
  { responseSupportedLocationsLocations
  , responseSupportedLocationsUnsupportedLocations
  }

-- ** ResponseTimeFilter
-- | ResponseTimeFilter
data ResponseTimeFilter = ResponseTimeFilter
  { responseTimeFilterResults :: !([ResponseTimeFilterResult]) -- ^ /Required/ "results"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResponseTimeFilter
instance A.FromJSON ResponseTimeFilter where
  parseJSON = A.withObject "ResponseTimeFilter" $ \o ->
    ResponseTimeFilter
      <$> (o .:  "results")

-- | ToJSON ResponseTimeFilter
instance A.ToJSON ResponseTimeFilter where
  toJSON ResponseTimeFilter {..} =
   _omitNulls
      [ "results" .= responseTimeFilterResults
      ]


-- | Construct a value of type 'ResponseTimeFilter' (by applying it's required fields, if any)
mkResponseTimeFilter
  :: [ResponseTimeFilterResult] -- ^ 'responseTimeFilterResults' 
  -> ResponseTimeFilter
mkResponseTimeFilter responseTimeFilterResults =
  ResponseTimeFilter
  { responseTimeFilterResults
  }

-- ** ResponseTimeFilterFast
-- | ResponseTimeFilterFast
data ResponseTimeFilterFast = ResponseTimeFilterFast
  { responseTimeFilterFastResults :: !([ResponseTimeFilterFastResult]) -- ^ /Required/ "results"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResponseTimeFilterFast
instance A.FromJSON ResponseTimeFilterFast where
  parseJSON = A.withObject "ResponseTimeFilterFast" $ \o ->
    ResponseTimeFilterFast
      <$> (o .:  "results")

-- | ToJSON ResponseTimeFilterFast
instance A.ToJSON ResponseTimeFilterFast where
  toJSON ResponseTimeFilterFast {..} =
   _omitNulls
      [ "results" .= responseTimeFilterFastResults
      ]


-- | Construct a value of type 'ResponseTimeFilterFast' (by applying it's required fields, if any)
mkResponseTimeFilterFast
  :: [ResponseTimeFilterFastResult] -- ^ 'responseTimeFilterFastResults' 
  -> ResponseTimeFilterFast
mkResponseTimeFilterFast responseTimeFilterFastResults =
  ResponseTimeFilterFast
  { responseTimeFilterFastResults
  }

-- ** ResponseTimeFilterFastLocation
-- | ResponseTimeFilterFastLocation
data ResponseTimeFilterFastLocation = ResponseTimeFilterFastLocation
  { responseTimeFilterFastLocationId :: !(Text) -- ^ /Required/ "id"
  , responseTimeFilterFastLocationProperties :: !([ResponseTimeFilterFastProperties]) -- ^ /Required/ "properties"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResponseTimeFilterFastLocation
instance A.FromJSON ResponseTimeFilterFastLocation where
  parseJSON = A.withObject "ResponseTimeFilterFastLocation" $ \o ->
    ResponseTimeFilterFastLocation
      <$> (o .:  "id")
      <*> (o .:  "properties")

-- | ToJSON ResponseTimeFilterFastLocation
instance A.ToJSON ResponseTimeFilterFastLocation where
  toJSON ResponseTimeFilterFastLocation {..} =
   _omitNulls
      [ "id" .= responseTimeFilterFastLocationId
      , "properties" .= responseTimeFilterFastLocationProperties
      ]


-- | Construct a value of type 'ResponseTimeFilterFastLocation' (by applying it's required fields, if any)
mkResponseTimeFilterFastLocation
  :: Text -- ^ 'responseTimeFilterFastLocationId' 
  -> [ResponseTimeFilterFastProperties] -- ^ 'responseTimeFilterFastLocationProperties' 
  -> ResponseTimeFilterFastLocation
mkResponseTimeFilterFastLocation responseTimeFilterFastLocationId responseTimeFilterFastLocationProperties =
  ResponseTimeFilterFastLocation
  { responseTimeFilterFastLocationId
  , responseTimeFilterFastLocationProperties
  }

-- ** ResponseTimeFilterFastProperties
-- | ResponseTimeFilterFastProperties
data ResponseTimeFilterFastProperties = ResponseTimeFilterFastProperties
  { responseTimeFilterFastPropertiesTravelTime :: !(Maybe Int) -- ^ "travel_time"
  , responseTimeFilterFastPropertiesFares :: !(Maybe ResponseFaresFast) -- ^ "fares"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResponseTimeFilterFastProperties
instance A.FromJSON ResponseTimeFilterFastProperties where
  parseJSON = A.withObject "ResponseTimeFilterFastProperties" $ \o ->
    ResponseTimeFilterFastProperties
      <$> (o .:? "travel_time")
      <*> (o .:? "fares")

-- | ToJSON ResponseTimeFilterFastProperties
instance A.ToJSON ResponseTimeFilterFastProperties where
  toJSON ResponseTimeFilterFastProperties {..} =
   _omitNulls
      [ "travel_time" .= responseTimeFilterFastPropertiesTravelTime
      , "fares" .= responseTimeFilterFastPropertiesFares
      ]


-- | Construct a value of type 'ResponseTimeFilterFastProperties' (by applying it's required fields, if any)
mkResponseTimeFilterFastProperties
  :: ResponseTimeFilterFastProperties
mkResponseTimeFilterFastProperties =
  ResponseTimeFilterFastProperties
  { responseTimeFilterFastPropertiesTravelTime = Nothing
  , responseTimeFilterFastPropertiesFares = Nothing
  }

-- ** ResponseTimeFilterFastResult
-- | ResponseTimeFilterFastResult
data ResponseTimeFilterFastResult = ResponseTimeFilterFastResult
  { responseTimeFilterFastResultSearchId :: !(Text) -- ^ /Required/ "search_id"
  , responseTimeFilterFastResultLocations :: !([ResponseTimeFilterFastLocation]) -- ^ /Required/ "locations"
  , responseTimeFilterFastResultUnreachable :: !([Text]) -- ^ /Required/ "unreachable"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResponseTimeFilterFastResult
instance A.FromJSON ResponseTimeFilterFastResult where
  parseJSON = A.withObject "ResponseTimeFilterFastResult" $ \o ->
    ResponseTimeFilterFastResult
      <$> (o .:  "search_id")
      <*> (o .:  "locations")
      <*> (o .:  "unreachable")

-- | ToJSON ResponseTimeFilterFastResult
instance A.ToJSON ResponseTimeFilterFastResult where
  toJSON ResponseTimeFilterFastResult {..} =
   _omitNulls
      [ "search_id" .= responseTimeFilterFastResultSearchId
      , "locations" .= responseTimeFilterFastResultLocations
      , "unreachable" .= responseTimeFilterFastResultUnreachable
      ]


-- | Construct a value of type 'ResponseTimeFilterFastResult' (by applying it's required fields, if any)
mkResponseTimeFilterFastResult
  :: Text -- ^ 'responseTimeFilterFastResultSearchId' 
  -> [ResponseTimeFilterFastLocation] -- ^ 'responseTimeFilterFastResultLocations' 
  -> [Text] -- ^ 'responseTimeFilterFastResultUnreachable' 
  -> ResponseTimeFilterFastResult
mkResponseTimeFilterFastResult responseTimeFilterFastResultSearchId responseTimeFilterFastResultLocations responseTimeFilterFastResultUnreachable =
  ResponseTimeFilterFastResult
  { responseTimeFilterFastResultSearchId
  , responseTimeFilterFastResultLocations
  , responseTimeFilterFastResultUnreachable
  }

-- ** ResponseTimeFilterLocation
-- | ResponseTimeFilterLocation
data ResponseTimeFilterLocation = ResponseTimeFilterLocation
  { responseTimeFilterLocationId :: !(Text) -- ^ /Required/ "id"
  , responseTimeFilterLocationProperties :: !([ResponseTimeFilterProperties]) -- ^ /Required/ "properties"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResponseTimeFilterLocation
instance A.FromJSON ResponseTimeFilterLocation where
  parseJSON = A.withObject "ResponseTimeFilterLocation" $ \o ->
    ResponseTimeFilterLocation
      <$> (o .:  "id")
      <*> (o .:  "properties")

-- | ToJSON ResponseTimeFilterLocation
instance A.ToJSON ResponseTimeFilterLocation where
  toJSON ResponseTimeFilterLocation {..} =
   _omitNulls
      [ "id" .= responseTimeFilterLocationId
      , "properties" .= responseTimeFilterLocationProperties
      ]


-- | Construct a value of type 'ResponseTimeFilterLocation' (by applying it's required fields, if any)
mkResponseTimeFilterLocation
  :: Text -- ^ 'responseTimeFilterLocationId' 
  -> [ResponseTimeFilterProperties] -- ^ 'responseTimeFilterLocationProperties' 
  -> ResponseTimeFilterLocation
mkResponseTimeFilterLocation responseTimeFilterLocationId responseTimeFilterLocationProperties =
  ResponseTimeFilterLocation
  { responseTimeFilterLocationId
  , responseTimeFilterLocationProperties
  }

-- ** ResponseTimeFilterPostcode
-- | ResponseTimeFilterPostcode
data ResponseTimeFilterPostcode = ResponseTimeFilterPostcode
  { responseTimeFilterPostcodeCode :: !(Text) -- ^ /Required/ "code"
  , responseTimeFilterPostcodeProperties :: !([ResponseTimeFilterPostcodesProperties]) -- ^ /Required/ "properties"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResponseTimeFilterPostcode
instance A.FromJSON ResponseTimeFilterPostcode where
  parseJSON = A.withObject "ResponseTimeFilterPostcode" $ \o ->
    ResponseTimeFilterPostcode
      <$> (o .:  "code")
      <*> (o .:  "properties")

-- | ToJSON ResponseTimeFilterPostcode
instance A.ToJSON ResponseTimeFilterPostcode where
  toJSON ResponseTimeFilterPostcode {..} =
   _omitNulls
      [ "code" .= responseTimeFilterPostcodeCode
      , "properties" .= responseTimeFilterPostcodeProperties
      ]


-- | Construct a value of type 'ResponseTimeFilterPostcode' (by applying it's required fields, if any)
mkResponseTimeFilterPostcode
  :: Text -- ^ 'responseTimeFilterPostcodeCode' 
  -> [ResponseTimeFilterPostcodesProperties] -- ^ 'responseTimeFilterPostcodeProperties' 
  -> ResponseTimeFilterPostcode
mkResponseTimeFilterPostcode responseTimeFilterPostcodeCode responseTimeFilterPostcodeProperties =
  ResponseTimeFilterPostcode
  { responseTimeFilterPostcodeCode
  , responseTimeFilterPostcodeProperties
  }

-- ** ResponseTimeFilterPostcodeDistrict
-- | ResponseTimeFilterPostcodeDistrict
data ResponseTimeFilterPostcodeDistrict = ResponseTimeFilterPostcodeDistrict
  { responseTimeFilterPostcodeDistrictCode :: !(Text) -- ^ /Required/ "code"
  , responseTimeFilterPostcodeDistrictProperties :: !(ResponseTimeFilterPostcodeDistrictProperties) -- ^ /Required/ "properties"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResponseTimeFilterPostcodeDistrict
instance A.FromJSON ResponseTimeFilterPostcodeDistrict where
  parseJSON = A.withObject "ResponseTimeFilterPostcodeDistrict" $ \o ->
    ResponseTimeFilterPostcodeDistrict
      <$> (o .:  "code")
      <*> (o .:  "properties")

-- | ToJSON ResponseTimeFilterPostcodeDistrict
instance A.ToJSON ResponseTimeFilterPostcodeDistrict where
  toJSON ResponseTimeFilterPostcodeDistrict {..} =
   _omitNulls
      [ "code" .= responseTimeFilterPostcodeDistrictCode
      , "properties" .= responseTimeFilterPostcodeDistrictProperties
      ]


-- | Construct a value of type 'ResponseTimeFilterPostcodeDistrict' (by applying it's required fields, if any)
mkResponseTimeFilterPostcodeDistrict
  :: Text -- ^ 'responseTimeFilterPostcodeDistrictCode' 
  -> ResponseTimeFilterPostcodeDistrictProperties -- ^ 'responseTimeFilterPostcodeDistrictProperties' 
  -> ResponseTimeFilterPostcodeDistrict
mkResponseTimeFilterPostcodeDistrict responseTimeFilterPostcodeDistrictCode responseTimeFilterPostcodeDistrictProperties =
  ResponseTimeFilterPostcodeDistrict
  { responseTimeFilterPostcodeDistrictCode
  , responseTimeFilterPostcodeDistrictProperties
  }

-- ** ResponseTimeFilterPostcodeDistrictProperties
-- | ResponseTimeFilterPostcodeDistrictProperties
data ResponseTimeFilterPostcodeDistrictProperties = ResponseTimeFilterPostcodeDistrictProperties
  { responseTimeFilterPostcodeDistrictPropertiesTravelTimeReachable :: !(Maybe ResponseTravelTimeStatistics) -- ^ "travel_time_reachable"
  , responseTimeFilterPostcodeDistrictPropertiesTravelTimeAll :: !(Maybe ResponseTravelTimeStatistics) -- ^ "travel_time_all"
  , responseTimeFilterPostcodeDistrictPropertiesCoverage :: !(Maybe Double) -- ^ "coverage"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResponseTimeFilterPostcodeDistrictProperties
instance A.FromJSON ResponseTimeFilterPostcodeDistrictProperties where
  parseJSON = A.withObject "ResponseTimeFilterPostcodeDistrictProperties" $ \o ->
    ResponseTimeFilterPostcodeDistrictProperties
      <$> (o .:? "travel_time_reachable")
      <*> (o .:? "travel_time_all")
      <*> (o .:? "coverage")

-- | ToJSON ResponseTimeFilterPostcodeDistrictProperties
instance A.ToJSON ResponseTimeFilterPostcodeDistrictProperties where
  toJSON ResponseTimeFilterPostcodeDistrictProperties {..} =
   _omitNulls
      [ "travel_time_reachable" .= responseTimeFilterPostcodeDistrictPropertiesTravelTimeReachable
      , "travel_time_all" .= responseTimeFilterPostcodeDistrictPropertiesTravelTimeAll
      , "coverage" .= responseTimeFilterPostcodeDistrictPropertiesCoverage
      ]


-- | Construct a value of type 'ResponseTimeFilterPostcodeDistrictProperties' (by applying it's required fields, if any)
mkResponseTimeFilterPostcodeDistrictProperties
  :: ResponseTimeFilterPostcodeDistrictProperties
mkResponseTimeFilterPostcodeDistrictProperties =
  ResponseTimeFilterPostcodeDistrictProperties
  { responseTimeFilterPostcodeDistrictPropertiesTravelTimeReachable = Nothing
  , responseTimeFilterPostcodeDistrictPropertiesTravelTimeAll = Nothing
  , responseTimeFilterPostcodeDistrictPropertiesCoverage = Nothing
  }

-- ** ResponseTimeFilterPostcodeDistricts
-- | ResponseTimeFilterPostcodeDistricts
data ResponseTimeFilterPostcodeDistricts = ResponseTimeFilterPostcodeDistricts
  { responseTimeFilterPostcodeDistrictsResults :: !([ResponseTimeFilterPostcodeDistrictsResult]) -- ^ /Required/ "results"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResponseTimeFilterPostcodeDistricts
instance A.FromJSON ResponseTimeFilterPostcodeDistricts where
  parseJSON = A.withObject "ResponseTimeFilterPostcodeDistricts" $ \o ->
    ResponseTimeFilterPostcodeDistricts
      <$> (o .:  "results")

-- | ToJSON ResponseTimeFilterPostcodeDistricts
instance A.ToJSON ResponseTimeFilterPostcodeDistricts where
  toJSON ResponseTimeFilterPostcodeDistricts {..} =
   _omitNulls
      [ "results" .= responseTimeFilterPostcodeDistrictsResults
      ]


-- | Construct a value of type 'ResponseTimeFilterPostcodeDistricts' (by applying it's required fields, if any)
mkResponseTimeFilterPostcodeDistricts
  :: [ResponseTimeFilterPostcodeDistrictsResult] -- ^ 'responseTimeFilterPostcodeDistrictsResults' 
  -> ResponseTimeFilterPostcodeDistricts
mkResponseTimeFilterPostcodeDistricts responseTimeFilterPostcodeDistrictsResults =
  ResponseTimeFilterPostcodeDistricts
  { responseTimeFilterPostcodeDistrictsResults
  }

-- ** ResponseTimeFilterPostcodeDistrictsResult
-- | ResponseTimeFilterPostcodeDistrictsResult
data ResponseTimeFilterPostcodeDistrictsResult = ResponseTimeFilterPostcodeDistrictsResult
  { responseTimeFilterPostcodeDistrictsResultSearchId :: !(Text) -- ^ /Required/ "search_id"
  , responseTimeFilterPostcodeDistrictsResultDistricts :: !([ResponseTimeFilterPostcodeDistrict]) -- ^ /Required/ "districts"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResponseTimeFilterPostcodeDistrictsResult
instance A.FromJSON ResponseTimeFilterPostcodeDistrictsResult where
  parseJSON = A.withObject "ResponseTimeFilterPostcodeDistrictsResult" $ \o ->
    ResponseTimeFilterPostcodeDistrictsResult
      <$> (o .:  "search_id")
      <*> (o .:  "districts")

-- | ToJSON ResponseTimeFilterPostcodeDistrictsResult
instance A.ToJSON ResponseTimeFilterPostcodeDistrictsResult where
  toJSON ResponseTimeFilterPostcodeDistrictsResult {..} =
   _omitNulls
      [ "search_id" .= responseTimeFilterPostcodeDistrictsResultSearchId
      , "districts" .= responseTimeFilterPostcodeDistrictsResultDistricts
      ]


-- | Construct a value of type 'ResponseTimeFilterPostcodeDistrictsResult' (by applying it's required fields, if any)
mkResponseTimeFilterPostcodeDistrictsResult
  :: Text -- ^ 'responseTimeFilterPostcodeDistrictsResultSearchId' 
  -> [ResponseTimeFilterPostcodeDistrict] -- ^ 'responseTimeFilterPostcodeDistrictsResultDistricts' 
  -> ResponseTimeFilterPostcodeDistrictsResult
mkResponseTimeFilterPostcodeDistrictsResult responseTimeFilterPostcodeDistrictsResultSearchId responseTimeFilterPostcodeDistrictsResultDistricts =
  ResponseTimeFilterPostcodeDistrictsResult
  { responseTimeFilterPostcodeDistrictsResultSearchId
  , responseTimeFilterPostcodeDistrictsResultDistricts
  }

-- ** ResponseTimeFilterPostcodeSector
-- | ResponseTimeFilterPostcodeSector
data ResponseTimeFilterPostcodeSector = ResponseTimeFilterPostcodeSector
  { responseTimeFilterPostcodeSectorCode :: !(Text) -- ^ /Required/ "code"
  , responseTimeFilterPostcodeSectorProperties :: !(ResponseTimeFilterPostcodeSectorProperties) -- ^ /Required/ "properties"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResponseTimeFilterPostcodeSector
instance A.FromJSON ResponseTimeFilterPostcodeSector where
  parseJSON = A.withObject "ResponseTimeFilterPostcodeSector" $ \o ->
    ResponseTimeFilterPostcodeSector
      <$> (o .:  "code")
      <*> (o .:  "properties")

-- | ToJSON ResponseTimeFilterPostcodeSector
instance A.ToJSON ResponseTimeFilterPostcodeSector where
  toJSON ResponseTimeFilterPostcodeSector {..} =
   _omitNulls
      [ "code" .= responseTimeFilterPostcodeSectorCode
      , "properties" .= responseTimeFilterPostcodeSectorProperties
      ]


-- | Construct a value of type 'ResponseTimeFilterPostcodeSector' (by applying it's required fields, if any)
mkResponseTimeFilterPostcodeSector
  :: Text -- ^ 'responseTimeFilterPostcodeSectorCode' 
  -> ResponseTimeFilterPostcodeSectorProperties -- ^ 'responseTimeFilterPostcodeSectorProperties' 
  -> ResponseTimeFilterPostcodeSector
mkResponseTimeFilterPostcodeSector responseTimeFilterPostcodeSectorCode responseTimeFilterPostcodeSectorProperties =
  ResponseTimeFilterPostcodeSector
  { responseTimeFilterPostcodeSectorCode
  , responseTimeFilterPostcodeSectorProperties
  }

-- ** ResponseTimeFilterPostcodeSectorProperties
-- | ResponseTimeFilterPostcodeSectorProperties
data ResponseTimeFilterPostcodeSectorProperties = ResponseTimeFilterPostcodeSectorProperties
  { responseTimeFilterPostcodeSectorPropertiesTravelTimeReachable :: !(Maybe ResponseTravelTimeStatistics) -- ^ "travel_time_reachable"
  , responseTimeFilterPostcodeSectorPropertiesTravelTimeAll :: !(Maybe ResponseTravelTimeStatistics) -- ^ "travel_time_all"
  , responseTimeFilterPostcodeSectorPropertiesCoverage :: !(Maybe Double) -- ^ "coverage"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResponseTimeFilterPostcodeSectorProperties
instance A.FromJSON ResponseTimeFilterPostcodeSectorProperties where
  parseJSON = A.withObject "ResponseTimeFilterPostcodeSectorProperties" $ \o ->
    ResponseTimeFilterPostcodeSectorProperties
      <$> (o .:? "travel_time_reachable")
      <*> (o .:? "travel_time_all")
      <*> (o .:? "coverage")

-- | ToJSON ResponseTimeFilterPostcodeSectorProperties
instance A.ToJSON ResponseTimeFilterPostcodeSectorProperties where
  toJSON ResponseTimeFilterPostcodeSectorProperties {..} =
   _omitNulls
      [ "travel_time_reachable" .= responseTimeFilterPostcodeSectorPropertiesTravelTimeReachable
      , "travel_time_all" .= responseTimeFilterPostcodeSectorPropertiesTravelTimeAll
      , "coverage" .= responseTimeFilterPostcodeSectorPropertiesCoverage
      ]


-- | Construct a value of type 'ResponseTimeFilterPostcodeSectorProperties' (by applying it's required fields, if any)
mkResponseTimeFilterPostcodeSectorProperties
  :: ResponseTimeFilterPostcodeSectorProperties
mkResponseTimeFilterPostcodeSectorProperties =
  ResponseTimeFilterPostcodeSectorProperties
  { responseTimeFilterPostcodeSectorPropertiesTravelTimeReachable = Nothing
  , responseTimeFilterPostcodeSectorPropertiesTravelTimeAll = Nothing
  , responseTimeFilterPostcodeSectorPropertiesCoverage = Nothing
  }

-- ** ResponseTimeFilterPostcodeSectors
-- | ResponseTimeFilterPostcodeSectors
data ResponseTimeFilterPostcodeSectors = ResponseTimeFilterPostcodeSectors
  { responseTimeFilterPostcodeSectorsResults :: !([ResponseTimeFilterPostcodeSectorsResult]) -- ^ /Required/ "results"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResponseTimeFilterPostcodeSectors
instance A.FromJSON ResponseTimeFilterPostcodeSectors where
  parseJSON = A.withObject "ResponseTimeFilterPostcodeSectors" $ \o ->
    ResponseTimeFilterPostcodeSectors
      <$> (o .:  "results")

-- | ToJSON ResponseTimeFilterPostcodeSectors
instance A.ToJSON ResponseTimeFilterPostcodeSectors where
  toJSON ResponseTimeFilterPostcodeSectors {..} =
   _omitNulls
      [ "results" .= responseTimeFilterPostcodeSectorsResults
      ]


-- | Construct a value of type 'ResponseTimeFilterPostcodeSectors' (by applying it's required fields, if any)
mkResponseTimeFilterPostcodeSectors
  :: [ResponseTimeFilterPostcodeSectorsResult] -- ^ 'responseTimeFilterPostcodeSectorsResults' 
  -> ResponseTimeFilterPostcodeSectors
mkResponseTimeFilterPostcodeSectors responseTimeFilterPostcodeSectorsResults =
  ResponseTimeFilterPostcodeSectors
  { responseTimeFilterPostcodeSectorsResults
  }

-- ** ResponseTimeFilterPostcodeSectorsResult
-- | ResponseTimeFilterPostcodeSectorsResult
data ResponseTimeFilterPostcodeSectorsResult = ResponseTimeFilterPostcodeSectorsResult
  { responseTimeFilterPostcodeSectorsResultSearchId :: !(Text) -- ^ /Required/ "search_id"
  , responseTimeFilterPostcodeSectorsResultSectors :: !([ResponseTimeFilterPostcodeSector]) -- ^ /Required/ "sectors"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResponseTimeFilterPostcodeSectorsResult
instance A.FromJSON ResponseTimeFilterPostcodeSectorsResult where
  parseJSON = A.withObject "ResponseTimeFilterPostcodeSectorsResult" $ \o ->
    ResponseTimeFilterPostcodeSectorsResult
      <$> (o .:  "search_id")
      <*> (o .:  "sectors")

-- | ToJSON ResponseTimeFilterPostcodeSectorsResult
instance A.ToJSON ResponseTimeFilterPostcodeSectorsResult where
  toJSON ResponseTimeFilterPostcodeSectorsResult {..} =
   _omitNulls
      [ "search_id" .= responseTimeFilterPostcodeSectorsResultSearchId
      , "sectors" .= responseTimeFilterPostcodeSectorsResultSectors
      ]


-- | Construct a value of type 'ResponseTimeFilterPostcodeSectorsResult' (by applying it's required fields, if any)
mkResponseTimeFilterPostcodeSectorsResult
  :: Text -- ^ 'responseTimeFilterPostcodeSectorsResultSearchId' 
  -> [ResponseTimeFilterPostcodeSector] -- ^ 'responseTimeFilterPostcodeSectorsResultSectors' 
  -> ResponseTimeFilterPostcodeSectorsResult
mkResponseTimeFilterPostcodeSectorsResult responseTimeFilterPostcodeSectorsResultSearchId responseTimeFilterPostcodeSectorsResultSectors =
  ResponseTimeFilterPostcodeSectorsResult
  { responseTimeFilterPostcodeSectorsResultSearchId
  , responseTimeFilterPostcodeSectorsResultSectors
  }

-- ** ResponseTimeFilterPostcodes
-- | ResponseTimeFilterPostcodes
data ResponseTimeFilterPostcodes = ResponseTimeFilterPostcodes
  { responseTimeFilterPostcodesResults :: !([ResponseTimeFilterPostcodesResult]) -- ^ /Required/ "results"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResponseTimeFilterPostcodes
instance A.FromJSON ResponseTimeFilterPostcodes where
  parseJSON = A.withObject "ResponseTimeFilterPostcodes" $ \o ->
    ResponseTimeFilterPostcodes
      <$> (o .:  "results")

-- | ToJSON ResponseTimeFilterPostcodes
instance A.ToJSON ResponseTimeFilterPostcodes where
  toJSON ResponseTimeFilterPostcodes {..} =
   _omitNulls
      [ "results" .= responseTimeFilterPostcodesResults
      ]


-- | Construct a value of type 'ResponseTimeFilterPostcodes' (by applying it's required fields, if any)
mkResponseTimeFilterPostcodes
  :: [ResponseTimeFilterPostcodesResult] -- ^ 'responseTimeFilterPostcodesResults' 
  -> ResponseTimeFilterPostcodes
mkResponseTimeFilterPostcodes responseTimeFilterPostcodesResults =
  ResponseTimeFilterPostcodes
  { responseTimeFilterPostcodesResults
  }

-- ** ResponseTimeFilterPostcodesProperties
-- | ResponseTimeFilterPostcodesProperties
data ResponseTimeFilterPostcodesProperties = ResponseTimeFilterPostcodesProperties
  { responseTimeFilterPostcodesPropertiesTravelTime :: !(Maybe Int) -- ^ "travel_time"
  , responseTimeFilterPostcodesPropertiesDistance :: !(Maybe Int) -- ^ "distance"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResponseTimeFilterPostcodesProperties
instance A.FromJSON ResponseTimeFilterPostcodesProperties where
  parseJSON = A.withObject "ResponseTimeFilterPostcodesProperties" $ \o ->
    ResponseTimeFilterPostcodesProperties
      <$> (o .:? "travel_time")
      <*> (o .:? "distance")

-- | ToJSON ResponseTimeFilterPostcodesProperties
instance A.ToJSON ResponseTimeFilterPostcodesProperties where
  toJSON ResponseTimeFilterPostcodesProperties {..} =
   _omitNulls
      [ "travel_time" .= responseTimeFilterPostcodesPropertiesTravelTime
      , "distance" .= responseTimeFilterPostcodesPropertiesDistance
      ]


-- | Construct a value of type 'ResponseTimeFilterPostcodesProperties' (by applying it's required fields, if any)
mkResponseTimeFilterPostcodesProperties
  :: ResponseTimeFilterPostcodesProperties
mkResponseTimeFilterPostcodesProperties =
  ResponseTimeFilterPostcodesProperties
  { responseTimeFilterPostcodesPropertiesTravelTime = Nothing
  , responseTimeFilterPostcodesPropertiesDistance = Nothing
  }

-- ** ResponseTimeFilterPostcodesResult
-- | ResponseTimeFilterPostcodesResult
data ResponseTimeFilterPostcodesResult = ResponseTimeFilterPostcodesResult
  { responseTimeFilterPostcodesResultSearchId :: !(Text) -- ^ /Required/ "search_id"
  , responseTimeFilterPostcodesResultPostcodes :: !([ResponseTimeFilterPostcode]) -- ^ /Required/ "postcodes"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResponseTimeFilterPostcodesResult
instance A.FromJSON ResponseTimeFilterPostcodesResult where
  parseJSON = A.withObject "ResponseTimeFilterPostcodesResult" $ \o ->
    ResponseTimeFilterPostcodesResult
      <$> (o .:  "search_id")
      <*> (o .:  "postcodes")

-- | ToJSON ResponseTimeFilterPostcodesResult
instance A.ToJSON ResponseTimeFilterPostcodesResult where
  toJSON ResponseTimeFilterPostcodesResult {..} =
   _omitNulls
      [ "search_id" .= responseTimeFilterPostcodesResultSearchId
      , "postcodes" .= responseTimeFilterPostcodesResultPostcodes
      ]


-- | Construct a value of type 'ResponseTimeFilterPostcodesResult' (by applying it's required fields, if any)
mkResponseTimeFilterPostcodesResult
  :: Text -- ^ 'responseTimeFilterPostcodesResultSearchId' 
  -> [ResponseTimeFilterPostcode] -- ^ 'responseTimeFilterPostcodesResultPostcodes' 
  -> ResponseTimeFilterPostcodesResult
mkResponseTimeFilterPostcodesResult responseTimeFilterPostcodesResultSearchId responseTimeFilterPostcodesResultPostcodes =
  ResponseTimeFilterPostcodesResult
  { responseTimeFilterPostcodesResultSearchId
  , responseTimeFilterPostcodesResultPostcodes
  }

-- ** ResponseTimeFilterProperties
-- | ResponseTimeFilterProperties
data ResponseTimeFilterProperties = ResponseTimeFilterProperties
  { responseTimeFilterPropertiesTravelTime :: !(Maybe Int) -- ^ "travel_time"
  , responseTimeFilterPropertiesDistance :: !(Maybe Int) -- ^ "distance"
  , responseTimeFilterPropertiesDistanceBreakdown :: !(Maybe [ResponseDistanceBreakdownItem]) -- ^ "distance_breakdown"
  , responseTimeFilterPropertiesFares :: !(Maybe ResponseFares) -- ^ "fares"
  , responseTimeFilterPropertiesRoute :: !(Maybe ResponseRoute) -- ^ "route"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResponseTimeFilterProperties
instance A.FromJSON ResponseTimeFilterProperties where
  parseJSON = A.withObject "ResponseTimeFilterProperties" $ \o ->
    ResponseTimeFilterProperties
      <$> (o .:? "travel_time")
      <*> (o .:? "distance")
      <*> (o .:? "distance_breakdown")
      <*> (o .:? "fares")
      <*> (o .:? "route")

-- | ToJSON ResponseTimeFilterProperties
instance A.ToJSON ResponseTimeFilterProperties where
  toJSON ResponseTimeFilterProperties {..} =
   _omitNulls
      [ "travel_time" .= responseTimeFilterPropertiesTravelTime
      , "distance" .= responseTimeFilterPropertiesDistance
      , "distance_breakdown" .= responseTimeFilterPropertiesDistanceBreakdown
      , "fares" .= responseTimeFilterPropertiesFares
      , "route" .= responseTimeFilterPropertiesRoute
      ]


-- | Construct a value of type 'ResponseTimeFilterProperties' (by applying it's required fields, if any)
mkResponseTimeFilterProperties
  :: ResponseTimeFilterProperties
mkResponseTimeFilterProperties =
  ResponseTimeFilterProperties
  { responseTimeFilterPropertiesTravelTime = Nothing
  , responseTimeFilterPropertiesDistance = Nothing
  , responseTimeFilterPropertiesDistanceBreakdown = Nothing
  , responseTimeFilterPropertiesFares = Nothing
  , responseTimeFilterPropertiesRoute = Nothing
  }

-- ** ResponseTimeFilterResult
-- | ResponseTimeFilterResult
data ResponseTimeFilterResult = ResponseTimeFilterResult
  { responseTimeFilterResultSearchId :: !(Text) -- ^ /Required/ "search_id"
  , responseTimeFilterResultLocations :: !([ResponseTimeFilterLocation]) -- ^ /Required/ "locations"
  , responseTimeFilterResultUnreachable :: !([Text]) -- ^ /Required/ "unreachable"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResponseTimeFilterResult
instance A.FromJSON ResponseTimeFilterResult where
  parseJSON = A.withObject "ResponseTimeFilterResult" $ \o ->
    ResponseTimeFilterResult
      <$> (o .:  "search_id")
      <*> (o .:  "locations")
      <*> (o .:  "unreachable")

-- | ToJSON ResponseTimeFilterResult
instance A.ToJSON ResponseTimeFilterResult where
  toJSON ResponseTimeFilterResult {..} =
   _omitNulls
      [ "search_id" .= responseTimeFilterResultSearchId
      , "locations" .= responseTimeFilterResultLocations
      , "unreachable" .= responseTimeFilterResultUnreachable
      ]


-- | Construct a value of type 'ResponseTimeFilterResult' (by applying it's required fields, if any)
mkResponseTimeFilterResult
  :: Text -- ^ 'responseTimeFilterResultSearchId' 
  -> [ResponseTimeFilterLocation] -- ^ 'responseTimeFilterResultLocations' 
  -> [Text] -- ^ 'responseTimeFilterResultUnreachable' 
  -> ResponseTimeFilterResult
mkResponseTimeFilterResult responseTimeFilterResultSearchId responseTimeFilterResultLocations responseTimeFilterResultUnreachable =
  ResponseTimeFilterResult
  { responseTimeFilterResultSearchId
  , responseTimeFilterResultLocations
  , responseTimeFilterResultUnreachable
  }

-- ** ResponseTimeMap
-- | ResponseTimeMap
data ResponseTimeMap = ResponseTimeMap
  { responseTimeMapResults :: !([ResponseTimeMapResult]) -- ^ /Required/ "results"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResponseTimeMap
instance A.FromJSON ResponseTimeMap where
  parseJSON = A.withObject "ResponseTimeMap" $ \o ->
    ResponseTimeMap
      <$> (o .:  "results")

-- | ToJSON ResponseTimeMap
instance A.ToJSON ResponseTimeMap where
  toJSON ResponseTimeMap {..} =
   _omitNulls
      [ "results" .= responseTimeMapResults
      ]


-- | Construct a value of type 'ResponseTimeMap' (by applying it's required fields, if any)
mkResponseTimeMap
  :: [ResponseTimeMapResult] -- ^ 'responseTimeMapResults' 
  -> ResponseTimeMap
mkResponseTimeMap responseTimeMapResults =
  ResponseTimeMap
  { responseTimeMapResults
  }

-- ** ResponseTimeMapBoundingBoxes
-- | ResponseTimeMapBoundingBoxes
data ResponseTimeMapBoundingBoxes = ResponseTimeMapBoundingBoxes
  { responseTimeMapBoundingBoxesResults :: !([ResponseTimeMapBoundingBoxesResult]) -- ^ /Required/ "results"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResponseTimeMapBoundingBoxes
instance A.FromJSON ResponseTimeMapBoundingBoxes where
  parseJSON = A.withObject "ResponseTimeMapBoundingBoxes" $ \o ->
    ResponseTimeMapBoundingBoxes
      <$> (o .:  "results")

-- | ToJSON ResponseTimeMapBoundingBoxes
instance A.ToJSON ResponseTimeMapBoundingBoxes where
  toJSON ResponseTimeMapBoundingBoxes {..} =
   _omitNulls
      [ "results" .= responseTimeMapBoundingBoxesResults
      ]


-- | Construct a value of type 'ResponseTimeMapBoundingBoxes' (by applying it's required fields, if any)
mkResponseTimeMapBoundingBoxes
  :: [ResponseTimeMapBoundingBoxesResult] -- ^ 'responseTimeMapBoundingBoxesResults' 
  -> ResponseTimeMapBoundingBoxes
mkResponseTimeMapBoundingBoxes responseTimeMapBoundingBoxesResults =
  ResponseTimeMapBoundingBoxes
  { responseTimeMapBoundingBoxesResults
  }

-- ** ResponseTimeMapBoundingBoxesResult
-- | ResponseTimeMapBoundingBoxesResult
data ResponseTimeMapBoundingBoxesResult = ResponseTimeMapBoundingBoxesResult
  { responseTimeMapBoundingBoxesResultSearchId :: !(Text) -- ^ /Required/ "search_id"
  , responseTimeMapBoundingBoxesResultBoundingBoxes :: !([ResponseBoundingBox]) -- ^ /Required/ "bounding_boxes"
  , responseTimeMapBoundingBoxesResultProperties :: !(ResponseTimeMapProperties) -- ^ /Required/ "properties"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResponseTimeMapBoundingBoxesResult
instance A.FromJSON ResponseTimeMapBoundingBoxesResult where
  parseJSON = A.withObject "ResponseTimeMapBoundingBoxesResult" $ \o ->
    ResponseTimeMapBoundingBoxesResult
      <$> (o .:  "search_id")
      <*> (o .:  "bounding_boxes")
      <*> (o .:  "properties")

-- | ToJSON ResponseTimeMapBoundingBoxesResult
instance A.ToJSON ResponseTimeMapBoundingBoxesResult where
  toJSON ResponseTimeMapBoundingBoxesResult {..} =
   _omitNulls
      [ "search_id" .= responseTimeMapBoundingBoxesResultSearchId
      , "bounding_boxes" .= responseTimeMapBoundingBoxesResultBoundingBoxes
      , "properties" .= responseTimeMapBoundingBoxesResultProperties
      ]


-- | Construct a value of type 'ResponseTimeMapBoundingBoxesResult' (by applying it's required fields, if any)
mkResponseTimeMapBoundingBoxesResult
  :: Text -- ^ 'responseTimeMapBoundingBoxesResultSearchId' 
  -> [ResponseBoundingBox] -- ^ 'responseTimeMapBoundingBoxesResultBoundingBoxes' 
  -> ResponseTimeMapProperties -- ^ 'responseTimeMapBoundingBoxesResultProperties' 
  -> ResponseTimeMapBoundingBoxesResult
mkResponseTimeMapBoundingBoxesResult responseTimeMapBoundingBoxesResultSearchId responseTimeMapBoundingBoxesResultBoundingBoxes responseTimeMapBoundingBoxesResultProperties =
  ResponseTimeMapBoundingBoxesResult
  { responseTimeMapBoundingBoxesResultSearchId
  , responseTimeMapBoundingBoxesResultBoundingBoxes
  , responseTimeMapBoundingBoxesResultProperties
  }

-- ** ResponseTimeMapProperties
-- | ResponseTimeMapProperties
data ResponseTimeMapProperties = ResponseTimeMapProperties
  { responseTimeMapPropertiesIsOnlyWalking :: !(Maybe Bool) -- ^ "is_only_walking"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResponseTimeMapProperties
instance A.FromJSON ResponseTimeMapProperties where
  parseJSON = A.withObject "ResponseTimeMapProperties" $ \o ->
    ResponseTimeMapProperties
      <$> (o .:? "is_only_walking")

-- | ToJSON ResponseTimeMapProperties
instance A.ToJSON ResponseTimeMapProperties where
  toJSON ResponseTimeMapProperties {..} =
   _omitNulls
      [ "is_only_walking" .= responseTimeMapPropertiesIsOnlyWalking
      ]


-- | Construct a value of type 'ResponseTimeMapProperties' (by applying it's required fields, if any)
mkResponseTimeMapProperties
  :: ResponseTimeMapProperties
mkResponseTimeMapProperties =
  ResponseTimeMapProperties
  { responseTimeMapPropertiesIsOnlyWalking = Nothing
  }

-- ** ResponseTimeMapResult
-- | ResponseTimeMapResult
data ResponseTimeMapResult = ResponseTimeMapResult
  { responseTimeMapResultSearchId :: !(Text) -- ^ /Required/ "search_id"
  , responseTimeMapResultShapes :: !([ResponseShape]) -- ^ /Required/ "shapes"
  , responseTimeMapResultProperties :: !(ResponseTimeMapProperties) -- ^ /Required/ "properties"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResponseTimeMapResult
instance A.FromJSON ResponseTimeMapResult where
  parseJSON = A.withObject "ResponseTimeMapResult" $ \o ->
    ResponseTimeMapResult
      <$> (o .:  "search_id")
      <*> (o .:  "shapes")
      <*> (o .:  "properties")

-- | ToJSON ResponseTimeMapResult
instance A.ToJSON ResponseTimeMapResult where
  toJSON ResponseTimeMapResult {..} =
   _omitNulls
      [ "search_id" .= responseTimeMapResultSearchId
      , "shapes" .= responseTimeMapResultShapes
      , "properties" .= responseTimeMapResultProperties
      ]


-- | Construct a value of type 'ResponseTimeMapResult' (by applying it's required fields, if any)
mkResponseTimeMapResult
  :: Text -- ^ 'responseTimeMapResultSearchId' 
  -> [ResponseShape] -- ^ 'responseTimeMapResultShapes' 
  -> ResponseTimeMapProperties -- ^ 'responseTimeMapResultProperties' 
  -> ResponseTimeMapResult
mkResponseTimeMapResult responseTimeMapResultSearchId responseTimeMapResultShapes responseTimeMapResultProperties =
  ResponseTimeMapResult
  { responseTimeMapResultSearchId
  , responseTimeMapResultShapes
  , responseTimeMapResultProperties
  }

-- ** ResponseTimeMapWkt
-- | ResponseTimeMapWkt
data ResponseTimeMapWkt = ResponseTimeMapWkt
  { responseTimeMapWktResults :: !([ResponseTimeMapWktResult]) -- ^ /Required/ "results"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResponseTimeMapWkt
instance A.FromJSON ResponseTimeMapWkt where
  parseJSON = A.withObject "ResponseTimeMapWkt" $ \o ->
    ResponseTimeMapWkt
      <$> (o .:  "results")

-- | ToJSON ResponseTimeMapWkt
instance A.ToJSON ResponseTimeMapWkt where
  toJSON ResponseTimeMapWkt {..} =
   _omitNulls
      [ "results" .= responseTimeMapWktResults
      ]


-- | Construct a value of type 'ResponseTimeMapWkt' (by applying it's required fields, if any)
mkResponseTimeMapWkt
  :: [ResponseTimeMapWktResult] -- ^ 'responseTimeMapWktResults' 
  -> ResponseTimeMapWkt
mkResponseTimeMapWkt responseTimeMapWktResults =
  ResponseTimeMapWkt
  { responseTimeMapWktResults
  }

-- ** ResponseTimeMapWktResult
-- | ResponseTimeMapWktResult
data ResponseTimeMapWktResult = ResponseTimeMapWktResult
  { responseTimeMapWktResultSearchId :: !(Text) -- ^ /Required/ "search_id"
  , responseTimeMapWktResultShape :: !(Text) -- ^ /Required/ "shape"
  , responseTimeMapWktResultProperties :: !(ResponseTimeMapProperties) -- ^ /Required/ "properties"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResponseTimeMapWktResult
instance A.FromJSON ResponseTimeMapWktResult where
  parseJSON = A.withObject "ResponseTimeMapWktResult" $ \o ->
    ResponseTimeMapWktResult
      <$> (o .:  "search_id")
      <*> (o .:  "shape")
      <*> (o .:  "properties")

-- | ToJSON ResponseTimeMapWktResult
instance A.ToJSON ResponseTimeMapWktResult where
  toJSON ResponseTimeMapWktResult {..} =
   _omitNulls
      [ "search_id" .= responseTimeMapWktResultSearchId
      , "shape" .= responseTimeMapWktResultShape
      , "properties" .= responseTimeMapWktResultProperties
      ]


-- | Construct a value of type 'ResponseTimeMapWktResult' (by applying it's required fields, if any)
mkResponseTimeMapWktResult
  :: Text -- ^ 'responseTimeMapWktResultSearchId' 
  -> Text -- ^ 'responseTimeMapWktResultShape' 
  -> ResponseTimeMapProperties -- ^ 'responseTimeMapWktResultProperties' 
  -> ResponseTimeMapWktResult
mkResponseTimeMapWktResult responseTimeMapWktResultSearchId responseTimeMapWktResultShape responseTimeMapWktResultProperties =
  ResponseTimeMapWktResult
  { responseTimeMapWktResultSearchId
  , responseTimeMapWktResultShape
  , responseTimeMapWktResultProperties
  }

-- ** ResponseTravelTimeStatistics
-- | ResponseTravelTimeStatistics
data ResponseTravelTimeStatistics = ResponseTravelTimeStatistics
  { responseTravelTimeStatisticsMin :: !(Int) -- ^ /Required/ "min"
  , responseTravelTimeStatisticsMax :: !(Int) -- ^ /Required/ "max"
  , responseTravelTimeStatisticsMean :: !(Int) -- ^ /Required/ "mean"
  , responseTravelTimeStatisticsMedian :: !(Int) -- ^ /Required/ "median"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ResponseTravelTimeStatistics
instance A.FromJSON ResponseTravelTimeStatistics where
  parseJSON = A.withObject "ResponseTravelTimeStatistics" $ \o ->
    ResponseTravelTimeStatistics
      <$> (o .:  "min")
      <*> (o .:  "max")
      <*> (o .:  "mean")
      <*> (o .:  "median")

-- | ToJSON ResponseTravelTimeStatistics
instance A.ToJSON ResponseTravelTimeStatistics where
  toJSON ResponseTravelTimeStatistics {..} =
   _omitNulls
      [ "min" .= responseTravelTimeStatisticsMin
      , "max" .= responseTravelTimeStatisticsMax
      , "mean" .= responseTravelTimeStatisticsMean
      , "median" .= responseTravelTimeStatisticsMedian
      ]


-- | Construct a value of type 'ResponseTravelTimeStatistics' (by applying it's required fields, if any)
mkResponseTravelTimeStatistics
  :: Int -- ^ 'responseTravelTimeStatisticsMin' 
  -> Int -- ^ 'responseTravelTimeStatisticsMax' 
  -> Int -- ^ 'responseTravelTimeStatisticsMean' 
  -> Int -- ^ 'responseTravelTimeStatisticsMedian' 
  -> ResponseTravelTimeStatistics
mkResponseTravelTimeStatistics responseTravelTimeStatisticsMin responseTravelTimeStatisticsMax responseTravelTimeStatisticsMean responseTravelTimeStatisticsMedian =
  ResponseTravelTimeStatistics
  { responseTravelTimeStatisticsMin
  , responseTravelTimeStatisticsMax
  , responseTravelTimeStatisticsMean
  , responseTravelTimeStatisticsMedian
  }


-- * Enums


-- ** E'Type

-- | Enum of 'Text'
data E'Type
  = E'Type'Public_transport -- ^ @"public_transport"@
  | E'Type'Driving -- ^ @"driving"@
  | E'Type'Drivingpublic_transport -- ^ @"driving+public_transport"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type where toJSON = A.toJSON . fromE'Type
instance A.FromJSON E'Type where parseJSON o = P.either P.fail (pure . P.id) . toE'Type =<< A.parseJSON o
instance WH.ToHttpApiData E'Type where toQueryParam = WH.toQueryParam . fromE'Type
instance WH.FromHttpApiData E'Type where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type
instance MimeRender MimeMultipartFormData E'Type where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type' enum
fromE'Type :: E'Type -> Text
fromE'Type = \case
  E'Type'Public_transport -> "public_transport"
  E'Type'Driving -> "driving"
  E'Type'Drivingpublic_transport -> "driving+public_transport"

-- | parse 'E'Type' enum
toE'Type :: Text -> P.Either String E'Type
toE'Type = \case
  "public_transport" -> P.Right E'Type'Public_transport
  "driving" -> P.Right E'Type'Driving
  "driving+public_transport" -> P.Right E'Type'Drivingpublic_transport
  s -> P.Left $ "toE'Type: enum parse failure: " P.++ P.show s


-- ** E'Type2

-- | Enum of 'Text'
data E'Type2
  = E'Type2'Single -- ^ @"single"@
  | E'Type2'Week -- ^ @"week"@
  | E'Type2'Month -- ^ @"month"@
  | E'Type2'Year -- ^ @"year"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type2 where toJSON = A.toJSON . fromE'Type2
instance A.FromJSON E'Type2 where parseJSON o = P.either P.fail (pure . P.id) . toE'Type2 =<< A.parseJSON o
instance WH.ToHttpApiData E'Type2 where toQueryParam = WH.toQueryParam . fromE'Type2
instance WH.FromHttpApiData E'Type2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type2
instance MimeRender MimeMultipartFormData E'Type2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type2' enum
fromE'Type2 :: E'Type2 -> Text
fromE'Type2 = \case
  E'Type2'Single -> "single"
  E'Type2'Week -> "week"
  E'Type2'Month -> "month"
  E'Type2'Year -> "year"

-- | parse 'E'Type2' enum
toE'Type2 :: Text -> P.Either String E'Type2
toE'Type2 = \case
  "single" -> P.Right E'Type2'Single
  "week" -> P.Right E'Type2'Week
  "month" -> P.Right E'Type2'Month
  "year" -> P.Right E'Type2'Year
  s -> P.Left $ "toE'Type2: enum parse failure: " P.++ P.show s


-- ** E'Type3

-- | Enum of 'Text'
data E'Type3
  = E'Type3'Basic -- ^ @"basic"@
  | E'Type3'Start_end -- ^ @"start_end"@
  | E'Type3'Road -- ^ @"road"@
  | E'Type3'Public_transport -- ^ @"public_transport"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type3 where toJSON = A.toJSON . fromE'Type3
instance A.FromJSON E'Type3 where parseJSON o = P.either P.fail (pure . P.id) . toE'Type3 =<< A.parseJSON o
instance WH.ToHttpApiData E'Type3 where toQueryParam = WH.toQueryParam . fromE'Type3
instance WH.FromHttpApiData E'Type3 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type3
instance MimeRender MimeMultipartFormData E'Type3 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type3' enum
fromE'Type3 :: E'Type3 -> Text
fromE'Type3 = \case
  E'Type3'Basic -> "basic"
  E'Type3'Start_end -> "start_end"
  E'Type3'Road -> "road"
  E'Type3'Public_transport -> "public_transport"

-- | parse 'E'Type3' enum
toE'Type3 :: Text -> P.Either String E'Type3
toE'Type3 = \case
  "basic" -> P.Right E'Type3'Basic
  "start_end" -> P.Right E'Type3'Start_end
  "road" -> P.Right E'Type3'Road
  "public_transport" -> P.Right E'Type3'Public_transport
  s -> P.Left $ "toE'Type3: enum parse failure: " P.++ P.show s


-- ** E'Type4

-- | Enum of 'Text'
data E'Type4
  = E'Type4'Cycling -- ^ @"cycling"@
  | E'Type4'Driving -- ^ @"driving"@
  | E'Type4'Drivingtrain -- ^ @"driving+train"@
  | E'Type4'Public_transport -- ^ @"public_transport"@
  | E'Type4'Walking -- ^ @"walking"@
  | E'Type4'Coach -- ^ @"coach"@
  | E'Type4'Bus -- ^ @"bus"@
  | E'Type4'Train -- ^ @"train"@
  | E'Type4'Ferry -- ^ @"ferry"@
  | E'Type4'Drivingferry -- ^ @"driving+ferry"@
  | E'Type4'Cyclingferry -- ^ @"cycling+ferry"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type4 where toJSON = A.toJSON . fromE'Type4
instance A.FromJSON E'Type4 where parseJSON o = P.either P.fail (pure . P.id) . toE'Type4 =<< A.parseJSON o
instance WH.ToHttpApiData E'Type4 where toQueryParam = WH.toQueryParam . fromE'Type4
instance WH.FromHttpApiData E'Type4 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type4
instance MimeRender MimeMultipartFormData E'Type4 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type4' enum
fromE'Type4 :: E'Type4 -> Text
fromE'Type4 = \case
  E'Type4'Cycling -> "cycling"
  E'Type4'Driving -> "driving"
  E'Type4'Drivingtrain -> "driving+train"
  E'Type4'Public_transport -> "public_transport"
  E'Type4'Walking -> "walking"
  E'Type4'Coach -> "coach"
  E'Type4'Bus -> "bus"
  E'Type4'Train -> "train"
  E'Type4'Ferry -> "ferry"
  E'Type4'Drivingferry -> "driving+ferry"
  E'Type4'Cyclingferry -> "cycling+ferry"

-- | parse 'E'Type4' enum
toE'Type4 :: Text -> P.Either String E'Type4
toE'Type4 = \case
  "cycling" -> P.Right E'Type4'Cycling
  "driving" -> P.Right E'Type4'Driving
  "driving+train" -> P.Right E'Type4'Drivingtrain
  "public_transport" -> P.Right E'Type4'Public_transport
  "walking" -> P.Right E'Type4'Walking
  "coach" -> P.Right E'Type4'Coach
  "bus" -> P.Right E'Type4'Bus
  "train" -> P.Right E'Type4'Train
  "ferry" -> P.Right E'Type4'Ferry
  "driving+ferry" -> P.Right E'Type4'Drivingferry
  "cycling+ferry" -> P.Right E'Type4'Cyclingferry
  s -> P.Left $ "toE'Type4: enum parse failure: " P.++ P.show s


-- ** RequestArrivalTimePeriod

-- | Enum of 'Text'
data RequestArrivalTimePeriod
  = RequestArrivalTimePeriod'Weekday_morning -- ^ @"weekday_morning"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON RequestArrivalTimePeriod where toJSON = A.toJSON . fromRequestArrivalTimePeriod
instance A.FromJSON RequestArrivalTimePeriod where parseJSON o = P.either P.fail (pure . P.id) . toRequestArrivalTimePeriod =<< A.parseJSON o
instance WH.ToHttpApiData RequestArrivalTimePeriod where toQueryParam = WH.toQueryParam . fromRequestArrivalTimePeriod
instance WH.FromHttpApiData RequestArrivalTimePeriod where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toRequestArrivalTimePeriod
instance MimeRender MimeMultipartFormData RequestArrivalTimePeriod where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'RequestArrivalTimePeriod' enum
fromRequestArrivalTimePeriod :: RequestArrivalTimePeriod -> Text
fromRequestArrivalTimePeriod = \case
  RequestArrivalTimePeriod'Weekday_morning -> "weekday_morning"

-- | parse 'RequestArrivalTimePeriod' enum
toRequestArrivalTimePeriod :: Text -> P.Either String RequestArrivalTimePeriod
toRequestArrivalTimePeriod = \case
  "weekday_morning" -> P.Right RequestArrivalTimePeriod'Weekday_morning
  s -> P.Left $ "toRequestArrivalTimePeriod: enum parse failure: " P.++ P.show s


-- ** RequestRoutesProperty

-- | Enum of 'Text'
data RequestRoutesProperty
  = RequestRoutesProperty'Travel_time -- ^ @"travel_time"@
  | RequestRoutesProperty'Distance -- ^ @"distance"@
  | RequestRoutesProperty'Fares -- ^ @"fares"@
  | RequestRoutesProperty'Route -- ^ @"route"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON RequestRoutesProperty where toJSON = A.toJSON . fromRequestRoutesProperty
instance A.FromJSON RequestRoutesProperty where parseJSON o = P.either P.fail (pure . P.id) . toRequestRoutesProperty =<< A.parseJSON o
instance WH.ToHttpApiData RequestRoutesProperty where toQueryParam = WH.toQueryParam . fromRequestRoutesProperty
instance WH.FromHttpApiData RequestRoutesProperty where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toRequestRoutesProperty
instance MimeRender MimeMultipartFormData RequestRoutesProperty where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'RequestRoutesProperty' enum
fromRequestRoutesProperty :: RequestRoutesProperty -> Text
fromRequestRoutesProperty = \case
  RequestRoutesProperty'Travel_time -> "travel_time"
  RequestRoutesProperty'Distance -> "distance"
  RequestRoutesProperty'Fares -> "fares"
  RequestRoutesProperty'Route -> "route"

-- | parse 'RequestRoutesProperty' enum
toRequestRoutesProperty :: Text -> P.Either String RequestRoutesProperty
toRequestRoutesProperty = \case
  "travel_time" -> P.Right RequestRoutesProperty'Travel_time
  "distance" -> P.Right RequestRoutesProperty'Distance
  "fares" -> P.Right RequestRoutesProperty'Fares
  "route" -> P.Right RequestRoutesProperty'Route
  s -> P.Left $ "toRequestRoutesProperty: enum parse failure: " P.++ P.show s


-- ** RequestTimeFilterFastProperty

-- | Enum of 'Text'
data RequestTimeFilterFastProperty
  = RequestTimeFilterFastProperty'Travel_time -- ^ @"travel_time"@
  | RequestTimeFilterFastProperty'Fares -- ^ @"fares"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON RequestTimeFilterFastProperty where toJSON = A.toJSON . fromRequestTimeFilterFastProperty
instance A.FromJSON RequestTimeFilterFastProperty where parseJSON o = P.either P.fail (pure . P.id) . toRequestTimeFilterFastProperty =<< A.parseJSON o
instance WH.ToHttpApiData RequestTimeFilterFastProperty where toQueryParam = WH.toQueryParam . fromRequestTimeFilterFastProperty
instance WH.FromHttpApiData RequestTimeFilterFastProperty where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toRequestTimeFilterFastProperty
instance MimeRender MimeMultipartFormData RequestTimeFilterFastProperty where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'RequestTimeFilterFastProperty' enum
fromRequestTimeFilterFastProperty :: RequestTimeFilterFastProperty -> Text
fromRequestTimeFilterFastProperty = \case
  RequestTimeFilterFastProperty'Travel_time -> "travel_time"
  RequestTimeFilterFastProperty'Fares -> "fares"

-- | parse 'RequestTimeFilterFastProperty' enum
toRequestTimeFilterFastProperty :: Text -> P.Either String RequestTimeFilterFastProperty
toRequestTimeFilterFastProperty = \case
  "travel_time" -> P.Right RequestTimeFilterFastProperty'Travel_time
  "fares" -> P.Right RequestTimeFilterFastProperty'Fares
  s -> P.Left $ "toRequestTimeFilterFastProperty: enum parse failure: " P.++ P.show s


-- ** RequestTimeFilterPostcodeDistrictsProperty

-- | Enum of 'Text'
data RequestTimeFilterPostcodeDistrictsProperty
  = RequestTimeFilterPostcodeDistrictsProperty'Travel_time_reachable -- ^ @"travel_time_reachable"@
  | RequestTimeFilterPostcodeDistrictsProperty'Travel_time_all -- ^ @"travel_time_all"@
  | RequestTimeFilterPostcodeDistrictsProperty'Coverage -- ^ @"coverage"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON RequestTimeFilterPostcodeDistrictsProperty where toJSON = A.toJSON . fromRequestTimeFilterPostcodeDistrictsProperty
instance A.FromJSON RequestTimeFilterPostcodeDistrictsProperty where parseJSON o = P.either P.fail (pure . P.id) . toRequestTimeFilterPostcodeDistrictsProperty =<< A.parseJSON o
instance WH.ToHttpApiData RequestTimeFilterPostcodeDistrictsProperty where toQueryParam = WH.toQueryParam . fromRequestTimeFilterPostcodeDistrictsProperty
instance WH.FromHttpApiData RequestTimeFilterPostcodeDistrictsProperty where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toRequestTimeFilterPostcodeDistrictsProperty
instance MimeRender MimeMultipartFormData RequestTimeFilterPostcodeDistrictsProperty where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'RequestTimeFilterPostcodeDistrictsProperty' enum
fromRequestTimeFilterPostcodeDistrictsProperty :: RequestTimeFilterPostcodeDistrictsProperty -> Text
fromRequestTimeFilterPostcodeDistrictsProperty = \case
  RequestTimeFilterPostcodeDistrictsProperty'Travel_time_reachable -> "travel_time_reachable"
  RequestTimeFilterPostcodeDistrictsProperty'Travel_time_all -> "travel_time_all"
  RequestTimeFilterPostcodeDistrictsProperty'Coverage -> "coverage"

-- | parse 'RequestTimeFilterPostcodeDistrictsProperty' enum
toRequestTimeFilterPostcodeDistrictsProperty :: Text -> P.Either String RequestTimeFilterPostcodeDistrictsProperty
toRequestTimeFilterPostcodeDistrictsProperty = \case
  "travel_time_reachable" -> P.Right RequestTimeFilterPostcodeDistrictsProperty'Travel_time_reachable
  "travel_time_all" -> P.Right RequestTimeFilterPostcodeDistrictsProperty'Travel_time_all
  "coverage" -> P.Right RequestTimeFilterPostcodeDistrictsProperty'Coverage
  s -> P.Left $ "toRequestTimeFilterPostcodeDistrictsProperty: enum parse failure: " P.++ P.show s


-- ** RequestTimeFilterPostcodeSectorsProperty

-- | Enum of 'Text'
data RequestTimeFilterPostcodeSectorsProperty
  = RequestTimeFilterPostcodeSectorsProperty'Travel_time_reachable -- ^ @"travel_time_reachable"@
  | RequestTimeFilterPostcodeSectorsProperty'Travel_time_all -- ^ @"travel_time_all"@
  | RequestTimeFilterPostcodeSectorsProperty'Coverage -- ^ @"coverage"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON RequestTimeFilterPostcodeSectorsProperty where toJSON = A.toJSON . fromRequestTimeFilterPostcodeSectorsProperty
instance A.FromJSON RequestTimeFilterPostcodeSectorsProperty where parseJSON o = P.either P.fail (pure . P.id) . toRequestTimeFilterPostcodeSectorsProperty =<< A.parseJSON o
instance WH.ToHttpApiData RequestTimeFilterPostcodeSectorsProperty where toQueryParam = WH.toQueryParam . fromRequestTimeFilterPostcodeSectorsProperty
instance WH.FromHttpApiData RequestTimeFilterPostcodeSectorsProperty where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toRequestTimeFilterPostcodeSectorsProperty
instance MimeRender MimeMultipartFormData RequestTimeFilterPostcodeSectorsProperty where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'RequestTimeFilterPostcodeSectorsProperty' enum
fromRequestTimeFilterPostcodeSectorsProperty :: RequestTimeFilterPostcodeSectorsProperty -> Text
fromRequestTimeFilterPostcodeSectorsProperty = \case
  RequestTimeFilterPostcodeSectorsProperty'Travel_time_reachable -> "travel_time_reachable"
  RequestTimeFilterPostcodeSectorsProperty'Travel_time_all -> "travel_time_all"
  RequestTimeFilterPostcodeSectorsProperty'Coverage -> "coverage"

-- | parse 'RequestTimeFilterPostcodeSectorsProperty' enum
toRequestTimeFilterPostcodeSectorsProperty :: Text -> P.Either String RequestTimeFilterPostcodeSectorsProperty
toRequestTimeFilterPostcodeSectorsProperty = \case
  "travel_time_reachable" -> P.Right RequestTimeFilterPostcodeSectorsProperty'Travel_time_reachable
  "travel_time_all" -> P.Right RequestTimeFilterPostcodeSectorsProperty'Travel_time_all
  "coverage" -> P.Right RequestTimeFilterPostcodeSectorsProperty'Coverage
  s -> P.Left $ "toRequestTimeFilterPostcodeSectorsProperty: enum parse failure: " P.++ P.show s


-- ** RequestTimeFilterPostcodesProperty

-- | Enum of 'Text'
data RequestTimeFilterPostcodesProperty
  = RequestTimeFilterPostcodesProperty'Travel_time -- ^ @"travel_time"@
  | RequestTimeFilterPostcodesProperty'Distance -- ^ @"distance"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON RequestTimeFilterPostcodesProperty where toJSON = A.toJSON . fromRequestTimeFilterPostcodesProperty
instance A.FromJSON RequestTimeFilterPostcodesProperty where parseJSON o = P.either P.fail (pure . P.id) . toRequestTimeFilterPostcodesProperty =<< A.parseJSON o
instance WH.ToHttpApiData RequestTimeFilterPostcodesProperty where toQueryParam = WH.toQueryParam . fromRequestTimeFilterPostcodesProperty
instance WH.FromHttpApiData RequestTimeFilterPostcodesProperty where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toRequestTimeFilterPostcodesProperty
instance MimeRender MimeMultipartFormData RequestTimeFilterPostcodesProperty where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'RequestTimeFilterPostcodesProperty' enum
fromRequestTimeFilterPostcodesProperty :: RequestTimeFilterPostcodesProperty -> Text
fromRequestTimeFilterPostcodesProperty = \case
  RequestTimeFilterPostcodesProperty'Travel_time -> "travel_time"
  RequestTimeFilterPostcodesProperty'Distance -> "distance"

-- | parse 'RequestTimeFilterPostcodesProperty' enum
toRequestTimeFilterPostcodesProperty :: Text -> P.Either String RequestTimeFilterPostcodesProperty
toRequestTimeFilterPostcodesProperty = \case
  "travel_time" -> P.Right RequestTimeFilterPostcodesProperty'Travel_time
  "distance" -> P.Right RequestTimeFilterPostcodesProperty'Distance
  s -> P.Left $ "toRequestTimeFilterPostcodesProperty: enum parse failure: " P.++ P.show s


-- ** RequestTimeFilterProperty

-- | Enum of 'Text'
data RequestTimeFilterProperty
  = RequestTimeFilterProperty'Travel_time -- ^ @"travel_time"@
  | RequestTimeFilterProperty'Distance -- ^ @"distance"@
  | RequestTimeFilterProperty'Distance_breakdown -- ^ @"distance_breakdown"@
  | RequestTimeFilterProperty'Fares -- ^ @"fares"@
  | RequestTimeFilterProperty'Route -- ^ @"route"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON RequestTimeFilterProperty where toJSON = A.toJSON . fromRequestTimeFilterProperty
instance A.FromJSON RequestTimeFilterProperty where parseJSON o = P.either P.fail (pure . P.id) . toRequestTimeFilterProperty =<< A.parseJSON o
instance WH.ToHttpApiData RequestTimeFilterProperty where toQueryParam = WH.toQueryParam . fromRequestTimeFilterProperty
instance WH.FromHttpApiData RequestTimeFilterProperty where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toRequestTimeFilterProperty
instance MimeRender MimeMultipartFormData RequestTimeFilterProperty where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'RequestTimeFilterProperty' enum
fromRequestTimeFilterProperty :: RequestTimeFilterProperty -> Text
fromRequestTimeFilterProperty = \case
  RequestTimeFilterProperty'Travel_time -> "travel_time"
  RequestTimeFilterProperty'Distance -> "distance"
  RequestTimeFilterProperty'Distance_breakdown -> "distance_breakdown"
  RequestTimeFilterProperty'Fares -> "fares"
  RequestTimeFilterProperty'Route -> "route"

-- | parse 'RequestTimeFilterProperty' enum
toRequestTimeFilterProperty :: Text -> P.Either String RequestTimeFilterProperty
toRequestTimeFilterProperty = \case
  "travel_time" -> P.Right RequestTimeFilterProperty'Travel_time
  "distance" -> P.Right RequestTimeFilterProperty'Distance
  "distance_breakdown" -> P.Right RequestTimeFilterProperty'Distance_breakdown
  "fares" -> P.Right RequestTimeFilterProperty'Fares
  "route" -> P.Right RequestTimeFilterProperty'Route
  s -> P.Left $ "toRequestTimeFilterProperty: enum parse failure: " P.++ P.show s


-- ** RequestTimeMapProperty

-- | Enum of 'Text'
data RequestTimeMapProperty
  = RequestTimeMapProperty'Is_only_walking -- ^ @"is_only_walking"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON RequestTimeMapProperty where toJSON = A.toJSON . fromRequestTimeMapProperty
instance A.FromJSON RequestTimeMapProperty where parseJSON o = P.either P.fail (pure . P.id) . toRequestTimeMapProperty =<< A.parseJSON o
instance WH.ToHttpApiData RequestTimeMapProperty where toQueryParam = WH.toQueryParam . fromRequestTimeMapProperty
instance WH.FromHttpApiData RequestTimeMapProperty where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toRequestTimeMapProperty
instance MimeRender MimeMultipartFormData RequestTimeMapProperty where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'RequestTimeMapProperty' enum
fromRequestTimeMapProperty :: RequestTimeMapProperty -> Text
fromRequestTimeMapProperty = \case
  RequestTimeMapProperty'Is_only_walking -> "is_only_walking"

-- | parse 'RequestTimeMapProperty' enum
toRequestTimeMapProperty :: Text -> P.Either String RequestTimeMapProperty
toRequestTimeMapProperty = \case
  "is_only_walking" -> P.Right RequestTimeMapProperty'Is_only_walking
  s -> P.Left $ "toRequestTimeMapProperty: enum parse failure: " P.++ P.show s


-- ** ResponseTransportationMode

-- | Enum of 'Text'
data ResponseTransportationMode
  = ResponseTransportationMode'Car -- ^ @"car"@
  | ResponseTransportationMode'Parking -- ^ @"parking"@
  | ResponseTransportationMode'Boarding -- ^ @"boarding"@
  | ResponseTransportationMode'Walk -- ^ @"walk"@
  | ResponseTransportationMode'Bike -- ^ @"bike"@
  | ResponseTransportationMode'Train -- ^ @"train"@
  | ResponseTransportationMode'Rail_national -- ^ @"rail_national"@
  | ResponseTransportationMode'Rail_overground -- ^ @"rail_overground"@
  | ResponseTransportationMode'Rail_underground -- ^ @"rail_underground"@
  | ResponseTransportationMode'Rail_dlr -- ^ @"rail_dlr"@
  | ResponseTransportationMode'Bus -- ^ @"bus"@
  | ResponseTransportationMode'Cable_car -- ^ @"cable_car"@
  | ResponseTransportationMode'Plane -- ^ @"plane"@
  | ResponseTransportationMode'Ferry -- ^ @"ferry"@
  | ResponseTransportationMode'Coach -- ^ @"coach"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON ResponseTransportationMode where toJSON = A.toJSON . fromResponseTransportationMode
instance A.FromJSON ResponseTransportationMode where parseJSON o = P.either P.fail (pure . P.id) . toResponseTransportationMode =<< A.parseJSON o
instance WH.ToHttpApiData ResponseTransportationMode where toQueryParam = WH.toQueryParam . fromResponseTransportationMode
instance WH.FromHttpApiData ResponseTransportationMode where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toResponseTransportationMode
instance MimeRender MimeMultipartFormData ResponseTransportationMode where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'ResponseTransportationMode' enum
fromResponseTransportationMode :: ResponseTransportationMode -> Text
fromResponseTransportationMode = \case
  ResponseTransportationMode'Car -> "car"
  ResponseTransportationMode'Parking -> "parking"
  ResponseTransportationMode'Boarding -> "boarding"
  ResponseTransportationMode'Walk -> "walk"
  ResponseTransportationMode'Bike -> "bike"
  ResponseTransportationMode'Train -> "train"
  ResponseTransportationMode'Rail_national -> "rail_national"
  ResponseTransportationMode'Rail_overground -> "rail_overground"
  ResponseTransportationMode'Rail_underground -> "rail_underground"
  ResponseTransportationMode'Rail_dlr -> "rail_dlr"
  ResponseTransportationMode'Bus -> "bus"
  ResponseTransportationMode'Cable_car -> "cable_car"
  ResponseTransportationMode'Plane -> "plane"
  ResponseTransportationMode'Ferry -> "ferry"
  ResponseTransportationMode'Coach -> "coach"

-- | parse 'ResponseTransportationMode' enum
toResponseTransportationMode :: Text -> P.Either String ResponseTransportationMode
toResponseTransportationMode = \case
  "car" -> P.Right ResponseTransportationMode'Car
  "parking" -> P.Right ResponseTransportationMode'Parking
  "boarding" -> P.Right ResponseTransportationMode'Boarding
  "walk" -> P.Right ResponseTransportationMode'Walk
  "bike" -> P.Right ResponseTransportationMode'Bike
  "train" -> P.Right ResponseTransportationMode'Train
  "rail_national" -> P.Right ResponseTransportationMode'Rail_national
  "rail_overground" -> P.Right ResponseTransportationMode'Rail_overground
  "rail_underground" -> P.Right ResponseTransportationMode'Rail_underground
  "rail_dlr" -> P.Right ResponseTransportationMode'Rail_dlr
  "bus" -> P.Right ResponseTransportationMode'Bus
  "cable_car" -> P.Right ResponseTransportationMode'Cable_car
  "plane" -> P.Right ResponseTransportationMode'Plane
  "ferry" -> P.Right ResponseTransportationMode'Ferry
  "coach" -> P.Right ResponseTransportationMode'Coach
  s -> P.Left $ "toResponseTransportationMode: enum parse failure: " P.++ P.show s


-- * Auth Methods

-- ** AuthApiKeyApiKey
data AuthApiKeyApiKey =
  AuthApiKeyApiKey Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthApiKeyApiKey where
  applyAuthMethod _ a@(AuthApiKeyApiKey secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("X-Api-Key", secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req

-- ** AuthApiKeyApplicationId
data AuthApiKeyApplicationId =
  AuthApiKeyApplicationId Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthApiKeyApplicationId where
  applyAuthMethod _ a@(AuthApiKeyApplicationId secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("X-Application-Id", secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req


