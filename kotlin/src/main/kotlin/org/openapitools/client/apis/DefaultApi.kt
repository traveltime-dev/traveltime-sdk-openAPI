/**
* TravelTime API
* No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
*
* The version of the OpenAPI document: 1.2.2
* Contact: support@igeolise.com
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/
package org.openapitools.client.apis

import org.openapitools.client.models.RequestRoutes
import org.openapitools.client.models.RequestSupportedLocations
import org.openapitools.client.models.RequestTimeFilter
import org.openapitools.client.models.RequestTimeFilterFast
import org.openapitools.client.models.RequestTimeFilterPostcodeDistricts
import org.openapitools.client.models.RequestTimeFilterPostcodeSectors
import org.openapitools.client.models.RequestTimeFilterPostcodes
import org.openapitools.client.models.RequestTimeMap
import org.openapitools.client.models.ResponseError
import org.openapitools.client.models.ResponseGeocoding
import org.openapitools.client.models.ResponseMapInfo
import org.openapitools.client.models.ResponseRoutes
import org.openapitools.client.models.ResponseSupportedLocations
import org.openapitools.client.models.ResponseTimeFilter
import org.openapitools.client.models.ResponseTimeFilterFast
import org.openapitools.client.models.ResponseTimeFilterPostcodeDistricts
import org.openapitools.client.models.ResponseTimeFilterPostcodeSectors
import org.openapitools.client.models.ResponseTimeFilterPostcodes
import org.openapitools.client.models.ResponseTimeMap

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class DefaultApi(basePath: kotlin.String = defaultBasePath) : ApiClient(basePath) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty("org.openapitools.client.baseUrl", "https://api.traveltimeapp.com")
        }
    }

    /**
    * 
    * 
    * @param lat  
    * @param lng  
    * @param withinCountry  (optional)
    * @return ResponseGeocoding
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun geocodingReverseSearch(lat: kotlin.Double, lng: kotlin.Double, withinCountry: kotlin.String?) : ResponseGeocoding {
        val localVariableConfig = geocodingReverseSearchRequestConfig(lat = lat, lng = lng, withinCountry = withinCountry)

        val localVarResponse = request<ResponseGeocoding>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ResponseGeocoding
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation geocodingReverseSearch
    *
    * @param lat  
    * @param lng  
    * @param withinCountry  (optional)
    * @return RequestConfig
    */
    fun geocodingReverseSearchRequestConfig(lat: kotlin.Double, lng: kotlin.Double, withinCountry: kotlin.String?) : RequestConfig {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                put("lat", listOf(lat.toString()))
                put("lng", listOf(lng.toString()))
                if (withinCountry != null) {
                    put("within.country", listOf(withinCountry.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.GET,
            path = "/v4/geocoding/reverse",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

    /**
    * 
    * 
    * @param query  
    * @param focusLat  (optional)
    * @param focusLng  (optional)
    * @param withinCountry  (optional)
    * @return ResponseGeocoding
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun geocodingSearch(query: kotlin.String, focusLat: kotlin.Double?, focusLng: kotlin.Double?, withinCountry: kotlin.String?) : ResponseGeocoding {
        val localVariableConfig = geocodingSearchRequestConfig(query = query, focusLat = focusLat, focusLng = focusLng, withinCountry = withinCountry)

        val localVarResponse = request<ResponseGeocoding>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ResponseGeocoding
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation geocodingSearch
    *
    * @param query  
    * @param focusLat  (optional)
    * @param focusLng  (optional)
    * @param withinCountry  (optional)
    * @return RequestConfig
    */
    fun geocodingSearchRequestConfig(query: kotlin.String, focusLat: kotlin.Double?, focusLng: kotlin.Double?, withinCountry: kotlin.String?) : RequestConfig {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                put("query", listOf(query.toString()))
                if (focusLat != null) {
                    put("focus.lat", listOf(focusLat.toString()))
                }
                if (focusLng != null) {
                    put("focus.lng", listOf(focusLng.toString()))
                }
                if (withinCountry != null) {
                    put("within.country", listOf(withinCountry.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.GET,
            path = "/v4/geocoding/search",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

    /**
    * 
    * 
    * @return ResponseMapInfo
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun mapInfo() : ResponseMapInfo {
        val localVariableConfig = mapInfoRequestConfig()

        val localVarResponse = request<ResponseMapInfo>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ResponseMapInfo
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation mapInfo
    *
    * @return RequestConfig
    */
    fun mapInfoRequestConfig() : RequestConfig {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.GET,
            path = "/v4/map-info",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

    /**
    * 
    * 
    * @param requestRoutes  
    * @return ResponseRoutes
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun routes(requestRoutes: RequestRoutes) : ResponseRoutes {
        val localVariableConfig = routesRequestConfig(requestRoutes = requestRoutes)

        val localVarResponse = request<ResponseRoutes>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ResponseRoutes
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation routes
    *
    * @param requestRoutes  
    * @return RequestConfig
    */
    fun routesRequestConfig(requestRoutes: RequestRoutes) : RequestConfig {
        val localVariableBody: kotlin.Any? = requestRoutes
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.POST,
            path = "/v4/routes",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

    /**
    * 
    * 
    * @param requestSupportedLocations  
    * @return ResponseSupportedLocations
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun supportedLocations(requestSupportedLocations: RequestSupportedLocations) : ResponseSupportedLocations {
        val localVariableConfig = supportedLocationsRequestConfig(requestSupportedLocations = requestSupportedLocations)

        val localVarResponse = request<ResponseSupportedLocations>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ResponseSupportedLocations
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation supportedLocations
    *
    * @param requestSupportedLocations  
    * @return RequestConfig
    */
    fun supportedLocationsRequestConfig(requestSupportedLocations: RequestSupportedLocations) : RequestConfig {
        val localVariableBody: kotlin.Any? = requestSupportedLocations
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.POST,
            path = "/v4/supported-locations",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

    /**
    * 
    * 
    * @param requestTimeFilter  
    * @return ResponseTimeFilter
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun timeFilter(requestTimeFilter: RequestTimeFilter) : ResponseTimeFilter {
        val localVariableConfig = timeFilterRequestConfig(requestTimeFilter = requestTimeFilter)

        val localVarResponse = request<ResponseTimeFilter>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ResponseTimeFilter
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation timeFilter
    *
    * @param requestTimeFilter  
    * @return RequestConfig
    */
    fun timeFilterRequestConfig(requestTimeFilter: RequestTimeFilter) : RequestConfig {
        val localVariableBody: kotlin.Any? = requestTimeFilter
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.POST,
            path = "/v4/time-filter",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

    /**
    * 
    * 
    * @param requestTimeFilterFast  
    * @return ResponseTimeFilterFast
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun timeFilterFast(requestTimeFilterFast: RequestTimeFilterFast) : ResponseTimeFilterFast {
        val localVariableConfig = timeFilterFastRequestConfig(requestTimeFilterFast = requestTimeFilterFast)

        val localVarResponse = request<ResponseTimeFilterFast>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ResponseTimeFilterFast
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation timeFilterFast
    *
    * @param requestTimeFilterFast  
    * @return RequestConfig
    */
    fun timeFilterFastRequestConfig(requestTimeFilterFast: RequestTimeFilterFast) : RequestConfig {
        val localVariableBody: kotlin.Any? = requestTimeFilterFast
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.POST,
            path = "/v4/time-filter/fast",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

    /**
    * 
    * 
    * @param requestTimeFilterPostcodeDistricts  
    * @return ResponseTimeFilterPostcodeDistricts
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun timeFilterPostcodeDistricts(requestTimeFilterPostcodeDistricts: RequestTimeFilterPostcodeDistricts) : ResponseTimeFilterPostcodeDistricts {
        val localVariableConfig = timeFilterPostcodeDistrictsRequestConfig(requestTimeFilterPostcodeDistricts = requestTimeFilterPostcodeDistricts)

        val localVarResponse = request<ResponseTimeFilterPostcodeDistricts>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ResponseTimeFilterPostcodeDistricts
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation timeFilterPostcodeDistricts
    *
    * @param requestTimeFilterPostcodeDistricts  
    * @return RequestConfig
    */
    fun timeFilterPostcodeDistrictsRequestConfig(requestTimeFilterPostcodeDistricts: RequestTimeFilterPostcodeDistricts) : RequestConfig {
        val localVariableBody: kotlin.Any? = requestTimeFilterPostcodeDistricts
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.POST,
            path = "/v4/time-filter/postcode-districts",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

    /**
    * 
    * 
    * @param requestTimeFilterPostcodeSectors  
    * @return ResponseTimeFilterPostcodeSectors
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun timeFilterPostcodeSectors(requestTimeFilterPostcodeSectors: RequestTimeFilterPostcodeSectors) : ResponseTimeFilterPostcodeSectors {
        val localVariableConfig = timeFilterPostcodeSectorsRequestConfig(requestTimeFilterPostcodeSectors = requestTimeFilterPostcodeSectors)

        val localVarResponse = request<ResponseTimeFilterPostcodeSectors>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ResponseTimeFilterPostcodeSectors
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation timeFilterPostcodeSectors
    *
    * @param requestTimeFilterPostcodeSectors  
    * @return RequestConfig
    */
    fun timeFilterPostcodeSectorsRequestConfig(requestTimeFilterPostcodeSectors: RequestTimeFilterPostcodeSectors) : RequestConfig {
        val localVariableBody: kotlin.Any? = requestTimeFilterPostcodeSectors
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.POST,
            path = "/v4/time-filter/postcode-sectors",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

    /**
    * 
    * 
    * @param requestTimeFilterPostcodes  
    * @return ResponseTimeFilterPostcodes
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun timeFilterPostcodes(requestTimeFilterPostcodes: RequestTimeFilterPostcodes) : ResponseTimeFilterPostcodes {
        val localVariableConfig = timeFilterPostcodesRequestConfig(requestTimeFilterPostcodes = requestTimeFilterPostcodes)

        val localVarResponse = request<ResponseTimeFilterPostcodes>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ResponseTimeFilterPostcodes
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation timeFilterPostcodes
    *
    * @param requestTimeFilterPostcodes  
    * @return RequestConfig
    */
    fun timeFilterPostcodesRequestConfig(requestTimeFilterPostcodes: RequestTimeFilterPostcodes) : RequestConfig {
        val localVariableBody: kotlin.Any? = requestTimeFilterPostcodes
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.POST,
            path = "/v4/time-filter/postcodes",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

    /**
    * 
    * 
    * @param requestTimeMap  
    * @return ResponseTimeMap
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun timeMap(requestTimeMap: RequestTimeMap) : ResponseTimeMap {
        val localVariableConfig = timeMapRequestConfig(requestTimeMap = requestTimeMap)

        val localVarResponse = request<ResponseTimeMap>(
            localVariableConfig
        )

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ResponseTimeMap
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
    * To obtain the request config of the operation timeMap
    *
    * @param requestTimeMap  
    * @return RequestConfig
    */
    fun timeMapRequestConfig(requestTimeMap: RequestTimeMap) : RequestConfig {
        val localVariableBody: kotlin.Any? = requestTimeMap
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        val localVariableConfig = RequestConfig(
            method = RequestMethod.POST,
            path = "/v4/time-map",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )

        return localVariableConfig
    }

}
