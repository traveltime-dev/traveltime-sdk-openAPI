<?php

/**
 * DefaultController
 * PHP version 5
 *
 * @category Class
 * @package  OpenAPI\Server\Controller
 * @author   OpenAPI Generator team
 * @link     https://github.com/openapitools/openapi-generator
 */

/**
 * TravelTime Platform API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@igeolise.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 *
 */

/**
 * NOTE: This class is auto generated by the openapi generator program.
 * https://github.com/openapitools/openapi-generator
 * Do not edit the class manually.
 */

namespace OpenAPI\Server\Controller;

use \Exception;
use JMS\Serializer\Exception\RuntimeException as SerializerRuntimeException;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpKernel\Exception\HttpException;
use Symfony\Component\Validator\Constraints as Assert;
use OpenAPI\Server\Api\DefaultApiInterface;
use OpenAPI\Server\Model\RequestRoutes;
use OpenAPI\Server\Model\RequestSupportedLocations;
use OpenAPI\Server\Model\RequestTimeFilter;
use OpenAPI\Server\Model\RequestTimeFilterFast;
use OpenAPI\Server\Model\RequestTimeFilterPostcodeDistricts;
use OpenAPI\Server\Model\RequestTimeFilterPostcodeSectors;
use OpenAPI\Server\Model\RequestTimeFilterPostcodes;
use OpenAPI\Server\Model\RequestTimeMap;
use OpenAPI\Server\Model\ResponseError;
use OpenAPI\Server\Model\ResponseGeocoding;
use OpenAPI\Server\Model\ResponseMapInfo;
use OpenAPI\Server\Model\ResponseRoutes;
use OpenAPI\Server\Model\ResponseSupportedLocations;
use OpenAPI\Server\Model\ResponseTimeFilter;
use OpenAPI\Server\Model\ResponseTimeFilterFast;
use OpenAPI\Server\Model\ResponseTimeFilterPostcodeDistricts;
use OpenAPI\Server\Model\ResponseTimeFilterPostcodeSectors;
use OpenAPI\Server\Model\ResponseTimeFilterPostcodes;
use OpenAPI\Server\Model\ResponseTimeMap;

/**
 * DefaultController Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Server\Controller
 * @author   OpenAPI Generator team
 * @link     https://github.com/openapitools/openapi-generator
 */
class DefaultController extends Controller
{

    /**
     * Operation geocodingReverseSearch
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function geocodingReverseSearchAction(Request $request)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'ApiKey' required
        // Set key with prefix in header
        $securityApiKey = $request->headers->get('X-Api-Key');
        // Authentication 'ApplicationId' required
        // Set key with prefix in header
        $securityApplicationId = $request->headers->get('X-Application-Id');

        // Read out all input parameter values into variables
        $focusLat = $request->query->get('focusLat');
        $focusLng = $request->query->get('focusLng');
        $withinCountry = $request->query->get('withinCountry');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $focusLat = $this->deserialize($focusLat, 'double', 'string');
            $focusLng = $this->deserialize($focusLng, 'double', 'string');
            $withinCountry = $this->deserialize($withinCountry, 'string', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("double");
        $response = $this->validate($focusLat, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("double");
        $response = $this->validate($focusLng, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($withinCountry, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'ApiKey'
            $handler->setApiKey($securityApiKey);
            // Set authentication method 'ApplicationId'
            $handler->setApplicationId($securityApplicationId);
            
            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];
            $result = $handler->geocodingReverseSearch($focusLat, $focusLng, $withinCountry, $responseCode, $responseHeaders);

            // Find default response message
            $message = 'Match a query string to geographic coordinates. [Docs link](http://docs.traveltimeplatform.com/reference/geocoding-search/)';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 200:
                    $message = 'Match a query string to geographic coordinates. [Docs link](http://docs.traveltimeplatform.com/reference/geocoding-search/)';
                    break;
                case 0:
                    $message = 'The json body returned upon error. [Docs link](http://docs.traveltimeplatform.com/reference/error-response)';
                    break;
            }

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation geocodingSearch
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function geocodingSearchAction(Request $request)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'ApiKey' required
        // Set key with prefix in header
        $securityApiKey = $request->headers->get('X-Api-Key');
        // Authentication 'ApplicationId' required
        // Set key with prefix in header
        $securityApplicationId = $request->headers->get('X-Application-Id');

        // Read out all input parameter values into variables
        $query = $request->query->get('query');
        $withinCountry = $request->query->get('withinCountry');
        $focusLat = $request->query->get('focusLat');
        $focusLng = $request->query->get('focusLng');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $query = $this->deserialize($query, 'string', 'string');
            $withinCountry = $this->deserialize($withinCountry, 'string', 'string');
            $focusLat = $this->deserialize($focusLat, 'double', 'string');
            $focusLng = $this->deserialize($focusLng, 'double', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($query, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($withinCountry, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("double");
        $response = $this->validate($focusLat, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("double");
        $response = $this->validate($focusLng, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'ApiKey'
            $handler->setApiKey($securityApiKey);
            // Set authentication method 'ApplicationId'
            $handler->setApplicationId($securityApplicationId);
            
            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];
            $result = $handler->geocodingSearch($query, $withinCountry, $focusLat, $focusLng, $responseCode, $responseHeaders);

            // Find default response message
            $message = 'Match a query string to geographic coordinates. [Docs link](http://docs.traveltimeplatform.com/reference/geocoding-search/)';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 200:
                    $message = 'Match a query string to geographic coordinates. [Docs link](http://docs.traveltimeplatform.com/reference/geocoding-search/)';
                    break;
                case 0:
                    $message = 'The json body returned upon error. [Docs link](http://docs.traveltimeplatform.com/reference/error-response)';
                    break;
            }

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation mapInfo
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function mapInfoAction(Request $request)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'ApiKey' required
        // Set key with prefix in header
        $securityApiKey = $request->headers->get('X-Api-Key');
        // Authentication 'ApplicationId' required
        // Set key with prefix in header
        $securityApplicationId = $request->headers->get('X-Application-Id');

        // Read out all input parameter values into variables

        // Use the default value if no value was provided

        // Validate the input values


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'ApiKey'
            $handler->setApiKey($securityApiKey);
            // Set authentication method 'ApplicationId'
            $handler->setApplicationId($securityApplicationId);
            
            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];
            $result = $handler->mapInfo($responseCode, $responseHeaders);

            // Find default response message
            $message = 'Returns information about currently supported countries. [Docs link](http://docs.traveltimeplatform.com/reference/map-info/)';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 200:
                    $message = 'Returns information about currently supported countries. [Docs link](http://docs.traveltimeplatform.com/reference/map-info/)';
                    break;
                case 0:
                    $message = 'The json body returned upon error. [Docs link](http://docs.traveltimeplatform.com/reference/error-response)';
                    break;
            }

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation routes
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function routesAction(Request $request)
    {
        // Make sure that the client is providing something that we can consume
        $consumes = ['application/json'];
        $inputFormat = $request->headers->has('Content-Type')?$request->headers->get('Content-Type'):$consumes[0];
        if (!in_array($inputFormat, $consumes)) {
            // We can't consume the content that the client is sending us
            return new Response('', 415);
        }

        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'ApiKey' required
        // Set key with prefix in header
        $securityApiKey = $request->headers->get('X-Api-Key');
        // Authentication 'ApplicationId' required
        // Set key with prefix in header
        $securityApplicationId = $request->headers->get('X-Application-Id');

        // Read out all input parameter values into variables
        $requestRoutes = $request->getContent();

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $requestRoutes = $this->deserialize($requestRoutes, 'OpenAPI\Server\Model\RequestRoutes', $inputFormat);
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("OpenAPI\Server\Model\RequestRoutes");
        $asserts[] = new Assert\Valid();
        $response = $this->validate($requestRoutes, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'ApiKey'
            $handler->setApiKey($securityApiKey);
            // Set authentication method 'ApplicationId'
            $handler->setApplicationId($securityApplicationId);
            
            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];
            $result = $handler->routes($requestRoutes, $responseCode, $responseHeaders);

            // Find default response message
            $message = 'Returns routing information between source and destinations. [Docs link](http://docs.traveltimeplatform.com/reference/routes/)';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 200:
                    $message = 'Returns routing information between source and destinations. [Docs link](http://docs.traveltimeplatform.com/reference/routes/)';
                    break;
                case 0:
                    $message = 'The json body returned upon error. [Docs link](http://docs.traveltimeplatform.com/reference/error-response)';
                    break;
            }

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation supportedLocations
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function supportedLocationsAction(Request $request)
    {
        // Make sure that the client is providing something that we can consume
        $consumes = ['application/json'];
        $inputFormat = $request->headers->has('Content-Type')?$request->headers->get('Content-Type'):$consumes[0];
        if (!in_array($inputFormat, $consumes)) {
            // We can't consume the content that the client is sending us
            return new Response('', 415);
        }

        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'ApiKey' required
        // Set key with prefix in header
        $securityApiKey = $request->headers->get('X-Api-Key');
        // Authentication 'ApplicationId' required
        // Set key with prefix in header
        $securityApplicationId = $request->headers->get('X-Application-Id');

        // Read out all input parameter values into variables
        $requestSupportedLocations = $request->getContent();

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $requestSupportedLocations = $this->deserialize($requestSupportedLocations, 'OpenAPI\Server\Model\RequestSupportedLocations', $inputFormat);
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("OpenAPI\Server\Model\RequestSupportedLocations");
        $asserts[] = new Assert\Valid();
        $response = $this->validate($requestSupportedLocations, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'ApiKey'
            $handler->setApiKey($securityApiKey);
            // Set authentication method 'ApplicationId'
            $handler->setApplicationId($securityApplicationId);
            
            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];
            $result = $handler->supportedLocations($requestSupportedLocations, $responseCode, $responseHeaders);

            // Find default response message
            $message = 'Find out what points are supported by our api. [Docs link](http://docs.traveltimeplatform.com/reference/supported-locations/)';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 200:
                    $message = 'Find out what points are supported by our api. [Docs link](http://docs.traveltimeplatform.com/reference/supported-locations/)';
                    break;
                case 0:
                    $message = 'The json body returned upon error. [Docs link](http://docs.traveltimeplatform.com/reference/error-response)';
                    break;
            }

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation timeFilter
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function timeFilterAction(Request $request)
    {
        // Make sure that the client is providing something that we can consume
        $consumes = ['application/json'];
        $inputFormat = $request->headers->has('Content-Type')?$request->headers->get('Content-Type'):$consumes[0];
        if (!in_array($inputFormat, $consumes)) {
            // We can't consume the content that the client is sending us
            return new Response('', 415);
        }

        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'ApiKey' required
        // Set key with prefix in header
        $securityApiKey = $request->headers->get('X-Api-Key');
        // Authentication 'ApplicationId' required
        // Set key with prefix in header
        $securityApplicationId = $request->headers->get('X-Application-Id');

        // Read out all input parameter values into variables
        $requestTimeFilter = $request->getContent();

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $requestTimeFilter = $this->deserialize($requestTimeFilter, 'OpenAPI\Server\Model\RequestTimeFilter', $inputFormat);
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("OpenAPI\Server\Model\RequestTimeFilter");
        $asserts[] = new Assert\Valid();
        $response = $this->validate($requestTimeFilter, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'ApiKey'
            $handler->setApiKey($securityApiKey);
            // Set authentication method 'ApplicationId'
            $handler->setApplicationId($securityApplicationId);
            
            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];
            $result = $handler->timeFilter($requestTimeFilter, $responseCode, $responseHeaders);

            // Find default response message
            $message = 'Given origin and destination points filter out points that cannot be reached within specified time limit. [Docs link](http://docs.traveltimeplatform.com/reference/time-filter)';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 200:
                    $message = 'Given origin and destination points filter out points that cannot be reached within specified time limit. [Docs link](http://docs.traveltimeplatform.com/reference/time-filter)';
                    break;
                case 0:
                    $message = 'The json body returned upon error. [Docs link](http://docs.traveltimeplatform.com/reference/error-response)';
                    break;
            }

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation timeFilterFast
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function timeFilterFastAction(Request $request)
    {
        // Make sure that the client is providing something that we can consume
        $consumes = ['application/json'];
        $inputFormat = $request->headers->has('Content-Type')?$request->headers->get('Content-Type'):$consumes[0];
        if (!in_array($inputFormat, $consumes)) {
            // We can't consume the content that the client is sending us
            return new Response('', 415);
        }

        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'ApiKey' required
        // Set key with prefix in header
        $securityApiKey = $request->headers->get('X-Api-Key');
        // Authentication 'ApplicationId' required
        // Set key with prefix in header
        $securityApplicationId = $request->headers->get('X-Application-Id');

        // Read out all input parameter values into variables
        $requestTimeFilterFast = $request->getContent();

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $requestTimeFilterFast = $this->deserialize($requestTimeFilterFast, 'OpenAPI\Server\Model\RequestTimeFilterFast', $inputFormat);
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("OpenAPI\Server\Model\RequestTimeFilterFast");
        $asserts[] = new Assert\Valid();
        $response = $this->validate($requestTimeFilterFast, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'ApiKey'
            $handler->setApiKey($securityApiKey);
            // Set authentication method 'ApplicationId'
            $handler->setApplicationId($securityApplicationId);
            
            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];
            $result = $handler->timeFilterFast($requestTimeFilterFast, $responseCode, $responseHeaders);

            // Find default response message
            $message = 'A very fast version of Time Filter. [Docs link](http://docs.traveltimeplatform.com/reference/time-filter-fast/)';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 200:
                    $message = 'A very fast version of Time Filter. [Docs link](http://docs.traveltimeplatform.com/reference/time-filter-fast/)';
                    break;
                case 0:
                    $message = 'The json body returned upon error. [Docs link](http://docs.traveltimeplatform.com/reference/error-response)';
                    break;
            }

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation timeFilterPostcodeDistricts
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function timeFilterPostcodeDistrictsAction(Request $request)
    {
        // Make sure that the client is providing something that we can consume
        $consumes = ['application/json'];
        $inputFormat = $request->headers->has('Content-Type')?$request->headers->get('Content-Type'):$consumes[0];
        if (!in_array($inputFormat, $consumes)) {
            // We can't consume the content that the client is sending us
            return new Response('', 415);
        }

        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'ApiKey' required
        // Set key with prefix in header
        $securityApiKey = $request->headers->get('X-Api-Key');
        // Authentication 'ApplicationId' required
        // Set key with prefix in header
        $securityApplicationId = $request->headers->get('X-Application-Id');

        // Read out all input parameter values into variables
        $requestTimeFilterPostcodeDistricts = $request->getContent();

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $requestTimeFilterPostcodeDistricts = $this->deserialize($requestTimeFilterPostcodeDistricts, 'OpenAPI\Server\Model\RequestTimeFilterPostcodeDistricts', $inputFormat);
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("OpenAPI\Server\Model\RequestTimeFilterPostcodeDistricts");
        $asserts[] = new Assert\Valid();
        $response = $this->validate($requestTimeFilterPostcodeDistricts, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'ApiKey'
            $handler->setApiKey($securityApiKey);
            // Set authentication method 'ApplicationId'
            $handler->setApplicationId($securityApplicationId);
            
            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];
            $result = $handler->timeFilterPostcodeDistricts($requestTimeFilterPostcodeDistricts, $responseCode, $responseHeaders);

            // Find default response message
            $message = 'Find districts that have a certain coverage from origin and get statistics about postcodes within such districts. [Docs link](http://docs.traveltimeplatform.com/reference/postcode-district-filter/)';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 200:
                    $message = 'Find districts that have a certain coverage from origin and get statistics about postcodes within such districts. [Docs link](http://docs.traveltimeplatform.com/reference/postcode-district-filter/)';
                    break;
                case 0:
                    $message = 'The json body returned upon error. [Docs link](http://docs.traveltimeplatform.com/reference/error-response)';
                    break;
            }

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation timeFilterPostcodeSectors
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function timeFilterPostcodeSectorsAction(Request $request)
    {
        // Make sure that the client is providing something that we can consume
        $consumes = ['application/json'];
        $inputFormat = $request->headers->has('Content-Type')?$request->headers->get('Content-Type'):$consumes[0];
        if (!in_array($inputFormat, $consumes)) {
            // We can't consume the content that the client is sending us
            return new Response('', 415);
        }

        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'ApiKey' required
        // Set key with prefix in header
        $securityApiKey = $request->headers->get('X-Api-Key');
        // Authentication 'ApplicationId' required
        // Set key with prefix in header
        $securityApplicationId = $request->headers->get('X-Application-Id');

        // Read out all input parameter values into variables
        $requestTimeFilterPostcodeSectors = $request->getContent();

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $requestTimeFilterPostcodeSectors = $this->deserialize($requestTimeFilterPostcodeSectors, 'OpenAPI\Server\Model\RequestTimeFilterPostcodeSectors', $inputFormat);
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("OpenAPI\Server\Model\RequestTimeFilterPostcodeSectors");
        $asserts[] = new Assert\Valid();
        $response = $this->validate($requestTimeFilterPostcodeSectors, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'ApiKey'
            $handler->setApiKey($securityApiKey);
            // Set authentication method 'ApplicationId'
            $handler->setApplicationId($securityApplicationId);
            
            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];
            $result = $handler->timeFilterPostcodeSectors($requestTimeFilterPostcodeSectors, $responseCode, $responseHeaders);

            // Find default response message
            $message = 'Find sectors that have a certain coverage from origin and get statistics about postcodes within such sectors. [Docs link](http://docs.traveltimeplatform.com/reference/postcode-sector-filter/)';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 200:
                    $message = 'Find sectors that have a certain coverage from origin and get statistics about postcodes within such sectors. [Docs link](http://docs.traveltimeplatform.com/reference/postcode-sector-filter/)';
                    break;
                case 0:
                    $message = 'The json body returned upon error. [Docs link](http://docs.traveltimeplatform.com/reference/error-response)';
                    break;
            }

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation timeFilterPostcodes
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function timeFilterPostcodesAction(Request $request)
    {
        // Make sure that the client is providing something that we can consume
        $consumes = ['application/json'];
        $inputFormat = $request->headers->has('Content-Type')?$request->headers->get('Content-Type'):$consumes[0];
        if (!in_array($inputFormat, $consumes)) {
            // We can't consume the content that the client is sending us
            return new Response('', 415);
        }

        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'ApiKey' required
        // Set key with prefix in header
        $securityApiKey = $request->headers->get('X-Api-Key');
        // Authentication 'ApplicationId' required
        // Set key with prefix in header
        $securityApplicationId = $request->headers->get('X-Application-Id');

        // Read out all input parameter values into variables
        $requestTimeFilterPostcodes = $request->getContent();

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $requestTimeFilterPostcodes = $this->deserialize($requestTimeFilterPostcodes, 'OpenAPI\Server\Model\RequestTimeFilterPostcodes', $inputFormat);
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("OpenAPI\Server\Model\RequestTimeFilterPostcodes");
        $asserts[] = new Assert\Valid();
        $response = $this->validate($requestTimeFilterPostcodes, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'ApiKey'
            $handler->setApiKey($securityApiKey);
            // Set authentication method 'ApplicationId'
            $handler->setApplicationId($securityApplicationId);
            
            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];
            $result = $handler->timeFilterPostcodes($requestTimeFilterPostcodes, $responseCode, $responseHeaders);

            // Find default response message
            $message = 'Find reachable postcodes from origin and get statistics about such postcodes. [Docs link](http://docs.traveltimeplatform.com/reference/postcode-search/)';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 200:
                    $message = 'Find reachable postcodes from origin and get statistics about such postcodes. [Docs link](http://docs.traveltimeplatform.com/reference/postcode-search/)';
                    break;
                case 0:
                    $message = 'The json body returned upon error. [Docs link](http://docs.traveltimeplatform.com/reference/error-response)';
                    break;
            }

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation timeMap
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function timeMapAction(Request $request)
    {
        // Make sure that the client is providing something that we can consume
        $consumes = ['application/json'];
        $inputFormat = $request->headers->has('Content-Type')?$request->headers->get('Content-Type'):$consumes[0];
        if (!in_array($inputFormat, $consumes)) {
            // We can't consume the content that the client is sending us
            return new Response('', 415);
        }

        // Figure out what data format to return to the client
        $produces = ['application/json', 'application/vnd.wkt+json', 'application/vnd.wkt-no-holes+json', 'application/vnd.bounding-boxes+json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'ApiKey' required
        // Set key with prefix in header
        $securityApiKey = $request->headers->get('X-Api-Key');
        // Authentication 'ApplicationId' required
        // Set key with prefix in header
        $securityApplicationId = $request->headers->get('X-Application-Id');

        // Read out all input parameter values into variables
        $requestTimeMap = $request->getContent();

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $requestTimeMap = $this->deserialize($requestTimeMap, 'OpenAPI\Server\Model\RequestTimeMap', $inputFormat);
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("OpenAPI\Server\Model\RequestTimeMap");
        $asserts[] = new Assert\Valid();
        $response = $this->validate($requestTimeMap, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'ApiKey'
            $handler->setApiKey($securityApiKey);
            // Set authentication method 'ApplicationId'
            $handler->setApplicationId($securityApplicationId);
            
            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];
            $result = $handler->timeMap($requestTimeMap, $responseCode, $responseHeaders);

            // Find default response message
            $message = 'Given origin coordinates, find shapes of zones reachable within corresponding travel time. [Docs link](http://docs.traveltimeplatform.com/reference/time-map/)';

            // Find a more specific message, if available
            switch ($responseCode) {
                case 200:
                    $message = 'Given origin coordinates, find shapes of zones reachable within corresponding travel time. [Docs link](http://docs.traveltimeplatform.com/reference/time-map/)';
                    break;
                case 0:
                    $message = 'The json body returned upon error. [Docs link](http://docs.traveltimeplatform.com/reference/error-response)';
                    break;
            }

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (Exception $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Returns the handler for this API controller.
     * @return DefaultApiInterface
     */
    public function getApiHandler()
    {
        return $this->apiServer->getApiHandler('default');
    }
}
