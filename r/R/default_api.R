# TravelTime API
#
# No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
#
# The version of the OpenAPI document: 1.2.2
# Contact: support@igeolise.com
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title Default operations
#' @description openapi.Default
#' @format An \code{R6Class} generator object
#' @field apiClient Handles the client-server communication.
#'
#' @section Methods:
#' \describe{
#' \strong{ GeocodingReverseSearch } \emph{  }
#' 
#'
#' \itemize{
#' \item \emph{ @param } lat numeric
#' \item \emph{ @param } lng numeric
#' \item \emph{ @param } within.country character
#' \item \emph{ @returnType } \link{ResponseGeocoding} \cr
#'
#'
#' \item status code : 200 | Match a query string to geographic coordinates. [Docs link](http://docs.traveltime.com/reference/geocoding-search/)
#'
#' \item return type : ResponseGeocoding 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | The json body returned upon error. [Docs link](http://docs.traveltime.com/reference/error-response)
#'
#' \item return type : ResponseError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GeocodingSearch } \emph{  }
#' 
#'
#' \itemize{
#' \item \emph{ @param } query character
#' \item \emph{ @param } focus.lat numeric
#' \item \emph{ @param } focus.lng numeric
#' \item \emph{ @param } within.country character
#' \item \emph{ @returnType } \link{ResponseGeocoding} \cr
#'
#'
#' \item status code : 200 | Match a query string to geographic coordinates. [Docs link](http://docs.traveltime.com/reference/geocoding-search/)
#'
#' \item return type : ResponseGeocoding 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | The json body returned upon error. [Docs link](http://docs.traveltime.com/reference/error-response)
#'
#' \item return type : ResponseError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ MapInfo } \emph{  }
#' 
#'
#' \itemize{
#' \item \emph{ @returnType } \link{ResponseMapInfo} \cr
#'
#'
#' \item status code : 200 | Returns information about currently supported countries. [Docs link](http://docs.traveltime.com/reference/map-info/)
#'
#' \item return type : ResponseMapInfo 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | The json body returned upon error. [Docs link](http://docs.traveltime.com/reference/error-response)
#'
#' \item return type : ResponseError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ Routes } \emph{  }
#' 
#'
#' \itemize{
#' \item \emph{ @param } request.routes \link{RequestRoutes}
#' \item \emph{ @returnType } \link{ResponseRoutes} \cr
#'
#'
#' \item status code : 200 | Returns routing information between source and destinations. [Docs link](http://docs.traveltime.com/reference/routes/)
#'
#' \item return type : ResponseRoutes 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | The json body returned upon error. [Docs link](http://docs.traveltime.com/reference/error-response)
#'
#' \item return type : ResponseError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ SupportedLocations } \emph{  }
#' 
#'
#' \itemize{
#' \item \emph{ @param } request.supported.locations \link{RequestSupportedLocations}
#' \item \emph{ @returnType } \link{ResponseSupportedLocations} \cr
#'
#'
#' \item status code : 200 | Find out what points are supported by our api. [Docs link](http://docs.traveltime.com/reference/supported-locations/)
#'
#' \item return type : ResponseSupportedLocations 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | The json body returned upon error. [Docs link](http://docs.traveltime.com/reference/error-response)
#'
#' \item return type : ResponseError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ TimeFilter } \emph{  }
#' 
#'
#' \itemize{
#' \item \emph{ @param } request.time.filter \link{RequestTimeFilter}
#' \item \emph{ @returnType } \link{ResponseTimeFilter} \cr
#'
#'
#' \item status code : 200 | Given origin and destination points filter out points that cannot be reached within specified time limit. [Docs link](http://docs.traveltime.com/reference/time-filter)
#'
#' \item return type : ResponseTimeFilter 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | The json body returned upon error. [Docs link](http://docs.traveltime.com/reference/error-response)
#'
#' \item return type : ResponseError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ TimeFilterFast } \emph{  }
#' 
#'
#' \itemize{
#' \item \emph{ @param } request.time.filter.fast \link{RequestTimeFilterFast}
#' \item \emph{ @returnType } \link{ResponseTimeFilterFast} \cr
#'
#'
#' \item status code : 200 | A very fast version of Time Filter. [Docs link](http://docs.traveltime.com/reference/time-filter-fast/)
#'
#' \item return type : ResponseTimeFilterFast 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | The json body returned upon error. [Docs link](http://docs.traveltime.com/reference/error-response)
#'
#' \item return type : ResponseError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ TimeFilterPostcodeDistricts } \emph{  }
#' 
#'
#' \itemize{
#' \item \emph{ @param } request.time.filter.postcode.districts \link{RequestTimeFilterPostcodeDistricts}
#' \item \emph{ @returnType } \link{ResponseTimeFilterPostcodeDistricts} \cr
#'
#'
#' \item status code : 200 | Find districts that have a certain coverage from origin and get statistics about postcodes within such districts. [Docs link](http://docs.traveltime.com/reference/postcode-district-filter/)
#'
#' \item return type : ResponseTimeFilterPostcodeDistricts 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | The json body returned upon error. [Docs link](http://docs.traveltime.com/reference/error-response)
#'
#' \item return type : ResponseError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ TimeFilterPostcodeSectors } \emph{  }
#' 
#'
#' \itemize{
#' \item \emph{ @param } request.time.filter.postcode.sectors \link{RequestTimeFilterPostcodeSectors}
#' \item \emph{ @returnType } \link{ResponseTimeFilterPostcodeSectors} \cr
#'
#'
#' \item status code : 200 | Find sectors that have a certain coverage from origin and get statistics about postcodes within such sectors. [Docs link](http://docs.traveltime.com/reference/postcode-sector-filter/)
#'
#' \item return type : ResponseTimeFilterPostcodeSectors 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | The json body returned upon error. [Docs link](http://docs.traveltime.com/reference/error-response)
#'
#' \item return type : ResponseError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ TimeFilterPostcodes } \emph{  }
#' 
#'
#' \itemize{
#' \item \emph{ @param } request.time.filter.postcodes \link{RequestTimeFilterPostcodes}
#' \item \emph{ @returnType } \link{ResponseTimeFilterPostcodes} \cr
#'
#'
#' \item status code : 200 | Find reachable postcodes from origin and get statistics about such postcodes. [Docs link](http://docs.traveltime.com/reference/postcode-search/)
#'
#' \item return type : ResponseTimeFilterPostcodes 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | The json body returned upon error. [Docs link](http://docs.traveltime.com/reference/error-response)
#'
#' \item return type : ResponseError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ TimeMap } \emph{  }
#' 
#'
#' \itemize{
#' \item \emph{ @param } request.time.map \link{RequestTimeMap}
#' \item \emph{ @returnType } \link{ResponseTimeMap} \cr
#'
#'
#' \item status code : 200 | Given origin coordinates, find shapes of zones reachable within corresponding travel time. [Docs link](http://docs.traveltime.com/reference/time-map/)
#'
#' \item return type : ResponseTimeMap 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 0 | The json body returned upon error. [Docs link](http://docs.traveltime.com/reference/error-response)
#'
#' \item return type : ResponseError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' }
#'
#'
#' @examples
#' \dontrun{
#' ####################  GeocodingReverseSearch  ####################
#'
#' library(openapi)
#' var.lat <- 3.4 # numeric | 
#' var.lng <- 3.4 # numeric | 
#' var.within.country <- 'within.country_example' # character | 
#'
#' api.instance <- DefaultApi$new()
#'
#' #Configure API key authorization: ApiKey
#' api.instance$apiClient$apiKeys['X-Api-Key'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure API key authorization: ApplicationId
#' api.instance$apiClient$apiKeys['X-Application-Id'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$GeocodingReverseSearch(var.lat, var.lng, within.country=var.within.country)
#'
#'
#' ####################  GeocodingSearch  ####################
#'
#' library(openapi)
#' var.query <- 'query_example' # character | 
#' var.focus.lat <- 3.4 # numeric | 
#' var.focus.lng <- 3.4 # numeric | 
#' var.within.country <- 'within.country_example' # character | 
#'
#' api.instance <- DefaultApi$new()
#'
#' #Configure API key authorization: ApiKey
#' api.instance$apiClient$apiKeys['X-Api-Key'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure API key authorization: ApplicationId
#' api.instance$apiClient$apiKeys['X-Application-Id'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$GeocodingSearch(var.query, focus.lat=var.focus.lat, focus.lng=var.focus.lng, within.country=var.within.country)
#'
#'
#' ####################  MapInfo  ####################
#'
#' library(openapi)
#'
#' api.instance <- DefaultApi$new()
#'
#' #Configure API key authorization: ApiKey
#' api.instance$apiClient$apiKeys['X-Api-Key'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure API key authorization: ApplicationId
#' api.instance$apiClient$apiKeys['X-Application-Id'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$MapInfo()
#'
#'
#' ####################  Routes  ####################
#'
#' library(openapi)
#' var.request.routes <- RequestRoutes$new() # RequestRoutes | 
#'
#' api.instance <- DefaultApi$new()
#'
#' #Configure API key authorization: ApiKey
#' api.instance$apiClient$apiKeys['X-Api-Key'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure API key authorization: ApplicationId
#' api.instance$apiClient$apiKeys['X-Application-Id'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$Routes(var.request.routes)
#'
#'
#' ####################  SupportedLocations  ####################
#'
#' library(openapi)
#' var.request.supported.locations <- RequestSupportedLocations$new() # RequestSupportedLocations | 
#'
#' api.instance <- DefaultApi$new()
#'
#' #Configure API key authorization: ApiKey
#' api.instance$apiClient$apiKeys['X-Api-Key'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure API key authorization: ApplicationId
#' api.instance$apiClient$apiKeys['X-Application-Id'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$SupportedLocations(var.request.supported.locations)
#'
#'
#' ####################  TimeFilter  ####################
#'
#' library(openapi)
#' var.request.time.filter <- RequestTimeFilter$new() # RequestTimeFilter | 
#'
#' api.instance <- DefaultApi$new()
#'
#' #Configure API key authorization: ApiKey
#' api.instance$apiClient$apiKeys['X-Api-Key'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure API key authorization: ApplicationId
#' api.instance$apiClient$apiKeys['X-Application-Id'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$TimeFilter(var.request.time.filter)
#'
#'
#' ####################  TimeFilterFast  ####################
#'
#' library(openapi)
#' var.request.time.filter.fast <- RequestTimeFilterFast$new() # RequestTimeFilterFast | 
#'
#' api.instance <- DefaultApi$new()
#'
#' #Configure API key authorization: ApiKey
#' api.instance$apiClient$apiKeys['X-Api-Key'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure API key authorization: ApplicationId
#' api.instance$apiClient$apiKeys['X-Application-Id'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$TimeFilterFast(var.request.time.filter.fast)
#'
#'
#' ####################  TimeFilterPostcodeDistricts  ####################
#'
#' library(openapi)
#' var.request.time.filter.postcode.districts <- RequestTimeFilterPostcodeDistricts$new() # RequestTimeFilterPostcodeDistricts | 
#'
#' api.instance <- DefaultApi$new()
#'
#' #Configure API key authorization: ApiKey
#' api.instance$apiClient$apiKeys['X-Api-Key'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure API key authorization: ApplicationId
#' api.instance$apiClient$apiKeys['X-Application-Id'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$TimeFilterPostcodeDistricts(var.request.time.filter.postcode.districts)
#'
#'
#' ####################  TimeFilterPostcodeSectors  ####################
#'
#' library(openapi)
#' var.request.time.filter.postcode.sectors <- RequestTimeFilterPostcodeSectors$new() # RequestTimeFilterPostcodeSectors | 
#'
#' api.instance <- DefaultApi$new()
#'
#' #Configure API key authorization: ApiKey
#' api.instance$apiClient$apiKeys['X-Api-Key'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure API key authorization: ApplicationId
#' api.instance$apiClient$apiKeys['X-Application-Id'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$TimeFilterPostcodeSectors(var.request.time.filter.postcode.sectors)
#'
#'
#' ####################  TimeFilterPostcodes  ####################
#'
#' library(openapi)
#' var.request.time.filter.postcodes <- RequestTimeFilterPostcodes$new() # RequestTimeFilterPostcodes | 
#'
#' api.instance <- DefaultApi$new()
#'
#' #Configure API key authorization: ApiKey
#' api.instance$apiClient$apiKeys['X-Api-Key'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure API key authorization: ApplicationId
#' api.instance$apiClient$apiKeys['X-Application-Id'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$TimeFilterPostcodes(var.request.time.filter.postcodes)
#'
#'
#' ####################  TimeMap  ####################
#'
#' library(openapi)
#' var.request.time.map <- RequestTimeMap$new() # RequestTimeMap | 
#'
#' api.instance <- DefaultApi$new()
#'
#' #Configure API key authorization: ApiKey
#' api.instance$apiClient$apiKeys['X-Api-Key'] <- 'TODO_YOUR_API_KEY';
#'
#' #Configure API key authorization: ApplicationId
#' api.instance$apiClient$apiKeys['X-Application-Id'] <- 'TODO_YOUR_API_KEY';
#'
#' result <- api.instance$TimeMap(var.request.time.map)
#'
#'
#' }
#' @importFrom R6 R6Class
#' @importFrom base64enc base64encode
#' @export
DefaultApi <- R6::R6Class(
  'DefaultApi',
  public = list(
    apiClient = NULL,
    initialize = function(apiClient){
      if (!missing(apiClient)) {
        self$apiClient <- apiClient
      }
      else {
        self$apiClient <- ApiClient$new()
      }
    },
    GeocodingReverseSearch = function(lat, lng, within.country=NULL, ...){
      apiResponse <- self$GeocodingReverseSearchWithHttpInfo(lat, lng, within.country, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GeocodingReverseSearchWithHttpInfo = function(lat, lng, within.country=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`lat`)) {
        stop("Missing required parameter `lat`.")
      }

      if (missing(`lng`)) {
        stop("Missing required parameter `lng`.")
      }

      queryParams['lat'] <- lat

      queryParams['lng'] <- lng

      queryParams['within.country'] <- within.country

      body <- NULL
      urlPath <- "/v4/geocoding/reverse"
      # API key authentication
      if ("X-Api-Key" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-Api-Key"]) > 0) {
        headerParams['X-Api-Key'] <- paste(unlist(self$apiClient$apiKeys["X-Api-Key"]), collapse='')
      }
      # API key authentication
      if ("X-Application-Id" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-Application-Id"]) > 0) {
        headerParams['X-Application-Id'] <- paste(unlist(self$apiClient$apiKeys["X-Application-Id"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "ResponseGeocoding", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GeocodingSearch = function(query, focus.lat=NULL, focus.lng=NULL, within.country=NULL, ...){
      apiResponse <- self$GeocodingSearchWithHttpInfo(query, focus.lat, focus.lng, within.country, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GeocodingSearchWithHttpInfo = function(query, focus.lat=NULL, focus.lng=NULL, within.country=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`query`)) {
        stop("Missing required parameter `query`.")
      }

      queryParams['query'] <- query

      queryParams['focus.lat'] <- focus.lat

      queryParams['focus.lng'] <- focus.lng

      queryParams['within.country'] <- within.country

      body <- NULL
      urlPath <- "/v4/geocoding/search"
      # API key authentication
      if ("X-Api-Key" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-Api-Key"]) > 0) {
        headerParams['X-Api-Key'] <- paste(unlist(self$apiClient$apiKeys["X-Api-Key"]), collapse='')
      }
      # API key authentication
      if ("X-Application-Id" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-Application-Id"]) > 0) {
        headerParams['X-Application-Id'] <- paste(unlist(self$apiClient$apiKeys["X-Application-Id"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "ResponseGeocoding", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    MapInfo = function(...){
      apiResponse <- self$MapInfoWithHttpInfo(...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    MapInfoWithHttpInfo = function(...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      body <- NULL
      urlPath <- "/v4/map-info"
      # API key authentication
      if ("X-Api-Key" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-Api-Key"]) > 0) {
        headerParams['X-Api-Key'] <- paste(unlist(self$apiClient$apiKeys["X-Api-Key"]), collapse='')
      }
      # API key authentication
      if ("X-Application-Id" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-Application-Id"]) > 0) {
        headerParams['X-Application-Id'] <- paste(unlist(self$apiClient$apiKeys["X-Application-Id"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "ResponseMapInfo", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    Routes = function(request.routes, ...){
      apiResponse <- self$RoutesWithHttpInfo(request.routes, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    RoutesWithHttpInfo = function(request.routes, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`request.routes`)) {
        stop("Missing required parameter `request.routes`.")
      }

      if (!missing(`request.routes`)) {
        body <- `request.routes`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/v4/routes"
      # API key authentication
      if ("X-Api-Key" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-Api-Key"]) > 0) {
        headerParams['X-Api-Key'] <- paste(unlist(self$apiClient$apiKeys["X-Api-Key"]), collapse='')
      }
      # API key authentication
      if ("X-Application-Id" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-Application-Id"]) > 0) {
        headerParams['X-Application-Id'] <- paste(unlist(self$apiClient$apiKeys["X-Application-Id"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "ResponseRoutes", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    SupportedLocations = function(request.supported.locations, ...){
      apiResponse <- self$SupportedLocationsWithHttpInfo(request.supported.locations, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    SupportedLocationsWithHttpInfo = function(request.supported.locations, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`request.supported.locations`)) {
        stop("Missing required parameter `request.supported.locations`.")
      }

      if (!missing(`request.supported.locations`)) {
        body <- `request.supported.locations`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/v4/supported-locations"
      # API key authentication
      if ("X-Api-Key" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-Api-Key"]) > 0) {
        headerParams['X-Api-Key'] <- paste(unlist(self$apiClient$apiKeys["X-Api-Key"]), collapse='')
      }
      # API key authentication
      if ("X-Application-Id" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-Application-Id"]) > 0) {
        headerParams['X-Application-Id'] <- paste(unlist(self$apiClient$apiKeys["X-Application-Id"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "ResponseSupportedLocations", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    TimeFilter = function(request.time.filter, ...){
      apiResponse <- self$TimeFilterWithHttpInfo(request.time.filter, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    TimeFilterWithHttpInfo = function(request.time.filter, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`request.time.filter`)) {
        stop("Missing required parameter `request.time.filter`.")
      }

      if (!missing(`request.time.filter`)) {
        body <- `request.time.filter`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/v4/time-filter"
      # API key authentication
      if ("X-Api-Key" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-Api-Key"]) > 0) {
        headerParams['X-Api-Key'] <- paste(unlist(self$apiClient$apiKeys["X-Api-Key"]), collapse='')
      }
      # API key authentication
      if ("X-Application-Id" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-Application-Id"]) > 0) {
        headerParams['X-Application-Id'] <- paste(unlist(self$apiClient$apiKeys["X-Application-Id"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "ResponseTimeFilter", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    TimeFilterFast = function(request.time.filter.fast, ...){
      apiResponse <- self$TimeFilterFastWithHttpInfo(request.time.filter.fast, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    TimeFilterFastWithHttpInfo = function(request.time.filter.fast, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`request.time.filter.fast`)) {
        stop("Missing required parameter `request.time.filter.fast`.")
      }

      if (!missing(`request.time.filter.fast`)) {
        body <- `request.time.filter.fast`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/v4/time-filter/fast"
      # API key authentication
      if ("X-Api-Key" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-Api-Key"]) > 0) {
        headerParams['X-Api-Key'] <- paste(unlist(self$apiClient$apiKeys["X-Api-Key"]), collapse='')
      }
      # API key authentication
      if ("X-Application-Id" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-Application-Id"]) > 0) {
        headerParams['X-Application-Id'] <- paste(unlist(self$apiClient$apiKeys["X-Application-Id"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "ResponseTimeFilterFast", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    TimeFilterPostcodeDistricts = function(request.time.filter.postcode.districts, ...){
      apiResponse <- self$TimeFilterPostcodeDistrictsWithHttpInfo(request.time.filter.postcode.districts, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    TimeFilterPostcodeDistrictsWithHttpInfo = function(request.time.filter.postcode.districts, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`request.time.filter.postcode.districts`)) {
        stop("Missing required parameter `request.time.filter.postcode.districts`.")
      }

      if (!missing(`request.time.filter.postcode.districts`)) {
        body <- `request.time.filter.postcode.districts`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/v4/time-filter/postcode-districts"
      # API key authentication
      if ("X-Api-Key" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-Api-Key"]) > 0) {
        headerParams['X-Api-Key'] <- paste(unlist(self$apiClient$apiKeys["X-Api-Key"]), collapse='')
      }
      # API key authentication
      if ("X-Application-Id" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-Application-Id"]) > 0) {
        headerParams['X-Application-Id'] <- paste(unlist(self$apiClient$apiKeys["X-Application-Id"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "ResponseTimeFilterPostcodeDistricts", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    TimeFilterPostcodeSectors = function(request.time.filter.postcode.sectors, ...){
      apiResponse <- self$TimeFilterPostcodeSectorsWithHttpInfo(request.time.filter.postcode.sectors, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    TimeFilterPostcodeSectorsWithHttpInfo = function(request.time.filter.postcode.sectors, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`request.time.filter.postcode.sectors`)) {
        stop("Missing required parameter `request.time.filter.postcode.sectors`.")
      }

      if (!missing(`request.time.filter.postcode.sectors`)) {
        body <- `request.time.filter.postcode.sectors`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/v4/time-filter/postcode-sectors"
      # API key authentication
      if ("X-Api-Key" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-Api-Key"]) > 0) {
        headerParams['X-Api-Key'] <- paste(unlist(self$apiClient$apiKeys["X-Api-Key"]), collapse='')
      }
      # API key authentication
      if ("X-Application-Id" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-Application-Id"]) > 0) {
        headerParams['X-Application-Id'] <- paste(unlist(self$apiClient$apiKeys["X-Application-Id"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "ResponseTimeFilterPostcodeSectors", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    TimeFilterPostcodes = function(request.time.filter.postcodes, ...){
      apiResponse <- self$TimeFilterPostcodesWithHttpInfo(request.time.filter.postcodes, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    TimeFilterPostcodesWithHttpInfo = function(request.time.filter.postcodes, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`request.time.filter.postcodes`)) {
        stop("Missing required parameter `request.time.filter.postcodes`.")
      }

      if (!missing(`request.time.filter.postcodes`)) {
        body <- `request.time.filter.postcodes`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/v4/time-filter/postcodes"
      # API key authentication
      if ("X-Api-Key" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-Api-Key"]) > 0) {
        headerParams['X-Api-Key'] <- paste(unlist(self$apiClient$apiKeys["X-Api-Key"]), collapse='')
      }
      # API key authentication
      if ("X-Application-Id" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-Application-Id"]) > 0) {
        headerParams['X-Application-Id'] <- paste(unlist(self$apiClient$apiKeys["X-Application-Id"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "ResponseTimeFilterPostcodes", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    TimeMap = function(request.time.map, ...){
      apiResponse <- self$TimeMapWithHttpInfo(request.time.map, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    TimeMapWithHttpInfo = function(request.time.map, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`request.time.map`)) {
        stop("Missing required parameter `request.time.map`.")
      }

      if (!missing(`request.time.map`)) {
        body <- `request.time.map`$toJSONString()
      } else {
        body <- NULL
      }

      urlPath <- "/v4/time-map"
      # API key authentication
      if ("X-Api-Key" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-Api-Key"]) > 0) {
        headerParams['X-Api-Key'] <- paste(unlist(self$apiClient$apiKeys["X-Api-Key"]), collapse='')
      }
      # API key authentication
      if ("X-Application-Id" %in% names(self$apiClient$apiKeys) && nchar(self$apiClient$apiKeys["X-Application-Id"]) > 0) {
        headerParams['X-Application-Id'] <- paste(unlist(self$apiClient$apiKeys["X-Application-Id"]), collapse='')
      }

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "POST",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "ResponseTimeMap", loadNamespace("openapi")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    }
  )
)
