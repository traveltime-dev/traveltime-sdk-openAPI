/**
 * TravelTime API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.2.3
 * Contact: support@igeolise.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { autoinject } from 'aurelia-framework';
import { HttpClient } from 'aurelia-http-client';
import { Api } from './Api';
import { AuthStorage } from './AuthStorage';
import {
  RequestSupportedLocations,
  ResponseTimeFilterPostcodeSectors,
  ResponseSupportedLocations,
  RequestTimeFilter,
  ResponseTimeFilterPostcodeDistricts,
  RequestTimeFilterPostcodeSectors,
  ResponseTimeFilterPostcodes,
  ResponseGeocoding,
  RequestTimeMap,
  ResponseMapInfo,
  RequestRoutes,
  ResponseTimeFilter,
  RequestTimeFilterPostcodes,
  RequestTimeFilterFast,
  RequestTimeFilterPostcodeDistricts,
  ResponseTimeMap,
  ResponseRoutes,
  ResponseTimeFilterFast,
} from './models';

/**
 * geocodingReverseSearch - parameters interface
 */
export interface IGeocodingReverseSearchParams {
  lat: number;
  lng: number;
  withinCountry?: string;
}

/**
 * geocodingSearch - parameters interface
 */
export interface IGeocodingSearchParams {
  query: string;
  focusLat?: number;
  focusLng?: number;
  withinCountry?: string;
}

/**
 * mapInfo - parameters interface
 */
export interface IMapInfoParams {
}

/**
 * routes - parameters interface
 */
export interface IRoutesParams {
  requestRoutes: RequestRoutes;
}

/**
 * supportedLocations - parameters interface
 */
export interface ISupportedLocationsParams {
  requestSupportedLocations: RequestSupportedLocations;
}

/**
 * timeFilter - parameters interface
 */
export interface ITimeFilterParams {
  requestTimeFilter: RequestTimeFilter;
}

/**
 * timeFilterFast - parameters interface
 */
export interface ITimeFilterFastParams {
  requestTimeFilterFast: RequestTimeFilterFast;
}

/**
 * timeFilterPostcodeDistricts - parameters interface
 */
export interface ITimeFilterPostcodeDistrictsParams {
  requestTimeFilterPostcodeDistricts: RequestTimeFilterPostcodeDistricts;
}

/**
 * timeFilterPostcodeSectors - parameters interface
 */
export interface ITimeFilterPostcodeSectorsParams {
  requestTimeFilterPostcodeSectors: RequestTimeFilterPostcodeSectors;
}

/**
 * timeFilterPostcodes - parameters interface
 */
export interface ITimeFilterPostcodesParams {
  requestTimeFilterPostcodes: RequestTimeFilterPostcodes;
}

/**
 * timeMap - parameters interface
 */
export interface ITimeMapParams {
  requestTimeMap: RequestTimeMap;
}

/**
 * DefaultApi - API class
 */
@autoinject()
export class DefaultApi extends Api {

  /**
   * Creates a new DefaultApi class.
   *
   * @param httpClient The Aurelia HTTP client to be injected.
   * @param authStorage A storage for authentication data.
   */
  constructor(httpClient: HttpClient, authStorage: AuthStorage) {
    super(httpClient, authStorage);
  }

  /**
   * @param params.lat 
   * @param params.lng 
   * @param params.withinCountry 
   */
  async geocodingReverseSearch(params: IGeocodingReverseSearchParams): Promise<ResponseGeocoding> {
    // Verify required parameters are set
    this.ensureParamIsSet('geocodingReverseSearch', params, 'lat');
    this.ensureParamIsSet('geocodingReverseSearch', params, 'lng');

    // Create URL to call
    const url = `${this.basePath}/v4/geocoding/reverse`;

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asGet()
      // Set query parameters
      .withParams({ 
        'lat': params['lat'],
        'lng': params['lng'],
        'within.country': params['withinCountry'],
      })

      // Authentication 'ApiKey' required
      .withHeader('X-Api-Key', this.authStorage.getApiKey())
      // Authentication 'ApplicationId' required
      .withHeader('X-Application-Id', this.authStorage.getApplicationId())
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.query 
   * @param params.focusLat 
   * @param params.focusLng 
   * @param params.withinCountry 
   */
  async geocodingSearch(params: IGeocodingSearchParams): Promise<ResponseGeocoding> {
    // Verify required parameters are set
    this.ensureParamIsSet('geocodingSearch', params, 'query');

    // Create URL to call
    const url = `${this.basePath}/v4/geocoding/search`;

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asGet()
      // Set query parameters
      .withParams({ 
        'query': params['query'],
        'focus.lat': params['focusLat'],
        'focus.lng': params['focusLng'],
        'within.country': params['withinCountry'],
      })

      // Authentication 'ApiKey' required
      .withHeader('X-Api-Key', this.authStorage.getApiKey())
      // Authentication 'ApplicationId' required
      .withHeader('X-Application-Id', this.authStorage.getApplicationId())
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   */
  async mapInfo(): Promise<ResponseMapInfo> {
    // Verify required parameters are set

    // Create URL to call
    const url = `${this.basePath}/v4/map-info`;

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asGet()

      // Authentication 'ApiKey' required
      .withHeader('X-Api-Key', this.authStorage.getApiKey())
      // Authentication 'ApplicationId' required
      .withHeader('X-Application-Id', this.authStorage.getApplicationId())
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.requestRoutes 
   */
  async routes(params: IRoutesParams): Promise<ResponseRoutes> {
    // Verify required parameters are set
    this.ensureParamIsSet('routes', params, 'requestRoutes');

    // Create URL to call
    const url = `${this.basePath}/v4/routes`;

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asPost()
      // Encode body parameter
      .withHeader('content-type', 'application/json')
      .withContent(JSON.stringify(params['requestRoutes'] || {}))

      // Authentication 'ApiKey' required
      .withHeader('X-Api-Key', this.authStorage.getApiKey())
      // Authentication 'ApplicationId' required
      .withHeader('X-Application-Id', this.authStorage.getApplicationId())
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.requestSupportedLocations 
   */
  async supportedLocations(params: ISupportedLocationsParams): Promise<ResponseSupportedLocations> {
    // Verify required parameters are set
    this.ensureParamIsSet('supportedLocations', params, 'requestSupportedLocations');

    // Create URL to call
    const url = `${this.basePath}/v4/supported-locations`;

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asPost()
      // Encode body parameter
      .withHeader('content-type', 'application/json')
      .withContent(JSON.stringify(params['requestSupportedLocations'] || {}))

      // Authentication 'ApiKey' required
      .withHeader('X-Api-Key', this.authStorage.getApiKey())
      // Authentication 'ApplicationId' required
      .withHeader('X-Application-Id', this.authStorage.getApplicationId())
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.requestTimeFilter 
   */
  async timeFilter(params: ITimeFilterParams): Promise<ResponseTimeFilter> {
    // Verify required parameters are set
    this.ensureParamIsSet('timeFilter', params, 'requestTimeFilter');

    // Create URL to call
    const url = `${this.basePath}/v4/time-filter`;

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asPost()
      // Encode body parameter
      .withHeader('content-type', 'application/json')
      .withContent(JSON.stringify(params['requestTimeFilter'] || {}))

      // Authentication 'ApiKey' required
      .withHeader('X-Api-Key', this.authStorage.getApiKey())
      // Authentication 'ApplicationId' required
      .withHeader('X-Application-Id', this.authStorage.getApplicationId())
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.requestTimeFilterFast 
   */
  async timeFilterFast(params: ITimeFilterFastParams): Promise<ResponseTimeFilterFast> {
    // Verify required parameters are set
    this.ensureParamIsSet('timeFilterFast', params, 'requestTimeFilterFast');

    // Create URL to call
    const url = `${this.basePath}/v4/time-filter/fast`;

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asPost()
      // Encode body parameter
      .withHeader('content-type', 'application/json')
      .withContent(JSON.stringify(params['requestTimeFilterFast'] || {}))

      // Authentication 'ApiKey' required
      .withHeader('X-Api-Key', this.authStorage.getApiKey())
      // Authentication 'ApplicationId' required
      .withHeader('X-Application-Id', this.authStorage.getApplicationId())
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.requestTimeFilterPostcodeDistricts 
   */
  async timeFilterPostcodeDistricts(params: ITimeFilterPostcodeDistrictsParams): Promise<ResponseTimeFilterPostcodeDistricts> {
    // Verify required parameters are set
    this.ensureParamIsSet('timeFilterPostcodeDistricts', params, 'requestTimeFilterPostcodeDistricts');

    // Create URL to call
    const url = `${this.basePath}/v4/time-filter/postcode-districts`;

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asPost()
      // Encode body parameter
      .withHeader('content-type', 'application/json')
      .withContent(JSON.stringify(params['requestTimeFilterPostcodeDistricts'] || {}))

      // Authentication 'ApiKey' required
      .withHeader('X-Api-Key', this.authStorage.getApiKey())
      // Authentication 'ApplicationId' required
      .withHeader('X-Application-Id', this.authStorage.getApplicationId())
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.requestTimeFilterPostcodeSectors 
   */
  async timeFilterPostcodeSectors(params: ITimeFilterPostcodeSectorsParams): Promise<ResponseTimeFilterPostcodeSectors> {
    // Verify required parameters are set
    this.ensureParamIsSet('timeFilterPostcodeSectors', params, 'requestTimeFilterPostcodeSectors');

    // Create URL to call
    const url = `${this.basePath}/v4/time-filter/postcode-sectors`;

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asPost()
      // Encode body parameter
      .withHeader('content-type', 'application/json')
      .withContent(JSON.stringify(params['requestTimeFilterPostcodeSectors'] || {}))

      // Authentication 'ApiKey' required
      .withHeader('X-Api-Key', this.authStorage.getApiKey())
      // Authentication 'ApplicationId' required
      .withHeader('X-Application-Id', this.authStorage.getApplicationId())
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.requestTimeFilterPostcodes 
   */
  async timeFilterPostcodes(params: ITimeFilterPostcodesParams): Promise<ResponseTimeFilterPostcodes> {
    // Verify required parameters are set
    this.ensureParamIsSet('timeFilterPostcodes', params, 'requestTimeFilterPostcodes');

    // Create URL to call
    const url = `${this.basePath}/v4/time-filter/postcodes`;

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asPost()
      // Encode body parameter
      .withHeader('content-type', 'application/json')
      .withContent(JSON.stringify(params['requestTimeFilterPostcodes'] || {}))

      // Authentication 'ApiKey' required
      .withHeader('X-Api-Key', this.authStorage.getApiKey())
      // Authentication 'ApplicationId' required
      .withHeader('X-Application-Id', this.authStorage.getApplicationId())
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

  /**
   * @param params.requestTimeMap 
   */
  async timeMap(params: ITimeMapParams): Promise<ResponseTimeMap> {
    // Verify required parameters are set
    this.ensureParamIsSet('timeMap', params, 'requestTimeMap');

    // Create URL to call
    const url = `${this.basePath}/v4/time-map`;

    const response = await this.httpClient.createRequest(url)
      // Set HTTP method
      .asPost()
      // Encode body parameter
      .withHeader('content-type', 'application/json')
      .withContent(JSON.stringify(params['requestTimeMap'] || {}))

      // Authentication 'ApiKey' required
      .withHeader('X-Api-Key', this.authStorage.getApiKey())
      // Authentication 'ApplicationId' required
      .withHeader('X-Application-Id', this.authStorage.getApplicationId())
      // Send the request
      .send();

    if (response.statusCode < 200 || response.statusCode >= 300) {
      throw new Error(response.content);
    }

    // Extract the content
    return response.content;
  }

}

