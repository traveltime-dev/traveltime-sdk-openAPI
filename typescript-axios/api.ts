/* tslint:disable */
/* eslint-disable */
/**
 * TravelTime API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.2.2
 * Contact: support@igeolise.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Coords
 */
export interface Coords {
    /**
     * 
     * @type {number}
     * @memberof Coords
     */
    lat: number;
    /**
     * 
     * @type {number}
     * @memberof Coords
     */
    lng: number;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum RequestArrivalTimePeriod {
    WeekdayMorning = 'weekday_morning'
}

/**
 * 
 * @export
 * @interface RequestLocation
 */
export interface RequestLocation {
    /**
     * 
     * @type {string}
     * @memberof RequestLocation
     */
    id: string;
    /**
     * 
     * @type {Coords}
     * @memberof RequestLocation
     */
    coords: Coords;
}
/**
 * 
 * @export
 * @interface RequestRangeFull
 */
export interface RequestRangeFull {
    /**
     * 
     * @type {boolean}
     * @memberof RequestRangeFull
     */
    enabled: boolean;
    /**
     * 
     * @type {number}
     * @memberof RequestRangeFull
     */
    max_results: number;
    /**
     * 
     * @type {number}
     * @memberof RequestRangeFull
     */
    width: number;
}
/**
 * 
 * @export
 * @interface RequestRangeNoMaxResults
 */
export interface RequestRangeNoMaxResults {
    /**
     * 
     * @type {boolean}
     * @memberof RequestRangeNoMaxResults
     */
    enabled: boolean;
    /**
     * 
     * @type {number}
     * @memberof RequestRangeNoMaxResults
     */
    width: number;
}
/**
 * 
 * @export
 * @interface RequestRoutes
 */
export interface RequestRoutes {
    /**
     * 
     * @type {Array<RequestLocation>}
     * @memberof RequestRoutes
     */
    locations: Array<RequestLocation>;
    /**
     * 
     * @type {Array<RequestRoutesDepartureSearch>}
     * @memberof RequestRoutes
     */
    departure_searches?: Array<RequestRoutesDepartureSearch>;
    /**
     * 
     * @type {Array<RequestRoutesArrivalSearch>}
     * @memberof RequestRoutes
     */
    arrival_searches?: Array<RequestRoutesArrivalSearch>;
}
/**
 * 
 * @export
 * @interface RequestRoutesArrivalSearch
 */
export interface RequestRoutesArrivalSearch {
    /**
     * 
     * @type {string}
     * @memberof RequestRoutesArrivalSearch
     */
    id: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RequestRoutesArrivalSearch
     */
    departure_location_ids: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof RequestRoutesArrivalSearch
     */
    arrival_location_id: string;
    /**
     * 
     * @type {RequestTransportation}
     * @memberof RequestRoutesArrivalSearch
     */
    transportation: RequestTransportation;
    /**
     * 
     * @type {string}
     * @memberof RequestRoutesArrivalSearch
     */
    arrival_time: string;
    /**
     * 
     * @type {Array<RequestRoutesProperty>}
     * @memberof RequestRoutesArrivalSearch
     */
    properties: Array<RequestRoutesProperty>;
    /**
     * 
     * @type {RequestRangeFull}
     * @memberof RequestRoutesArrivalSearch
     */
    range?: RequestRangeFull;
}
/**
 * 
 * @export
 * @interface RequestRoutesDepartureSearch
 */
export interface RequestRoutesDepartureSearch {
    /**
     * 
     * @type {string}
     * @memberof RequestRoutesDepartureSearch
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof RequestRoutesDepartureSearch
     */
    departure_location_id: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RequestRoutesDepartureSearch
     */
    arrival_location_ids: Array<string>;
    /**
     * 
     * @type {RequestTransportation}
     * @memberof RequestRoutesDepartureSearch
     */
    transportation: RequestTransportation;
    /**
     * 
     * @type {string}
     * @memberof RequestRoutesDepartureSearch
     */
    departure_time: string;
    /**
     * 
     * @type {Array<RequestRoutesProperty>}
     * @memberof RequestRoutesDepartureSearch
     */
    properties: Array<RequestRoutesProperty>;
    /**
     * 
     * @type {RequestRangeFull}
     * @memberof RequestRoutesDepartureSearch
     */
    range?: RequestRangeFull;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum RequestRoutesProperty {
    TravelTime = 'travel_time',
    Distance = 'distance',
    Fares = 'fares',
    Route = 'route'
}

/**
 * 
 * @export
 * @interface RequestSupportedLocations
 */
export interface RequestSupportedLocations {
    /**
     * 
     * @type {Array<RequestLocation>}
     * @memberof RequestSupportedLocations
     */
    locations: Array<RequestLocation>;
}
/**
 * 
 * @export
 * @interface RequestTimeFilter
 */
export interface RequestTimeFilter {
    /**
     * 
     * @type {Array<RequestLocation>}
     * @memberof RequestTimeFilter
     */
    locations: Array<RequestLocation>;
    /**
     * 
     * @type {Array<RequestTimeFilterDepartureSearch>}
     * @memberof RequestTimeFilter
     */
    departure_searches?: Array<RequestTimeFilterDepartureSearch>;
    /**
     * 
     * @type {Array<RequestTimeFilterArrivalSearch>}
     * @memberof RequestTimeFilter
     */
    arrival_searches?: Array<RequestTimeFilterArrivalSearch>;
}
/**
 * 
 * @export
 * @interface RequestTimeFilterArrivalSearch
 */
export interface RequestTimeFilterArrivalSearch {
    /**
     * 
     * @type {string}
     * @memberof RequestTimeFilterArrivalSearch
     */
    id: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RequestTimeFilterArrivalSearch
     */
    departure_location_ids: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof RequestTimeFilterArrivalSearch
     */
    arrival_location_id: string;
    /**
     * 
     * @type {RequestTransportation}
     * @memberof RequestTimeFilterArrivalSearch
     */
    transportation: RequestTransportation;
    /**
     * 
     * @type {number}
     * @memberof RequestTimeFilterArrivalSearch
     */
    travel_time: number;
    /**
     * 
     * @type {string}
     * @memberof RequestTimeFilterArrivalSearch
     */
    arrival_time: string;
    /**
     * 
     * @type {Array<RequestTimeFilterProperty>}
     * @memberof RequestTimeFilterArrivalSearch
     */
    properties: Array<RequestTimeFilterProperty>;
    /**
     * 
     * @type {RequestRangeFull}
     * @memberof RequestTimeFilterArrivalSearch
     */
    range?: RequestRangeFull;
}
/**
 * 
 * @export
 * @interface RequestTimeFilterDepartureSearch
 */
export interface RequestTimeFilterDepartureSearch {
    /**
     * 
     * @type {string}
     * @memberof RequestTimeFilterDepartureSearch
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof RequestTimeFilterDepartureSearch
     */
    departure_location_id: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RequestTimeFilterDepartureSearch
     */
    arrival_location_ids: Array<string>;
    /**
     * 
     * @type {RequestTransportation}
     * @memberof RequestTimeFilterDepartureSearch
     */
    transportation: RequestTransportation;
    /**
     * 
     * @type {number}
     * @memberof RequestTimeFilterDepartureSearch
     */
    travel_time: number;
    /**
     * 
     * @type {string}
     * @memberof RequestTimeFilterDepartureSearch
     */
    departure_time: string;
    /**
     * 
     * @type {Array<RequestTimeFilterProperty>}
     * @memberof RequestTimeFilterDepartureSearch
     */
    properties: Array<RequestTimeFilterProperty>;
    /**
     * 
     * @type {RequestRangeFull}
     * @memberof RequestTimeFilterDepartureSearch
     */
    range?: RequestRangeFull;
}
/**
 * 
 * @export
 * @interface RequestTimeFilterFast
 */
export interface RequestTimeFilterFast {
    /**
     * 
     * @type {Array<RequestLocation>}
     * @memberof RequestTimeFilterFast
     */
    locations: Array<RequestLocation>;
    /**
     * 
     * @type {RequestTimeFilterFastArrivalSearches}
     * @memberof RequestTimeFilterFast
     */
    arrival_searches: RequestTimeFilterFastArrivalSearches;
}
/**
 * 
 * @export
 * @interface RequestTimeFilterFastArrivalManyToOneSearch
 */
export interface RequestTimeFilterFastArrivalManyToOneSearch {
    /**
     * 
     * @type {string}
     * @memberof RequestTimeFilterFastArrivalManyToOneSearch
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof RequestTimeFilterFastArrivalManyToOneSearch
     */
    arrival_location_id: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RequestTimeFilterFastArrivalManyToOneSearch
     */
    departure_location_ids: Array<string>;
    /**
     * 
     * @type {RequestTransportationFast}
     * @memberof RequestTimeFilterFastArrivalManyToOneSearch
     */
    transportation: RequestTransportationFast;
    /**
     * 
     * @type {number}
     * @memberof RequestTimeFilterFastArrivalManyToOneSearch
     */
    travel_time: number;
    /**
     * 
     * @type {RequestArrivalTimePeriod}
     * @memberof RequestTimeFilterFastArrivalManyToOneSearch
     */
    arrival_time_period: RequestArrivalTimePeriod;
    /**
     * 
     * @type {Array<RequestTimeFilterFastProperty>}
     * @memberof RequestTimeFilterFastArrivalManyToOneSearch
     */
    properties: Array<RequestTimeFilterFastProperty>;
}
/**
 * 
 * @export
 * @interface RequestTimeFilterFastArrivalOneToManySearch
 */
export interface RequestTimeFilterFastArrivalOneToManySearch {
    /**
     * 
     * @type {string}
     * @memberof RequestTimeFilterFastArrivalOneToManySearch
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof RequestTimeFilterFastArrivalOneToManySearch
     */
    departure_location_id: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RequestTimeFilterFastArrivalOneToManySearch
     */
    arrival_location_ids: Array<string>;
    /**
     * 
     * @type {RequestTransportationFast}
     * @memberof RequestTimeFilterFastArrivalOneToManySearch
     */
    transportation: RequestTransportationFast;
    /**
     * 
     * @type {number}
     * @memberof RequestTimeFilterFastArrivalOneToManySearch
     */
    travel_time: number;
    /**
     * 
     * @type {RequestArrivalTimePeriod}
     * @memberof RequestTimeFilterFastArrivalOneToManySearch
     */
    arrival_time_period: RequestArrivalTimePeriod;
    /**
     * 
     * @type {Array<RequestTimeFilterFastProperty>}
     * @memberof RequestTimeFilterFastArrivalOneToManySearch
     */
    properties: Array<RequestTimeFilterFastProperty>;
}
/**
 * 
 * @export
 * @interface RequestTimeFilterFastArrivalSearches
 */
export interface RequestTimeFilterFastArrivalSearches {
    /**
     * 
     * @type {Array<RequestTimeFilterFastArrivalManyToOneSearch>}
     * @memberof RequestTimeFilterFastArrivalSearches
     */
    many_to_one?: Array<RequestTimeFilterFastArrivalManyToOneSearch>;
    /**
     * 
     * @type {Array<RequestTimeFilterFastArrivalOneToManySearch>}
     * @memberof RequestTimeFilterFastArrivalSearches
     */
    one_to_many?: Array<RequestTimeFilterFastArrivalOneToManySearch>;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum RequestTimeFilterFastProperty {
    TravelTime = 'travel_time',
    Fares = 'fares'
}

/**
 * 
 * @export
 * @interface RequestTimeFilterPostcodeDistricts
 */
export interface RequestTimeFilterPostcodeDistricts {
    /**
     * 
     * @type {Array<RequestTimeFilterPostcodeDistrictsDepartureSearch>}
     * @memberof RequestTimeFilterPostcodeDistricts
     */
    departure_searches?: Array<RequestTimeFilterPostcodeDistrictsDepartureSearch>;
    /**
     * 
     * @type {Array<RequestTimeFilterPostcodeDistrictsArrivalSearch>}
     * @memberof RequestTimeFilterPostcodeDistricts
     */
    arrival_searches?: Array<RequestTimeFilterPostcodeDistrictsArrivalSearch>;
}
/**
 * 
 * @export
 * @interface RequestTimeFilterPostcodeDistrictsArrivalSearch
 */
export interface RequestTimeFilterPostcodeDistrictsArrivalSearch {
    /**
     * 
     * @type {string}
     * @memberof RequestTimeFilterPostcodeDistrictsArrivalSearch
     */
    id: string;
    /**
     * 
     * @type {RequestTransportation}
     * @memberof RequestTimeFilterPostcodeDistrictsArrivalSearch
     */
    transportation: RequestTransportation;
    /**
     * 
     * @type {number}
     * @memberof RequestTimeFilterPostcodeDistrictsArrivalSearch
     */
    travel_time: number;
    /**
     * 
     * @type {string}
     * @memberof RequestTimeFilterPostcodeDistrictsArrivalSearch
     */
    arrival_time: string;
    /**
     * 
     * @type {number}
     * @memberof RequestTimeFilterPostcodeDistrictsArrivalSearch
     */
    reachable_postcodes_threshold: number;
    /**
     * 
     * @type {Array<RequestTimeFilterPostcodeDistrictsProperty>}
     * @memberof RequestTimeFilterPostcodeDistrictsArrivalSearch
     */
    properties: Array<RequestTimeFilterPostcodeDistrictsProperty>;
    /**
     * 
     * @type {RequestRangeFull}
     * @memberof RequestTimeFilterPostcodeDistrictsArrivalSearch
     */
    range?: RequestRangeFull;
}
/**
 * 
 * @export
 * @interface RequestTimeFilterPostcodeDistrictsDepartureSearch
 */
export interface RequestTimeFilterPostcodeDistrictsDepartureSearch {
    /**
     * 
     * @type {string}
     * @memberof RequestTimeFilterPostcodeDistrictsDepartureSearch
     */
    id: string;
    /**
     * 
     * @type {RequestTransportation}
     * @memberof RequestTimeFilterPostcodeDistrictsDepartureSearch
     */
    transportation: RequestTransportation;
    /**
     * 
     * @type {number}
     * @memberof RequestTimeFilterPostcodeDistrictsDepartureSearch
     */
    travel_time: number;
    /**
     * 
     * @type {string}
     * @memberof RequestTimeFilterPostcodeDistrictsDepartureSearch
     */
    departure_time: string;
    /**
     * 
     * @type {number}
     * @memberof RequestTimeFilterPostcodeDistrictsDepartureSearch
     */
    reachable_postcodes_threshold: number;
    /**
     * 
     * @type {Array<RequestTimeFilterPostcodeDistrictsProperty>}
     * @memberof RequestTimeFilterPostcodeDistrictsDepartureSearch
     */
    properties: Array<RequestTimeFilterPostcodeDistrictsProperty>;
    /**
     * 
     * @type {RequestRangeFull}
     * @memberof RequestTimeFilterPostcodeDistrictsDepartureSearch
     */
    range?: RequestRangeFull;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum RequestTimeFilterPostcodeDistrictsProperty {
    TravelTimeReachable = 'travel_time_reachable',
    TravelTimeAll = 'travel_time_all',
    Coverage = 'coverage'
}

/**
 * 
 * @export
 * @interface RequestTimeFilterPostcodeSectors
 */
export interface RequestTimeFilterPostcodeSectors {
    /**
     * 
     * @type {Array<RequestTimeFilterPostcodeSectorsDepartureSearch>}
     * @memberof RequestTimeFilterPostcodeSectors
     */
    departure_searches?: Array<RequestTimeFilterPostcodeSectorsDepartureSearch>;
    /**
     * 
     * @type {Array<RequestTimeFilterPostcodeSectorsArrivalSearch>}
     * @memberof RequestTimeFilterPostcodeSectors
     */
    arrival_searches?: Array<RequestTimeFilterPostcodeSectorsArrivalSearch>;
}
/**
 * 
 * @export
 * @interface RequestTimeFilterPostcodeSectorsArrivalSearch
 */
export interface RequestTimeFilterPostcodeSectorsArrivalSearch {
    /**
     * 
     * @type {string}
     * @memberof RequestTimeFilterPostcodeSectorsArrivalSearch
     */
    id: string;
    /**
     * 
     * @type {RequestTransportation}
     * @memberof RequestTimeFilterPostcodeSectorsArrivalSearch
     */
    transportation: RequestTransportation;
    /**
     * 
     * @type {number}
     * @memberof RequestTimeFilterPostcodeSectorsArrivalSearch
     */
    travel_time: number;
    /**
     * 
     * @type {string}
     * @memberof RequestTimeFilterPostcodeSectorsArrivalSearch
     */
    arrival_time: string;
    /**
     * 
     * @type {number}
     * @memberof RequestTimeFilterPostcodeSectorsArrivalSearch
     */
    reachable_postcodes_threshold: number;
    /**
     * 
     * @type {Array<RequestTimeFilterPostcodeSectorsProperty>}
     * @memberof RequestTimeFilterPostcodeSectorsArrivalSearch
     */
    properties: Array<RequestTimeFilterPostcodeSectorsProperty>;
    /**
     * 
     * @type {RequestRangeFull}
     * @memberof RequestTimeFilterPostcodeSectorsArrivalSearch
     */
    range?: RequestRangeFull;
}
/**
 * 
 * @export
 * @interface RequestTimeFilterPostcodeSectorsDepartureSearch
 */
export interface RequestTimeFilterPostcodeSectorsDepartureSearch {
    /**
     * 
     * @type {string}
     * @memberof RequestTimeFilterPostcodeSectorsDepartureSearch
     */
    id: string;
    /**
     * 
     * @type {RequestTransportation}
     * @memberof RequestTimeFilterPostcodeSectorsDepartureSearch
     */
    transportation: RequestTransportation;
    /**
     * 
     * @type {number}
     * @memberof RequestTimeFilterPostcodeSectorsDepartureSearch
     */
    travel_time: number;
    /**
     * 
     * @type {string}
     * @memberof RequestTimeFilterPostcodeSectorsDepartureSearch
     */
    departure_time: string;
    /**
     * 
     * @type {number}
     * @memberof RequestTimeFilterPostcodeSectorsDepartureSearch
     */
    reachable_postcodes_threshold: number;
    /**
     * 
     * @type {Array<RequestTimeFilterPostcodeSectorsProperty>}
     * @memberof RequestTimeFilterPostcodeSectorsDepartureSearch
     */
    properties: Array<RequestTimeFilterPostcodeSectorsProperty>;
    /**
     * 
     * @type {RequestRangeFull}
     * @memberof RequestTimeFilterPostcodeSectorsDepartureSearch
     */
    range?: RequestRangeFull;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum RequestTimeFilterPostcodeSectorsProperty {
    TravelTimeReachable = 'travel_time_reachable',
    TravelTimeAll = 'travel_time_all',
    Coverage = 'coverage'
}

/**
 * 
 * @export
 * @interface RequestTimeFilterPostcodes
 */
export interface RequestTimeFilterPostcodes {
    /**
     * 
     * @type {Array<RequestTimeFilterPostcodesDepartureSearch>}
     * @memberof RequestTimeFilterPostcodes
     */
    departure_searches?: Array<RequestTimeFilterPostcodesDepartureSearch>;
    /**
     * 
     * @type {Array<RequestTimeFilterPostcodesArrivalSearch>}
     * @memberof RequestTimeFilterPostcodes
     */
    arrival_searches?: Array<RequestTimeFilterPostcodesArrivalSearch>;
}
/**
 * 
 * @export
 * @interface RequestTimeFilterPostcodesArrivalSearch
 */
export interface RequestTimeFilterPostcodesArrivalSearch {
    /**
     * 
     * @type {string}
     * @memberof RequestTimeFilterPostcodesArrivalSearch
     */
    id: string;
    /**
     * 
     * @type {RequestTransportation}
     * @memberof RequestTimeFilterPostcodesArrivalSearch
     */
    transportation: RequestTransportation;
    /**
     * 
     * @type {number}
     * @memberof RequestTimeFilterPostcodesArrivalSearch
     */
    travel_time: number;
    /**
     * 
     * @type {string}
     * @memberof RequestTimeFilterPostcodesArrivalSearch
     */
    arrival_time: string;
    /**
     * 
     * @type {Array<RequestTimeFilterPostcodesProperty>}
     * @memberof RequestTimeFilterPostcodesArrivalSearch
     */
    properties: Array<RequestTimeFilterPostcodesProperty>;
    /**
     * 
     * @type {RequestRangeFull}
     * @memberof RequestTimeFilterPostcodesArrivalSearch
     */
    range?: RequestRangeFull;
}
/**
 * 
 * @export
 * @interface RequestTimeFilterPostcodesDepartureSearch
 */
export interface RequestTimeFilterPostcodesDepartureSearch {
    /**
     * 
     * @type {string}
     * @memberof RequestTimeFilterPostcodesDepartureSearch
     */
    id: string;
    /**
     * 
     * @type {RequestTransportation}
     * @memberof RequestTimeFilterPostcodesDepartureSearch
     */
    transportation: RequestTransportation;
    /**
     * 
     * @type {number}
     * @memberof RequestTimeFilterPostcodesDepartureSearch
     */
    travel_time: number;
    /**
     * 
     * @type {string}
     * @memberof RequestTimeFilterPostcodesDepartureSearch
     */
    departure_time: string;
    /**
     * 
     * @type {Array<RequestTimeFilterPostcodesProperty>}
     * @memberof RequestTimeFilterPostcodesDepartureSearch
     */
    properties: Array<RequestTimeFilterPostcodesProperty>;
    /**
     * 
     * @type {RequestRangeFull}
     * @memberof RequestTimeFilterPostcodesDepartureSearch
     */
    range?: RequestRangeFull;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum RequestTimeFilterPostcodesProperty {
    TravelTime = 'travel_time',
    Distance = 'distance'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum RequestTimeFilterProperty {
    TravelTime = 'travel_time',
    Distance = 'distance',
    DistanceBreakdown = 'distance_breakdown',
    Fares = 'fares',
    Route = 'route'
}

/**
 * 
 * @export
 * @interface RequestTimeMap
 */
export interface RequestTimeMap {
    /**
     * 
     * @type {Array<RequestTimeMapDepartureSearch>}
     * @memberof RequestTimeMap
     */
    departure_searches?: Array<RequestTimeMapDepartureSearch>;
    /**
     * 
     * @type {Array<RequestTimeMapArrivalSearch>}
     * @memberof RequestTimeMap
     */
    arrival_searches?: Array<RequestTimeMapArrivalSearch>;
    /**
     * 
     * @type {Array<RequestUnionOnIntersection>}
     * @memberof RequestTimeMap
     */
    unions?: Array<RequestUnionOnIntersection>;
    /**
     * 
     * @type {Array<RequestUnionOnIntersection>}
     * @memberof RequestTimeMap
     */
    intersections?: Array<RequestUnionOnIntersection>;
}
/**
 * 
 * @export
 * @interface RequestTimeMapArrivalSearch
 */
export interface RequestTimeMapArrivalSearch {
    /**
     * 
     * @type {string}
     * @memberof RequestTimeMapArrivalSearch
     */
    id: string;
    /**
     * 
     * @type {Coords}
     * @memberof RequestTimeMapArrivalSearch
     */
    coords: Coords;
    /**
     * 
     * @type {RequestTransportation}
     * @memberof RequestTimeMapArrivalSearch
     */
    transportation: RequestTransportation;
    /**
     * 
     * @type {number}
     * @memberof RequestTimeMapArrivalSearch
     */
    travel_time: number;
    /**
     * 
     * @type {string}
     * @memberof RequestTimeMapArrivalSearch
     */
    arrival_time: string;
    /**
     * 
     * @type {Array<RequestTimeMapProperty>}
     * @memberof RequestTimeMapArrivalSearch
     */
    properties?: Array<RequestTimeMapProperty>;
    /**
     * 
     * @type {RequestRangeNoMaxResults}
     * @memberof RequestTimeMapArrivalSearch
     */
    range?: RequestRangeNoMaxResults;
}
/**
 * 
 * @export
 * @interface RequestTimeMapDepartureSearch
 */
export interface RequestTimeMapDepartureSearch {
    /**
     * 
     * @type {string}
     * @memberof RequestTimeMapDepartureSearch
     */
    id: string;
    /**
     * 
     * @type {Coords}
     * @memberof RequestTimeMapDepartureSearch
     */
    coords: Coords;
    /**
     * 
     * @type {RequestTransportation}
     * @memberof RequestTimeMapDepartureSearch
     */
    transportation: RequestTransportation;
    /**
     * 
     * @type {number}
     * @memberof RequestTimeMapDepartureSearch
     */
    travel_time: number;
    /**
     * 
     * @type {string}
     * @memberof RequestTimeMapDepartureSearch
     */
    departure_time: string;
    /**
     * 
     * @type {Array<RequestTimeMapProperty>}
     * @memberof RequestTimeMapDepartureSearch
     */
    properties?: Array<RequestTimeMapProperty>;
    /**
     * 
     * @type {RequestRangeNoMaxResults}
     * @memberof RequestTimeMapDepartureSearch
     */
    range?: RequestRangeNoMaxResults;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum RequestTimeMapProperty {
    IsOnlyWalking = 'is_only_walking'
}

/**
 * 
 * @export
 * @interface RequestTransportation
 */
export interface RequestTransportation {
    /**
     * 
     * @type {string}
     * @memberof RequestTransportation
     */
    type: RequestTransportationTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof RequestTransportation
     */
    pt_change_delay?: number;
    /**
     * 
     * @type {number}
     * @memberof RequestTransportation
     */
    walking_time?: number;
    /**
     * 
     * @type {number}
     * @memberof RequestTransportation
     */
    driving_time_to_station?: number;
    /**
     * 
     * @type {number}
     * @memberof RequestTransportation
     */
    parking_time?: number;
    /**
     * 
     * @type {number}
     * @memberof RequestTransportation
     */
    boarding_time?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum RequestTransportationTypeEnum {
    Cycling = 'cycling',
    Driving = 'driving',
    Drivingtrain = 'driving+train',
    PublicTransport = 'public_transport',
    Walking = 'walking',
    Coach = 'coach',
    Bus = 'bus',
    Train = 'train',
    Ferry = 'ferry',
    Drivingferry = 'driving+ferry',
    Cyclingferry = 'cycling+ferry'
}

/**
 * 
 * @export
 * @interface RequestTransportationFast
 */
export interface RequestTransportationFast {
    /**
     * 
     * @type {string}
     * @memberof RequestTransportationFast
     */
    type: RequestTransportationFastTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum RequestTransportationFastTypeEnum {
    PublicTransport = 'public_transport',
    Driving = 'driving',
    DrivingpublicTransport = 'driving+public_transport'
}

/**
 * 
 * @export
 * @interface RequestUnionOnIntersection
 */
export interface RequestUnionOnIntersection {
    /**
     * 
     * @type {string}
     * @memberof RequestUnionOnIntersection
     */
    id: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RequestUnionOnIntersection
     */
    search_ids: Array<string>;
}
/**
 * 
 * @export
 * @interface ResponseBoundingBox
 */
export interface ResponseBoundingBox {
    /**
     * 
     * @type {ResponseBox}
     * @memberof ResponseBoundingBox
     */
    envelope: ResponseBox;
    /**
     * 
     * @type {Array<ResponseBox>}
     * @memberof ResponseBoundingBox
     */
    boxes: Array<ResponseBox>;
}
/**
 * 
 * @export
 * @interface ResponseBox
 */
export interface ResponseBox {
    /**
     * 
     * @type {number}
     * @memberof ResponseBox
     */
    min_lat: number;
    /**
     * 
     * @type {number}
     * @memberof ResponseBox
     */
    max_lat: number;
    /**
     * 
     * @type {number}
     * @memberof ResponseBox
     */
    min_lng: number;
    /**
     * 
     * @type {number}
     * @memberof ResponseBox
     */
    max_lng: number;
}
/**
 * 
 * @export
 * @interface ResponseDistanceBreakdownItem
 */
export interface ResponseDistanceBreakdownItem {
    /**
     * 
     * @type {ResponseTransportationMode}
     * @memberof ResponseDistanceBreakdownItem
     */
    mode: ResponseTransportationMode;
    /**
     * 
     * @type {number}
     * @memberof ResponseDistanceBreakdownItem
     */
    distance: number;
}
/**
 * 
 * @export
 * @interface ResponseError
 */
export interface ResponseError {
    /**
     * 
     * @type {number}
     * @memberof ResponseError
     */
    http_status?: number;
    /**
     * 
     * @type {number}
     * @memberof ResponseError
     */
    error_code?: number;
    /**
     * 
     * @type {string}
     * @memberof ResponseError
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseError
     */
    documentation_link?: string;
    /**
     * 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof ResponseError
     */
    additional_info?: { [key: string]: Array<string>; };
}
/**
 * 
 * @export
 * @interface ResponseFareTicket
 */
export interface ResponseFareTicket {
    /**
     * 
     * @type {string}
     * @memberof ResponseFareTicket
     */
    type: ResponseFareTicketTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof ResponseFareTicket
     */
    price: number;
    /**
     * 
     * @type {string}
     * @memberof ResponseFareTicket
     */
    currency: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ResponseFareTicketTypeEnum {
    Single = 'single',
    Week = 'week',
    Month = 'month',
    Year = 'year'
}

/**
 * 
 * @export
 * @interface ResponseFares
 */
export interface ResponseFares {
    /**
     * 
     * @type {Array<ResponseFaresBreakdownItem>}
     * @memberof ResponseFares
     */
    breakdown: Array<ResponseFaresBreakdownItem>;
    /**
     * 
     * @type {Array<ResponseFareTicket>}
     * @memberof ResponseFares
     */
    tickets_total: Array<ResponseFareTicket>;
}
/**
 * 
 * @export
 * @interface ResponseFaresBreakdownItem
 */
export interface ResponseFaresBreakdownItem {
    /**
     * 
     * @type {Array<ResponseTransportationMode>}
     * @memberof ResponseFaresBreakdownItem
     */
    modes: Array<ResponseTransportationMode>;
    /**
     * 
     * @type {Array<number>}
     * @memberof ResponseFaresBreakdownItem
     */
    route_part_ids: Array<number>;
    /**
     * 
     * @type {Array<ResponseFareTicket>}
     * @memberof ResponseFaresBreakdownItem
     */
    tickets: Array<ResponseFareTicket>;
}
/**
 * 
 * @export
 * @interface ResponseFaresFast
 */
export interface ResponseFaresFast {
    /**
     * 
     * @type {Array<ResponseFareTicket>}
     * @memberof ResponseFaresFast
     */
    tickets_total: Array<ResponseFareTicket>;
}
/**
 * 
 * @export
 * @interface ResponseGeocoding
 */
export interface ResponseGeocoding {
    /**
     * 
     * @type {string}
     * @memberof ResponseGeocoding
     */
    type: string;
    /**
     * 
     * @type {Array<ResponseGeocodingGeoJsonFeature>}
     * @memberof ResponseGeocoding
     */
    features: Array<ResponseGeocodingGeoJsonFeature>;
}
/**
 * 
 * @export
 * @interface ResponseGeocodingGeoJsonFeature
 */
export interface ResponseGeocodingGeoJsonFeature {
    /**
     * 
     * @type {string}
     * @memberof ResponseGeocodingGeoJsonFeature
     */
    type: string;
    /**
     * 
     * @type {ResponseGeocodingGeometry}
     * @memberof ResponseGeocodingGeoJsonFeature
     */
    geometry: ResponseGeocodingGeometry;
    /**
     * 
     * @type {ResponseGeocodingProperties}
     * @memberof ResponseGeocodingGeoJsonFeature
     */
    properties: ResponseGeocodingProperties;
}
/**
 * 
 * @export
 * @interface ResponseGeocodingGeometry
 */
export interface ResponseGeocodingGeometry {
    /**
     * 
     * @type {string}
     * @memberof ResponseGeocodingGeometry
     */
    type: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof ResponseGeocodingGeometry
     */
    coordinates: Array<number>;
}
/**
 * 
 * @export
 * @interface ResponseGeocodingProperties
 */
export interface ResponseGeocodingProperties {
    /**
     * 
     * @type {string}
     * @memberof ResponseGeocodingProperties
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseGeocodingProperties
     */
    label: string;
    /**
     * 
     * @type {number}
     * @memberof ResponseGeocodingProperties
     */
    score?: number;
    /**
     * 
     * @type {string}
     * @memberof ResponseGeocodingProperties
     */
    house_number?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseGeocodingProperties
     */
    street?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseGeocodingProperties
     */
    region?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseGeocodingProperties
     */
    region_code?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseGeocodingProperties
     */
    neighbourhood?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseGeocodingProperties
     */
    county?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseGeocodingProperties
     */
    macroregion?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseGeocodingProperties
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseGeocodingProperties
     */
    country?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseGeocodingProperties
     */
    country_code?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseGeocodingProperties
     */
    continent?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseGeocodingProperties
     */
    postcode?: string;
    /**
     * 
     * @type {ResponseMapInfoFeatures}
     * @memberof ResponseGeocodingProperties
     */
    features?: ResponseMapInfoFeatures;
}
/**
 * 
 * @export
 * @interface ResponseMapInfo
 */
export interface ResponseMapInfo {
    /**
     * 
     * @type {Array<ResponseMapInfoMap>}
     * @memberof ResponseMapInfo
     */
    maps: Array<ResponseMapInfoMap>;
}
/**
 * 
 * @export
 * @interface ResponseMapInfoFeatures
 */
export interface ResponseMapInfoFeatures {
    /**
     * 
     * @type {ResponseMapInfoFeaturesPublicTransport}
     * @memberof ResponseMapInfoFeatures
     */
    public_transport?: ResponseMapInfoFeaturesPublicTransport;
    /**
     * 
     * @type {boolean}
     * @memberof ResponseMapInfoFeatures
     */
    fares: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ResponseMapInfoFeatures
     */
    postcodes: boolean;
}
/**
 * 
 * @export
 * @interface ResponseMapInfoFeaturesPublicTransport
 */
export interface ResponseMapInfoFeaturesPublicTransport {
    /**
     * 
     * @type {string}
     * @memberof ResponseMapInfoFeaturesPublicTransport
     */
    date_start: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseMapInfoFeaturesPublicTransport
     */
    date_end: string;
}
/**
 * 
 * @export
 * @interface ResponseMapInfoMap
 */
export interface ResponseMapInfoMap {
    /**
     * 
     * @type {string}
     * @memberof ResponseMapInfoMap
     */
    name: string;
    /**
     * 
     * @type {ResponseMapInfoFeatures}
     * @memberof ResponseMapInfoMap
     */
    features: ResponseMapInfoFeatures;
}
/**
 * 
 * @export
 * @interface ResponseRoute
 */
export interface ResponseRoute {
    /**
     * 
     * @type {string}
     * @memberof ResponseRoute
     */
    departure_time: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseRoute
     */
    arrival_time: string;
    /**
     * 
     * @type {Array<ResponseRoutePart>}
     * @memberof ResponseRoute
     */
    parts: Array<ResponseRoutePart>;
}
/**
 * 
 * @export
 * @interface ResponseRoutePart
 */
export interface ResponseRoutePart {
    /**
     * 
     * @type {string}
     * @memberof ResponseRoutePart
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseRoutePart
     */
    type: ResponseRoutePartTypeEnum;
    /**
     * 
     * @type {ResponseTransportationMode}
     * @memberof ResponseRoutePart
     */
    mode: ResponseTransportationMode;
    /**
     * 
     * @type {string}
     * @memberof ResponseRoutePart
     */
    directions: string;
    /**
     * 
     * @type {number}
     * @memberof ResponseRoutePart
     */
    distance: number;
    /**
     * 
     * @type {number}
     * @memberof ResponseRoutePart
     */
    travel_time: number;
    /**
     * 
     * @type {Array<Coords>}
     * @memberof ResponseRoutePart
     */
    coords: Array<Coords>;
    /**
     * 
     * @type {string}
     * @memberof ResponseRoutePart
     */
    direction?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseRoutePart
     */
    road?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseRoutePart
     */
    turn?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseRoutePart
     */
    line?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseRoutePart
     */
    departure_station?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseRoutePart
     */
    arrival_station?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseRoutePart
     */
    departs_at?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseRoutePart
     */
    arrives_at?: string;
    /**
     * 
     * @type {number}
     * @memberof ResponseRoutePart
     */
    num_stops?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum ResponseRoutePartTypeEnum {
    Basic = 'basic',
    StartEnd = 'start_end',
    Road = 'road',
    PublicTransport = 'public_transport'
}

/**
 * 
 * @export
 * @interface ResponseRoutes
 */
export interface ResponseRoutes {
    /**
     * 
     * @type {Array<ResponseRoutesResult>}
     * @memberof ResponseRoutes
     */
    results: Array<ResponseRoutesResult>;
}
/**
 * 
 * @export
 * @interface ResponseRoutesLocation
 */
export interface ResponseRoutesLocation {
    /**
     * 
     * @type {string}
     * @memberof ResponseRoutesLocation
     */
    id: string;
    /**
     * 
     * @type {Array<ResponseRoutesProperties>}
     * @memberof ResponseRoutesLocation
     */
    properties: Array<ResponseRoutesProperties>;
}
/**
 * 
 * @export
 * @interface ResponseRoutesProperties
 */
export interface ResponseRoutesProperties {
    /**
     * 
     * @type {number}
     * @memberof ResponseRoutesProperties
     */
    travel_time?: number;
    /**
     * 
     * @type {number}
     * @memberof ResponseRoutesProperties
     */
    distance?: number;
    /**
     * 
     * @type {ResponseFares}
     * @memberof ResponseRoutesProperties
     */
    fares?: ResponseFares;
    /**
     * 
     * @type {ResponseRoute}
     * @memberof ResponseRoutesProperties
     */
    route?: ResponseRoute;
}
/**
 * 
 * @export
 * @interface ResponseRoutesResult
 */
export interface ResponseRoutesResult {
    /**
     * 
     * @type {string}
     * @memberof ResponseRoutesResult
     */
    search_id: string;
    /**
     * 
     * @type {Array<ResponseRoutesLocation>}
     * @memberof ResponseRoutesResult
     */
    locations: Array<ResponseRoutesLocation>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResponseRoutesResult
     */
    unreachable: Array<string>;
}
/**
 * 
 * @export
 * @interface ResponseShape
 */
export interface ResponseShape {
    /**
     * 
     * @type {Array<Coords>}
     * @memberof ResponseShape
     */
    shell: Array<Coords>;
    /**
     * 
     * @type {Array<Array<Coords>>}
     * @memberof ResponseShape
     */
    holes: Array<Array<Coords>>;
}
/**
 * 
 * @export
 * @interface ResponseSupportedLocation
 */
export interface ResponseSupportedLocation {
    /**
     * 
     * @type {string}
     * @memberof ResponseSupportedLocation
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseSupportedLocation
     */
    map_name: string;
}
/**
 * 
 * @export
 * @interface ResponseSupportedLocations
 */
export interface ResponseSupportedLocations {
    /**
     * 
     * @type {Array<ResponseSupportedLocation>}
     * @memberof ResponseSupportedLocations
     */
    locations: Array<ResponseSupportedLocation>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResponseSupportedLocations
     */
    unsupported_locations: Array<string>;
}
/**
 * 
 * @export
 * @interface ResponseTimeFilter
 */
export interface ResponseTimeFilter {
    /**
     * 
     * @type {Array<ResponseTimeFilterResult>}
     * @memberof ResponseTimeFilter
     */
    results: Array<ResponseTimeFilterResult>;
}
/**
 * 
 * @export
 * @interface ResponseTimeFilterFast
 */
export interface ResponseTimeFilterFast {
    /**
     * 
     * @type {Array<ResponseTimeFilterFastResult>}
     * @memberof ResponseTimeFilterFast
     */
    results: Array<ResponseTimeFilterFastResult>;
}
/**
 * 
 * @export
 * @interface ResponseTimeFilterFastLocation
 */
export interface ResponseTimeFilterFastLocation {
    /**
     * 
     * @type {string}
     * @memberof ResponseTimeFilterFastLocation
     */
    id: string;
    /**
     * 
     * @type {Array<ResponseTimeFilterFastProperties>}
     * @memberof ResponseTimeFilterFastLocation
     */
    properties: Array<ResponseTimeFilterFastProperties>;
}
/**
 * 
 * @export
 * @interface ResponseTimeFilterFastProperties
 */
export interface ResponseTimeFilterFastProperties {
    /**
     * 
     * @type {number}
     * @memberof ResponseTimeFilterFastProperties
     */
    travel_time?: number;
    /**
     * 
     * @type {ResponseFaresFast}
     * @memberof ResponseTimeFilterFastProperties
     */
    fares?: ResponseFaresFast;
}
/**
 * 
 * @export
 * @interface ResponseTimeFilterFastResult
 */
export interface ResponseTimeFilterFastResult {
    /**
     * 
     * @type {string}
     * @memberof ResponseTimeFilterFastResult
     */
    search_id: string;
    /**
     * 
     * @type {Array<ResponseTimeFilterFastLocation>}
     * @memberof ResponseTimeFilterFastResult
     */
    locations: Array<ResponseTimeFilterFastLocation>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResponseTimeFilterFastResult
     */
    unreachable: Array<string>;
}
/**
 * 
 * @export
 * @interface ResponseTimeFilterLocation
 */
export interface ResponseTimeFilterLocation {
    /**
     * 
     * @type {string}
     * @memberof ResponseTimeFilterLocation
     */
    id: string;
    /**
     * 
     * @type {Array<ResponseTimeFilterProperties>}
     * @memberof ResponseTimeFilterLocation
     */
    properties: Array<ResponseTimeFilterProperties>;
}
/**
 * 
 * @export
 * @interface ResponseTimeFilterPostcode
 */
export interface ResponseTimeFilterPostcode {
    /**
     * 
     * @type {string}
     * @memberof ResponseTimeFilterPostcode
     */
    code: string;
    /**
     * 
     * @type {Array<ResponseTimeFilterPostcodesProperties>}
     * @memberof ResponseTimeFilterPostcode
     */
    properties: Array<ResponseTimeFilterPostcodesProperties>;
}
/**
 * 
 * @export
 * @interface ResponseTimeFilterPostcodeDistrict
 */
export interface ResponseTimeFilterPostcodeDistrict {
    /**
     * 
     * @type {string}
     * @memberof ResponseTimeFilterPostcodeDistrict
     */
    code: string;
    /**
     * 
     * @type {ResponseTimeFilterPostcodeDistrictProperties}
     * @memberof ResponseTimeFilterPostcodeDistrict
     */
    properties: ResponseTimeFilterPostcodeDistrictProperties;
}
/**
 * 
 * @export
 * @interface ResponseTimeFilterPostcodeDistrictProperties
 */
export interface ResponseTimeFilterPostcodeDistrictProperties {
    /**
     * 
     * @type {ResponseTravelTimeStatistics}
     * @memberof ResponseTimeFilterPostcodeDistrictProperties
     */
    travel_time_reachable?: ResponseTravelTimeStatistics;
    /**
     * 
     * @type {ResponseTravelTimeStatistics}
     * @memberof ResponseTimeFilterPostcodeDistrictProperties
     */
    travel_time_all?: ResponseTravelTimeStatistics;
    /**
     * 
     * @type {number}
     * @memberof ResponseTimeFilterPostcodeDistrictProperties
     */
    coverage?: number;
}
/**
 * 
 * @export
 * @interface ResponseTimeFilterPostcodeDistricts
 */
export interface ResponseTimeFilterPostcodeDistricts {
    /**
     * 
     * @type {Array<ResponseTimeFilterPostcodeDistrictsResult>}
     * @memberof ResponseTimeFilterPostcodeDistricts
     */
    results: Array<ResponseTimeFilterPostcodeDistrictsResult>;
}
/**
 * 
 * @export
 * @interface ResponseTimeFilterPostcodeDistrictsResult
 */
export interface ResponseTimeFilterPostcodeDistrictsResult {
    /**
     * 
     * @type {string}
     * @memberof ResponseTimeFilterPostcodeDistrictsResult
     */
    search_id: string;
    /**
     * 
     * @type {Array<ResponseTimeFilterPostcodeDistrict>}
     * @memberof ResponseTimeFilterPostcodeDistrictsResult
     */
    districts: Array<ResponseTimeFilterPostcodeDistrict>;
}
/**
 * 
 * @export
 * @interface ResponseTimeFilterPostcodeSector
 */
export interface ResponseTimeFilterPostcodeSector {
    /**
     * 
     * @type {string}
     * @memberof ResponseTimeFilterPostcodeSector
     */
    code: string;
    /**
     * 
     * @type {ResponseTimeFilterPostcodeSectorProperties}
     * @memberof ResponseTimeFilterPostcodeSector
     */
    properties: ResponseTimeFilterPostcodeSectorProperties;
}
/**
 * 
 * @export
 * @interface ResponseTimeFilterPostcodeSectorProperties
 */
export interface ResponseTimeFilterPostcodeSectorProperties {
    /**
     * 
     * @type {ResponseTravelTimeStatistics}
     * @memberof ResponseTimeFilterPostcodeSectorProperties
     */
    travel_time_reachable?: ResponseTravelTimeStatistics;
    /**
     * 
     * @type {ResponseTravelTimeStatistics}
     * @memberof ResponseTimeFilterPostcodeSectorProperties
     */
    travel_time_all?: ResponseTravelTimeStatistics;
    /**
     * 
     * @type {number}
     * @memberof ResponseTimeFilterPostcodeSectorProperties
     */
    coverage?: number;
}
/**
 * 
 * @export
 * @interface ResponseTimeFilterPostcodeSectors
 */
export interface ResponseTimeFilterPostcodeSectors {
    /**
     * 
     * @type {Array<ResponseTimeFilterPostcodeSectorsResult>}
     * @memberof ResponseTimeFilterPostcodeSectors
     */
    results: Array<ResponseTimeFilterPostcodeSectorsResult>;
}
/**
 * 
 * @export
 * @interface ResponseTimeFilterPostcodeSectorsResult
 */
export interface ResponseTimeFilterPostcodeSectorsResult {
    /**
     * 
     * @type {string}
     * @memberof ResponseTimeFilterPostcodeSectorsResult
     */
    search_id: string;
    /**
     * 
     * @type {Array<ResponseTimeFilterPostcodeSector>}
     * @memberof ResponseTimeFilterPostcodeSectorsResult
     */
    sectors: Array<ResponseTimeFilterPostcodeSector>;
}
/**
 * 
 * @export
 * @interface ResponseTimeFilterPostcodes
 */
export interface ResponseTimeFilterPostcodes {
    /**
     * 
     * @type {Array<ResponseTimeFilterPostcodesResult>}
     * @memberof ResponseTimeFilterPostcodes
     */
    results: Array<ResponseTimeFilterPostcodesResult>;
}
/**
 * 
 * @export
 * @interface ResponseTimeFilterPostcodesProperties
 */
export interface ResponseTimeFilterPostcodesProperties {
    /**
     * 
     * @type {number}
     * @memberof ResponseTimeFilterPostcodesProperties
     */
    travel_time?: number;
    /**
     * 
     * @type {number}
     * @memberof ResponseTimeFilterPostcodesProperties
     */
    distance?: number;
}
/**
 * 
 * @export
 * @interface ResponseTimeFilterPostcodesResult
 */
export interface ResponseTimeFilterPostcodesResult {
    /**
     * 
     * @type {string}
     * @memberof ResponseTimeFilterPostcodesResult
     */
    search_id: string;
    /**
     * 
     * @type {Array<ResponseTimeFilterPostcode>}
     * @memberof ResponseTimeFilterPostcodesResult
     */
    postcodes: Array<ResponseTimeFilterPostcode>;
}
/**
 * 
 * @export
 * @interface ResponseTimeFilterProperties
 */
export interface ResponseTimeFilterProperties {
    /**
     * 
     * @type {number}
     * @memberof ResponseTimeFilterProperties
     */
    travel_time?: number;
    /**
     * 
     * @type {number}
     * @memberof ResponseTimeFilterProperties
     */
    distance?: number;
    /**
     * 
     * @type {Array<ResponseDistanceBreakdownItem>}
     * @memberof ResponseTimeFilterProperties
     */
    distance_breakdown?: Array<ResponseDistanceBreakdownItem>;
    /**
     * 
     * @type {ResponseFares}
     * @memberof ResponseTimeFilterProperties
     */
    fares?: ResponseFares;
    /**
     * 
     * @type {ResponseRoute}
     * @memberof ResponseTimeFilterProperties
     */
    route?: ResponseRoute;
}
/**
 * 
 * @export
 * @interface ResponseTimeFilterResult
 */
export interface ResponseTimeFilterResult {
    /**
     * 
     * @type {string}
     * @memberof ResponseTimeFilterResult
     */
    search_id: string;
    /**
     * 
     * @type {Array<ResponseTimeFilterLocation>}
     * @memberof ResponseTimeFilterResult
     */
    locations: Array<ResponseTimeFilterLocation>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResponseTimeFilterResult
     */
    unreachable: Array<string>;
}
/**
 * 
 * @export
 * @interface ResponseTimeMap
 */
export interface ResponseTimeMap {
    /**
     * 
     * @type {Array<ResponseTimeMapResult>}
     * @memberof ResponseTimeMap
     */
    results: Array<ResponseTimeMapResult>;
}
/**
 * 
 * @export
 * @interface ResponseTimeMapBoundingBoxes
 */
export interface ResponseTimeMapBoundingBoxes {
    /**
     * 
     * @type {Array<ResponseTimeMapBoundingBoxesResult>}
     * @memberof ResponseTimeMapBoundingBoxes
     */
    results: Array<ResponseTimeMapBoundingBoxesResult>;
}
/**
 * 
 * @export
 * @interface ResponseTimeMapBoundingBoxesResult
 */
export interface ResponseTimeMapBoundingBoxesResult {
    /**
     * 
     * @type {string}
     * @memberof ResponseTimeMapBoundingBoxesResult
     */
    search_id: string;
    /**
     * 
     * @type {Array<ResponseBoundingBox>}
     * @memberof ResponseTimeMapBoundingBoxesResult
     */
    bounding_boxes: Array<ResponseBoundingBox>;
    /**
     * 
     * @type {ResponseTimeMapProperties}
     * @memberof ResponseTimeMapBoundingBoxesResult
     */
    properties: ResponseTimeMapProperties;
}
/**
 * 
 * @export
 * @interface ResponseTimeMapProperties
 */
export interface ResponseTimeMapProperties {
    /**
     * 
     * @type {boolean}
     * @memberof ResponseTimeMapProperties
     */
    is_only_walking?: boolean;
}
/**
 * 
 * @export
 * @interface ResponseTimeMapResult
 */
export interface ResponseTimeMapResult {
    /**
     * 
     * @type {string}
     * @memberof ResponseTimeMapResult
     */
    search_id: string;
    /**
     * 
     * @type {Array<ResponseShape>}
     * @memberof ResponseTimeMapResult
     */
    shapes: Array<ResponseShape>;
    /**
     * 
     * @type {ResponseTimeMapProperties}
     * @memberof ResponseTimeMapResult
     */
    properties: ResponseTimeMapProperties;
}
/**
 * 
 * @export
 * @interface ResponseTimeMapWkt
 */
export interface ResponseTimeMapWkt {
    /**
     * 
     * @type {Array<ResponseTimeMapWktResult>}
     * @memberof ResponseTimeMapWkt
     */
    results: Array<ResponseTimeMapWktResult>;
}
/**
 * 
 * @export
 * @interface ResponseTimeMapWktResult
 */
export interface ResponseTimeMapWktResult {
    /**
     * 
     * @type {string}
     * @memberof ResponseTimeMapWktResult
     */
    search_id: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseTimeMapWktResult
     */
    shape: string;
    /**
     * 
     * @type {ResponseTimeMapProperties}
     * @memberof ResponseTimeMapWktResult
     */
    properties: ResponseTimeMapProperties;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ResponseTransportationMode {
    Car = 'car',
    Parking = 'parking',
    Boarding = 'boarding',
    Walk = 'walk',
    Bike = 'bike',
    Train = 'train',
    RailNational = 'rail_national',
    RailOverground = 'rail_overground',
    RailUnderground = 'rail_underground',
    RailDlr = 'rail_dlr',
    Bus = 'bus',
    CableCar = 'cable_car',
    Plane = 'plane',
    Ferry = 'ferry',
    Coach = 'coach'
}

/**
 * 
 * @export
 * @interface ResponseTravelTimeStatistics
 */
export interface ResponseTravelTimeStatistics {
    /**
     * 
     * @type {number}
     * @memberof ResponseTravelTimeStatistics
     */
    min: number;
    /**
     * 
     * @type {number}
     * @memberof ResponseTravelTimeStatistics
     */
    max: number;
    /**
     * 
     * @type {number}
     * @memberof ResponseTravelTimeStatistics
     */
    mean: number;
    /**
     * 
     * @type {number}
     * @memberof ResponseTravelTimeStatistics
     */
    median: number;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} lat 
         * @param {number} lng 
         * @param {string} [withinCountry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geocodingReverseSearch: async (lat: number, lng: number, withinCountry?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'lat' is not null or undefined
            assertParamExists('geocodingReverseSearch', 'lat', lat)
            // verify required parameter 'lng' is not null or undefined
            assertParamExists('geocodingReverseSearch', 'lng', lng)
            const localVarPath = `/v4/geocoding/reverse`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApplicationId required
            await setApiKeyToObject(localVarHeaderParameter, "X-Application-Id", configuration)

            if (lat !== undefined) {
                localVarQueryParameter['lat'] = lat;
            }

            if (lng !== undefined) {
                localVarQueryParameter['lng'] = lng;
            }

            if (withinCountry !== undefined) {
                localVarQueryParameter['within.country'] = withinCountry;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} query 
         * @param {number} [focusLat] 
         * @param {number} [focusLng] 
         * @param {string} [withinCountry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geocodingSearch: async (query: string, focusLat?: number, focusLng?: number, withinCountry?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'query' is not null or undefined
            assertParamExists('geocodingSearch', 'query', query)
            const localVarPath = `/v4/geocoding/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApplicationId required
            await setApiKeyToObject(localVarHeaderParameter, "X-Application-Id", configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (focusLat !== undefined) {
                localVarQueryParameter['focus.lat'] = focusLat;
            }

            if (focusLng !== undefined) {
                localVarQueryParameter['focus.lng'] = focusLng;
            }

            if (withinCountry !== undefined) {
                localVarQueryParameter['within.country'] = withinCountry;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mapInfo: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v4/map-info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApplicationId required
            await setApiKeyToObject(localVarHeaderParameter, "X-Application-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RequestRoutes} requestRoutes 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routes: async (requestRoutes: RequestRoutes, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestRoutes' is not null or undefined
            assertParamExists('routes', 'requestRoutes', requestRoutes)
            const localVarPath = `/v4/routes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApplicationId required
            await setApiKeyToObject(localVarHeaderParameter, "X-Application-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestRoutes, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RequestSupportedLocations} requestSupportedLocations 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportedLocations: async (requestSupportedLocations: RequestSupportedLocations, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestSupportedLocations' is not null or undefined
            assertParamExists('supportedLocations', 'requestSupportedLocations', requestSupportedLocations)
            const localVarPath = `/v4/supported-locations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApplicationId required
            await setApiKeyToObject(localVarHeaderParameter, "X-Application-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestSupportedLocations, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RequestTimeFilter} requestTimeFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeFilter: async (requestTimeFilter: RequestTimeFilter, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestTimeFilter' is not null or undefined
            assertParamExists('timeFilter', 'requestTimeFilter', requestTimeFilter)
            const localVarPath = `/v4/time-filter`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApplicationId required
            await setApiKeyToObject(localVarHeaderParameter, "X-Application-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestTimeFilter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RequestTimeFilterFast} requestTimeFilterFast 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeFilterFast: async (requestTimeFilterFast: RequestTimeFilterFast, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestTimeFilterFast' is not null or undefined
            assertParamExists('timeFilterFast', 'requestTimeFilterFast', requestTimeFilterFast)
            const localVarPath = `/v4/time-filter/fast`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApplicationId required
            await setApiKeyToObject(localVarHeaderParameter, "X-Application-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestTimeFilterFast, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RequestTimeFilterPostcodeDistricts} requestTimeFilterPostcodeDistricts 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeFilterPostcodeDistricts: async (requestTimeFilterPostcodeDistricts: RequestTimeFilterPostcodeDistricts, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestTimeFilterPostcodeDistricts' is not null or undefined
            assertParamExists('timeFilterPostcodeDistricts', 'requestTimeFilterPostcodeDistricts', requestTimeFilterPostcodeDistricts)
            const localVarPath = `/v4/time-filter/postcode-districts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApplicationId required
            await setApiKeyToObject(localVarHeaderParameter, "X-Application-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestTimeFilterPostcodeDistricts, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RequestTimeFilterPostcodeSectors} requestTimeFilterPostcodeSectors 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeFilterPostcodeSectors: async (requestTimeFilterPostcodeSectors: RequestTimeFilterPostcodeSectors, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestTimeFilterPostcodeSectors' is not null or undefined
            assertParamExists('timeFilterPostcodeSectors', 'requestTimeFilterPostcodeSectors', requestTimeFilterPostcodeSectors)
            const localVarPath = `/v4/time-filter/postcode-sectors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApplicationId required
            await setApiKeyToObject(localVarHeaderParameter, "X-Application-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestTimeFilterPostcodeSectors, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RequestTimeFilterPostcodes} requestTimeFilterPostcodes 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeFilterPostcodes: async (requestTimeFilterPostcodes: RequestTimeFilterPostcodes, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestTimeFilterPostcodes' is not null or undefined
            assertParamExists('timeFilterPostcodes', 'requestTimeFilterPostcodes', requestTimeFilterPostcodes)
            const localVarPath = `/v4/time-filter/postcodes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApplicationId required
            await setApiKeyToObject(localVarHeaderParameter, "X-Application-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestTimeFilterPostcodes, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RequestTimeMap} requestTimeMap 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeMap: async (requestTimeMap: RequestTimeMap, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestTimeMap' is not null or undefined
            assertParamExists('timeMap', 'requestTimeMap', requestTimeMap)
            const localVarPath = `/v4/time-map`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            // authentication ApplicationId required
            await setApiKeyToObject(localVarHeaderParameter, "X-Application-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestTimeMap, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} lat 
         * @param {number} lng 
         * @param {string} [withinCountry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async geocodingReverseSearch(lat: number, lng: number, withinCountry?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeocoding>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.geocodingReverseSearch(lat, lng, withinCountry, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} query 
         * @param {number} [focusLat] 
         * @param {number} [focusLng] 
         * @param {string} [withinCountry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async geocodingSearch(query: string, focusLat?: number, focusLng?: number, withinCountry?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGeocoding>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.geocodingSearch(query, focusLat, focusLng, withinCountry, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mapInfo(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseMapInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mapInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {RequestRoutes} requestRoutes 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routes(requestRoutes: RequestRoutes, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseRoutes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routes(requestRoutes, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {RequestSupportedLocations} requestSupportedLocations 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supportedLocations(requestSupportedLocations: RequestSupportedLocations, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseSupportedLocations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.supportedLocations(requestSupportedLocations, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {RequestTimeFilter} requestTimeFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async timeFilter(requestTimeFilter: RequestTimeFilter, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseTimeFilter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.timeFilter(requestTimeFilter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {RequestTimeFilterFast} requestTimeFilterFast 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async timeFilterFast(requestTimeFilterFast: RequestTimeFilterFast, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseTimeFilterFast>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.timeFilterFast(requestTimeFilterFast, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {RequestTimeFilterPostcodeDistricts} requestTimeFilterPostcodeDistricts 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async timeFilterPostcodeDistricts(requestTimeFilterPostcodeDistricts: RequestTimeFilterPostcodeDistricts, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseTimeFilterPostcodeDistricts>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.timeFilterPostcodeDistricts(requestTimeFilterPostcodeDistricts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {RequestTimeFilterPostcodeSectors} requestTimeFilterPostcodeSectors 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async timeFilterPostcodeSectors(requestTimeFilterPostcodeSectors: RequestTimeFilterPostcodeSectors, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseTimeFilterPostcodeSectors>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.timeFilterPostcodeSectors(requestTimeFilterPostcodeSectors, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {RequestTimeFilterPostcodes} requestTimeFilterPostcodes 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async timeFilterPostcodes(requestTimeFilterPostcodes: RequestTimeFilterPostcodes, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseTimeFilterPostcodes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.timeFilterPostcodes(requestTimeFilterPostcodes, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {RequestTimeMap} requestTimeMap 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async timeMap(requestTimeMap: RequestTimeMap, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseTimeMap>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.timeMap(requestTimeMap, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @param {number} lat 
         * @param {number} lng 
         * @param {string} [withinCountry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geocodingReverseSearch(lat: number, lng: number, withinCountry?: string, options?: any): AxiosPromise<ResponseGeocoding> {
            return localVarFp.geocodingReverseSearch(lat, lng, withinCountry, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} query 
         * @param {number} [focusLat] 
         * @param {number} [focusLng] 
         * @param {string} [withinCountry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geocodingSearch(query: string, focusLat?: number, focusLng?: number, withinCountry?: string, options?: any): AxiosPromise<ResponseGeocoding> {
            return localVarFp.geocodingSearch(query, focusLat, focusLng, withinCountry, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mapInfo(options?: any): AxiosPromise<ResponseMapInfo> {
            return localVarFp.mapInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RequestRoutes} requestRoutes 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routes(requestRoutes: RequestRoutes, options?: any): AxiosPromise<ResponseRoutes> {
            return localVarFp.routes(requestRoutes, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RequestSupportedLocations} requestSupportedLocations 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportedLocations(requestSupportedLocations: RequestSupportedLocations, options?: any): AxiosPromise<ResponseSupportedLocations> {
            return localVarFp.supportedLocations(requestSupportedLocations, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RequestTimeFilter} requestTimeFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeFilter(requestTimeFilter: RequestTimeFilter, options?: any): AxiosPromise<ResponseTimeFilter> {
            return localVarFp.timeFilter(requestTimeFilter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RequestTimeFilterFast} requestTimeFilterFast 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeFilterFast(requestTimeFilterFast: RequestTimeFilterFast, options?: any): AxiosPromise<ResponseTimeFilterFast> {
            return localVarFp.timeFilterFast(requestTimeFilterFast, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RequestTimeFilterPostcodeDistricts} requestTimeFilterPostcodeDistricts 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeFilterPostcodeDistricts(requestTimeFilterPostcodeDistricts: RequestTimeFilterPostcodeDistricts, options?: any): AxiosPromise<ResponseTimeFilterPostcodeDistricts> {
            return localVarFp.timeFilterPostcodeDistricts(requestTimeFilterPostcodeDistricts, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RequestTimeFilterPostcodeSectors} requestTimeFilterPostcodeSectors 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeFilterPostcodeSectors(requestTimeFilterPostcodeSectors: RequestTimeFilterPostcodeSectors, options?: any): AxiosPromise<ResponseTimeFilterPostcodeSectors> {
            return localVarFp.timeFilterPostcodeSectors(requestTimeFilterPostcodeSectors, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RequestTimeFilterPostcodes} requestTimeFilterPostcodes 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeFilterPostcodes(requestTimeFilterPostcodes: RequestTimeFilterPostcodes, options?: any): AxiosPromise<ResponseTimeFilterPostcodes> {
            return localVarFp.timeFilterPostcodes(requestTimeFilterPostcodes, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RequestTimeMap} requestTimeMap 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeMap(requestTimeMap: RequestTimeMap, options?: any): AxiosPromise<ResponseTimeMap> {
            return localVarFp.timeMap(requestTimeMap, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @param {number} lat 
     * @param {number} lng 
     * @param {string} [withinCountry] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public geocodingReverseSearch(lat: number, lng: number, withinCountry?: string, options?: any) {
        return DefaultApiFp(this.configuration).geocodingReverseSearch(lat, lng, withinCountry, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} query 
     * @param {number} [focusLat] 
     * @param {number} [focusLng] 
     * @param {string} [withinCountry] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public geocodingSearch(query: string, focusLat?: number, focusLng?: number, withinCountry?: string, options?: any) {
        return DefaultApiFp(this.configuration).geocodingSearch(query, focusLat, focusLng, withinCountry, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public mapInfo(options?: any) {
        return DefaultApiFp(this.configuration).mapInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RequestRoutes} requestRoutes 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public routes(requestRoutes: RequestRoutes, options?: any) {
        return DefaultApiFp(this.configuration).routes(requestRoutes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RequestSupportedLocations} requestSupportedLocations 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public supportedLocations(requestSupportedLocations: RequestSupportedLocations, options?: any) {
        return DefaultApiFp(this.configuration).supportedLocations(requestSupportedLocations, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RequestTimeFilter} requestTimeFilter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public timeFilter(requestTimeFilter: RequestTimeFilter, options?: any) {
        return DefaultApiFp(this.configuration).timeFilter(requestTimeFilter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RequestTimeFilterFast} requestTimeFilterFast 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public timeFilterFast(requestTimeFilterFast: RequestTimeFilterFast, options?: any) {
        return DefaultApiFp(this.configuration).timeFilterFast(requestTimeFilterFast, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RequestTimeFilterPostcodeDistricts} requestTimeFilterPostcodeDistricts 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public timeFilterPostcodeDistricts(requestTimeFilterPostcodeDistricts: RequestTimeFilterPostcodeDistricts, options?: any) {
        return DefaultApiFp(this.configuration).timeFilterPostcodeDistricts(requestTimeFilterPostcodeDistricts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RequestTimeFilterPostcodeSectors} requestTimeFilterPostcodeSectors 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public timeFilterPostcodeSectors(requestTimeFilterPostcodeSectors: RequestTimeFilterPostcodeSectors, options?: any) {
        return DefaultApiFp(this.configuration).timeFilterPostcodeSectors(requestTimeFilterPostcodeSectors, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RequestTimeFilterPostcodes} requestTimeFilterPostcodes 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public timeFilterPostcodes(requestTimeFilterPostcodes: RequestTimeFilterPostcodes, options?: any) {
        return DefaultApiFp(this.configuration).timeFilterPostcodes(requestTimeFilterPostcodes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RequestTimeMap} requestTimeMap 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public timeMap(requestTimeMap: RequestTimeMap, options?: any) {
        return DefaultApiFp(this.configuration).timeMap(requestTimeMap, options).then((request) => request(this.axios, this.basePath));
    }
}


