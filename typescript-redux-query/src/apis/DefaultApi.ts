// tslint:disable
/**
 * TravelTime API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.2.3
 * Contact: support@igeolise.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { HttpMethods, QueryConfig, ResponseBody, ResponseText } from 'redux-query';
import * as runtime from '../runtime';
import {
    RequestRoutes,
    RequestRoutesFromJSON,
    RequestRoutesToJSON,
    RequestSupportedLocations,
    RequestSupportedLocationsFromJSON,
    RequestSupportedLocationsToJSON,
    RequestTimeFilter,
    RequestTimeFilterFromJSON,
    RequestTimeFilterToJSON,
    RequestTimeFilterFast,
    RequestTimeFilterFastFromJSON,
    RequestTimeFilterFastToJSON,
    RequestTimeFilterPostcodeDistricts,
    RequestTimeFilterPostcodeDistrictsFromJSON,
    RequestTimeFilterPostcodeDistrictsToJSON,
    RequestTimeFilterPostcodeSectors,
    RequestTimeFilterPostcodeSectorsFromJSON,
    RequestTimeFilterPostcodeSectorsToJSON,
    RequestTimeFilterPostcodes,
    RequestTimeFilterPostcodesFromJSON,
    RequestTimeFilterPostcodesToJSON,
    RequestTimeMap,
    RequestTimeMapFromJSON,
    RequestTimeMapToJSON,
    ResponseError,
    ResponseErrorFromJSON,
    ResponseErrorToJSON,
    ResponseGeocoding,
    ResponseGeocodingFromJSON,
    ResponseGeocodingToJSON,
    ResponseMapInfo,
    ResponseMapInfoFromJSON,
    ResponseMapInfoToJSON,
    ResponseRoutes,
    ResponseRoutesFromJSON,
    ResponseRoutesToJSON,
    ResponseSupportedLocations,
    ResponseSupportedLocationsFromJSON,
    ResponseSupportedLocationsToJSON,
    ResponseTimeFilter,
    ResponseTimeFilterFromJSON,
    ResponseTimeFilterToJSON,
    ResponseTimeFilterFast,
    ResponseTimeFilterFastFromJSON,
    ResponseTimeFilterFastToJSON,
    ResponseTimeFilterPostcodeDistricts,
    ResponseTimeFilterPostcodeDistrictsFromJSON,
    ResponseTimeFilterPostcodeDistrictsToJSON,
    ResponseTimeFilterPostcodeSectors,
    ResponseTimeFilterPostcodeSectorsFromJSON,
    ResponseTimeFilterPostcodeSectorsToJSON,
    ResponseTimeFilterPostcodes,
    ResponseTimeFilterPostcodesFromJSON,
    ResponseTimeFilterPostcodesToJSON,
    ResponseTimeMap,
    ResponseTimeMapFromJSON,
    ResponseTimeMapToJSON,
} from '../models';

export interface GeocodingReverseSearchRequest {
    lat: number;
    lng: number;
    withinCountry?: string;
}

export interface GeocodingSearchRequest {
    query: string;
    focusLat?: number;
    focusLng?: number;
    withinCountry?: string;
}

export interface RoutesRequest {
    requestRoutes: RequestRoutes;
}

export interface SupportedLocationsRequest {
    requestSupportedLocations: RequestSupportedLocations;
}

export interface TimeFilterRequest {
    requestTimeFilter: RequestTimeFilter;
}

export interface TimeFilterFastRequest {
    requestTimeFilterFast: RequestTimeFilterFast;
}

export interface TimeFilterPostcodeDistrictsRequest {
    requestTimeFilterPostcodeDistricts: RequestTimeFilterPostcodeDistricts;
}

export interface TimeFilterPostcodeSectorsRequest {
    requestTimeFilterPostcodeSectors: RequestTimeFilterPostcodeSectors;
}

export interface TimeFilterPostcodesRequest {
    requestTimeFilterPostcodes: RequestTimeFilterPostcodes;
}

export interface TimeMapRequest {
    requestTimeMap: RequestTimeMap;
}


/**
 */
function geocodingReverseSearchRaw<T>(requestParameters: GeocodingReverseSearchRequest, requestConfig: runtime.TypedQueryConfig<T, ResponseGeocoding> = {}): QueryConfig<T> {
    if (requestParameters.lat === null || requestParameters.lat === undefined) {
        throw new runtime.RequiredError('lat','Required parameter requestParameters.lat was null or undefined when calling geocodingReverseSearch.');
    }

    if (requestParameters.lng === null || requestParameters.lng === undefined) {
        throw new runtime.RequiredError('lng','Required parameter requestParameters.lng was null or undefined when calling geocodingReverseSearch.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.lat !== undefined) {
        queryParameters['lat'] = requestParameters.lat;
    }


    if (requestParameters.lng !== undefined) {
        queryParameters['lng'] = requestParameters.lng;
    }


    if (requestParameters.withinCountry !== undefined) {
        queryParameters['within.country'] = requestParameters.withinCountry;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['api_key', 'header'];
    meta.authType = ['api_key', 'header'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v4/geocoding/reverse`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(ResponseGeocodingFromJSON(body), text);
    }

    return config;
}

/**
*/
export function geocodingReverseSearch<T>(requestParameters: GeocodingReverseSearchRequest, requestConfig?: runtime.TypedQueryConfig<T, ResponseGeocoding>): QueryConfig<T> {
    return geocodingReverseSearchRaw(requestParameters, requestConfig);
}

/**
 */
function geocodingSearchRaw<T>(requestParameters: GeocodingSearchRequest, requestConfig: runtime.TypedQueryConfig<T, ResponseGeocoding> = {}): QueryConfig<T> {
    if (requestParameters.query === null || requestParameters.query === undefined) {
        throw new runtime.RequiredError('query','Required parameter requestParameters.query was null or undefined when calling geocodingSearch.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.query !== undefined) {
        queryParameters['query'] = requestParameters.query;
    }


    if (requestParameters.focusLat !== undefined) {
        queryParameters['focus.lat'] = requestParameters.focusLat;
    }


    if (requestParameters.focusLng !== undefined) {
        queryParameters['focus.lng'] = requestParameters.focusLng;
    }


    if (requestParameters.withinCountry !== undefined) {
        queryParameters['within.country'] = requestParameters.withinCountry;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['api_key', 'header'];
    meta.authType = ['api_key', 'header'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v4/geocoding/search`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(ResponseGeocodingFromJSON(body), text);
    }

    return config;
}

/**
*/
export function geocodingSearch<T>(requestParameters: GeocodingSearchRequest, requestConfig?: runtime.TypedQueryConfig<T, ResponseGeocoding>): QueryConfig<T> {
    return geocodingSearchRaw(requestParameters, requestConfig);
}

/**
 */
function mapInfoRaw<T>( requestConfig: runtime.TypedQueryConfig<T, ResponseMapInfo> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['api_key', 'header'];
    meta.authType = ['api_key', 'header'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v4/map-info`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(ResponseMapInfoFromJSON(body), text);
    }

    return config;
}

/**
*/
export function mapInfo<T>( requestConfig?: runtime.TypedQueryConfig<T, ResponseMapInfo>): QueryConfig<T> {
    return mapInfoRaw( requestConfig);
}

/**
 */
function routesRaw<T>(requestParameters: RoutesRequest, requestConfig: runtime.TypedQueryConfig<T, ResponseRoutes> = {}): QueryConfig<T> {
    if (requestParameters.requestRoutes === null || requestParameters.requestRoutes === undefined) {
        throw new runtime.RequiredError('requestRoutes','Required parameter requestParameters.requestRoutes was null or undefined when calling routes.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    meta.authType = ['api_key', 'header'];
    meta.authType = ['api_key', 'header'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v4/routes`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || RequestRoutesToJSON(requestParameters.requestRoutes),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(ResponseRoutesFromJSON(body), text);
    }

    return config;
}

/**
*/
export function routes<T>(requestParameters: RoutesRequest, requestConfig?: runtime.TypedQueryConfig<T, ResponseRoutes>): QueryConfig<T> {
    return routesRaw(requestParameters, requestConfig);
}

/**
 */
function supportedLocationsRaw<T>(requestParameters: SupportedLocationsRequest, requestConfig: runtime.TypedQueryConfig<T, ResponseSupportedLocations> = {}): QueryConfig<T> {
    if (requestParameters.requestSupportedLocations === null || requestParameters.requestSupportedLocations === undefined) {
        throw new runtime.RequiredError('requestSupportedLocations','Required parameter requestParameters.requestSupportedLocations was null or undefined when calling supportedLocations.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    meta.authType = ['api_key', 'header'];
    meta.authType = ['api_key', 'header'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v4/supported-locations`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || RequestSupportedLocationsToJSON(requestParameters.requestSupportedLocations),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(ResponseSupportedLocationsFromJSON(body), text);
    }

    return config;
}

/**
*/
export function supportedLocations<T>(requestParameters: SupportedLocationsRequest, requestConfig?: runtime.TypedQueryConfig<T, ResponseSupportedLocations>): QueryConfig<T> {
    return supportedLocationsRaw(requestParameters, requestConfig);
}

/**
 */
function timeFilterRaw<T>(requestParameters: TimeFilterRequest, requestConfig: runtime.TypedQueryConfig<T, ResponseTimeFilter> = {}): QueryConfig<T> {
    if (requestParameters.requestTimeFilter === null || requestParameters.requestTimeFilter === undefined) {
        throw new runtime.RequiredError('requestTimeFilter','Required parameter requestParameters.requestTimeFilter was null or undefined when calling timeFilter.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    meta.authType = ['api_key', 'header'];
    meta.authType = ['api_key', 'header'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v4/time-filter`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || RequestTimeFilterToJSON(requestParameters.requestTimeFilter),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(ResponseTimeFilterFromJSON(body), text);
    }

    return config;
}

/**
*/
export function timeFilter<T>(requestParameters: TimeFilterRequest, requestConfig?: runtime.TypedQueryConfig<T, ResponseTimeFilter>): QueryConfig<T> {
    return timeFilterRaw(requestParameters, requestConfig);
}

/**
 */
function timeFilterFastRaw<T>(requestParameters: TimeFilterFastRequest, requestConfig: runtime.TypedQueryConfig<T, ResponseTimeFilterFast> = {}): QueryConfig<T> {
    if (requestParameters.requestTimeFilterFast === null || requestParameters.requestTimeFilterFast === undefined) {
        throw new runtime.RequiredError('requestTimeFilterFast','Required parameter requestParameters.requestTimeFilterFast was null or undefined when calling timeFilterFast.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    meta.authType = ['api_key', 'header'];
    meta.authType = ['api_key', 'header'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v4/time-filter/fast`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || RequestTimeFilterFastToJSON(requestParameters.requestTimeFilterFast),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(ResponseTimeFilterFastFromJSON(body), text);
    }

    return config;
}

/**
*/
export function timeFilterFast<T>(requestParameters: TimeFilterFastRequest, requestConfig?: runtime.TypedQueryConfig<T, ResponseTimeFilterFast>): QueryConfig<T> {
    return timeFilterFastRaw(requestParameters, requestConfig);
}

/**
 */
function timeFilterPostcodeDistrictsRaw<T>(requestParameters: TimeFilterPostcodeDistrictsRequest, requestConfig: runtime.TypedQueryConfig<T, ResponseTimeFilterPostcodeDistricts> = {}): QueryConfig<T> {
    if (requestParameters.requestTimeFilterPostcodeDistricts === null || requestParameters.requestTimeFilterPostcodeDistricts === undefined) {
        throw new runtime.RequiredError('requestTimeFilterPostcodeDistricts','Required parameter requestParameters.requestTimeFilterPostcodeDistricts was null or undefined when calling timeFilterPostcodeDistricts.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    meta.authType = ['api_key', 'header'];
    meta.authType = ['api_key', 'header'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v4/time-filter/postcode-districts`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || RequestTimeFilterPostcodeDistrictsToJSON(requestParameters.requestTimeFilterPostcodeDistricts),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(ResponseTimeFilterPostcodeDistrictsFromJSON(body), text);
    }

    return config;
}

/**
*/
export function timeFilterPostcodeDistricts<T>(requestParameters: TimeFilterPostcodeDistrictsRequest, requestConfig?: runtime.TypedQueryConfig<T, ResponseTimeFilterPostcodeDistricts>): QueryConfig<T> {
    return timeFilterPostcodeDistrictsRaw(requestParameters, requestConfig);
}

/**
 */
function timeFilterPostcodeSectorsRaw<T>(requestParameters: TimeFilterPostcodeSectorsRequest, requestConfig: runtime.TypedQueryConfig<T, ResponseTimeFilterPostcodeSectors> = {}): QueryConfig<T> {
    if (requestParameters.requestTimeFilterPostcodeSectors === null || requestParameters.requestTimeFilterPostcodeSectors === undefined) {
        throw new runtime.RequiredError('requestTimeFilterPostcodeSectors','Required parameter requestParameters.requestTimeFilterPostcodeSectors was null or undefined when calling timeFilterPostcodeSectors.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    meta.authType = ['api_key', 'header'];
    meta.authType = ['api_key', 'header'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v4/time-filter/postcode-sectors`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || RequestTimeFilterPostcodeSectorsToJSON(requestParameters.requestTimeFilterPostcodeSectors),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(ResponseTimeFilterPostcodeSectorsFromJSON(body), text);
    }

    return config;
}

/**
*/
export function timeFilterPostcodeSectors<T>(requestParameters: TimeFilterPostcodeSectorsRequest, requestConfig?: runtime.TypedQueryConfig<T, ResponseTimeFilterPostcodeSectors>): QueryConfig<T> {
    return timeFilterPostcodeSectorsRaw(requestParameters, requestConfig);
}

/**
 */
function timeFilterPostcodesRaw<T>(requestParameters: TimeFilterPostcodesRequest, requestConfig: runtime.TypedQueryConfig<T, ResponseTimeFilterPostcodes> = {}): QueryConfig<T> {
    if (requestParameters.requestTimeFilterPostcodes === null || requestParameters.requestTimeFilterPostcodes === undefined) {
        throw new runtime.RequiredError('requestTimeFilterPostcodes','Required parameter requestParameters.requestTimeFilterPostcodes was null or undefined when calling timeFilterPostcodes.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    meta.authType = ['api_key', 'header'];
    meta.authType = ['api_key', 'header'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v4/time-filter/postcodes`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || RequestTimeFilterPostcodesToJSON(requestParameters.requestTimeFilterPostcodes),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(ResponseTimeFilterPostcodesFromJSON(body), text);
    }

    return config;
}

/**
*/
export function timeFilterPostcodes<T>(requestParameters: TimeFilterPostcodesRequest, requestConfig?: runtime.TypedQueryConfig<T, ResponseTimeFilterPostcodes>): QueryConfig<T> {
    return timeFilterPostcodesRaw(requestParameters, requestConfig);
}

/**
 */
function timeMapRaw<T>(requestParameters: TimeMapRequest, requestConfig: runtime.TypedQueryConfig<T, ResponseTimeMap> = {}): QueryConfig<T> {
    if (requestParameters.requestTimeMap === null || requestParameters.requestTimeMap === undefined) {
        throw new runtime.RequiredError('requestTimeMap','Required parameter requestParameters.requestTimeMap was null or undefined when calling timeMap.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    meta.authType = ['api_key', 'header'];
    meta.authType = ['api_key', 'header'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v4/time-map`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || RequestTimeMapToJSON(requestParameters.requestTimeMap),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(ResponseTimeMapFromJSON(body), text);
    }

    return config;
}

/**
*/
export function timeMap<T>(requestParameters: TimeMapRequest, requestConfig?: runtime.TypedQueryConfig<T, ResponseTimeMap>): QueryConfig<T> {
    return timeMapRaw(requestParameters, requestConfig);
}

